// ============================================
// ğŸ“‹ é…ç½®æ•°æ®åŒºï¼ˆé›†ä¸­ç®¡ç†æ‰€æœ‰å¯è‡ªå®šä¹‰é…ç½®ï¼‰
// ============================================
/**
 * çŸ¥è¯†åº“æœç´¢é…ç½®
 * åŒ…å«ç±»å‹é¢„è®¾ã€åŒä¹‰è¯ç»„ã€æ’é™¤è¯ç»„ç­‰æœç´¢ç›¸å…³é…ç½®
 */
const kbSearchConfig = {
  /**
   * åŒä¹‰è¯ç»„é…ç½®ï¼ˆç”¨äºæœç´¢æ‰©å±•ï¼‰
   * â­ è¿™æ˜¯ç”¨æˆ·ç»å¸¸æ‰‹åŠ¨ç»´æŠ¤çš„æ ¸å¿ƒé…ç½®ä¹‹ä¸€
   *
   * @typedef {Object} SynonymGroup
   * @property {string[]} words - åŒä¹‰è¯åˆ—è¡¨ï¼Œç»„å†…çš„è¯ä¼šè¢«è§†ä¸ºç­‰ä»·
   * @property {boolean} [partialReplacement=false] - æ˜¯å¦å¯ç”¨éƒ¨åˆ†æ›¿æ¢æ¨¡å¼
   *   - true: æ”¯æŒå­—ç¬¦çº§åˆ«çš„æ›¿æ¢ï¼Œå¦‚ ||x|| â†” â€–xâ€–
   *   - false: ä»…æ”¯æŒå®Œæ•´è¯åŒ¹é…
   *   - ç¤ºä¾‹ï¼š{"words": ["||", "â€–"], "partialReplacement": true}
   *     â†’ æœç´¢ ||x|| æ—¶ä¼šæ‰©å±•ä¸º â€–xâ€–ï¼Œåä¹‹äº¦ç„¶
   *
   * @property {boolean} [patternMode=false] - æ˜¯å¦å¯ç”¨æ¨¡å¼åŒ¹é…æ¨¡å¼
   *   - true: æ”¯æŒ {{}} å ä½ç¬¦ï¼Œå¯ä»¥åŒ¹é…ä»»æ„å†…å®¹
   *   - false: æ™®é€šåŒä¹‰è¯åŒ¹é…
   *   - ç¤ºä¾‹ï¼š{"words": ["ç¨ {{}}é›†", "ç¨ å¯†{{}}é›†"], "patternMode": true}
   *     â†’ "ç¨ å¼€é›†" ä¼šæ‰©å±•ä¸º "ç¨ å¯†å¼€é›†"
   *
   * @property {boolean} [caseSensitive=false] - æ˜¯å¦å¤§å°å†™æ•æ„Ÿ
   *   - true: ä¸¥æ ¼åŒºåˆ†å¤§å°å†™
   *   - false: å¿½ç•¥å¤§å°å†™
   *   - ç¤ºä¾‹ï¼š{"words": ["Span", "span"], "caseSensitive": true}
   *     â†’ "Span" å’Œ "span" ä¼šè¢«è§†ä¸ºä¸åŒçš„è¯
   *
   * @property {string[]} [contextTriggers] - ä¸Šä¸‹æ–‡è§¦å‘è¯
   *   - ä»…åœ¨æ ‡é¢˜åŒ…å«è¿™äº›è§¦å‘è¯æ—¶æ‰å¯ç”¨è¯¥åŒä¹‰è¯ç»„
   *   - ç”¨äºé¿å…è¯¯åŒ¹é…ï¼ˆå¦‚"æ­£äº¤"å’Œ"æ­£äº¤é›†"ï¼‰
   *   - ç¤ºä¾‹ï¼š{"words": ["å…ƒç´ ", "å‘é‡"], "contextTriggers": ["å†…ç§¯ç©ºé—´", "Hilbert ç©ºé—´"]}
   *     â†’ åªåœ¨æ ‡é¢˜åŒ…å«"å†…ç§¯ç©ºé—´"æˆ–"Hilbert ç©ºé—´"æ—¶æ‰å°†"å…ƒç´ "å’Œ"å‘é‡"è§†ä¸ºåŒä¹‰è¯
   *
   * @property {string} [contextMode="any"] - ä¸Šä¸‹æ–‡åŒ¹é…æ¨¡å¼
   *   - "any": æ»¡è¶³ä»»æ„ä¸€ä¸ªè§¦å‘è¯å³å¯
   *   - "all": éœ€è¦æ»¡è¶³æ‰€æœ‰è§¦å‘è¯
   *
   * @property {string} [id] - åŒä¹‰è¯ç»„çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆå¯é€‰ï¼Œç”¨äºè°ƒè¯•å’Œç®¡ç†ï¼‰
   * @property {boolean} [enabled=true] - æ˜¯å¦å¯ç”¨è¯¥åŒä¹‰è¯ç»„ï¼ˆå¯é€‰ï¼Œé»˜è®¤å¯ç”¨ï¼‰
   *
   * @example
   * // åŸºç¡€åŒä¹‰è¯ç»„ï¼ˆå®Œæ•´è¯åŒ¹é…ï¼‰
   * {"words": ["ä¸¤ä¸¤ä¸åŒ", "ä¸¤ä¸¤ä¸ç­‰", "äº’ä¸ç›¸ç­‰"]}
   *
   * @example
   * // éƒ¨åˆ†æ›¿æ¢æ¨¡å¼ï¼ˆå­—ç¬¦çº§åˆ«æ›¿æ¢ï¼‰
   * {"words": ["||", "â€–"], "partialReplacement": true}
   * // æœç´¢ "||f(x)||" æ—¶ä¼šè‡ªåŠ¨æ‰©å±•ä¸º "â€–f(x)â€–"
   *
   * @example
   * // æ¨¡å¼åŒ¹é…æ¨¡å¼ï¼ˆå ä½ç¬¦æ›¿æ¢ï¼‰
   * {"words": ["ä¸€åˆ—{{}}çš„å¹¶", "{{}}çš„å¯åˆ—å¹¶"], "patternMode": true}
   * // "ä¸€åˆ—å¼€é›†çš„å¹¶" ä¼šæ‰©å±•ä¸º "å¼€é›†çš„å¯åˆ—å¹¶"
   *
   * @example
   * // ä¸Šä¸‹æ–‡æ•æ„Ÿçš„åŒä¹‰è¯
   * {
   *   "words": ["å…ƒç´ ", "å‘é‡"],
   *   "partialReplacement": true,
   *   "caseSensitive": true,
   *   "contextTriggers": ["å†…ç§¯ç©ºé—´", "Hilbert ç©ºé—´"],
   *   "contextMode": "any"
   * }
   */
  synonymGroups: [
    {
      "words": ["é—­å‡¸åŒ…","å‡¸åŒ…çš„é—­åŒ…", "å‡¸ç»„åˆçš„é—­åŒ…"],
    },
    {
      "words": ["å‡¸{{}}é›†", "{{}}å‡¸é›†"],
      "patternMode": true
    },
    {
      "words": ["å±äº{{}}å†…éƒ¨", "æ˜¯{{}}å†…ç‚¹"],
      "patternMode": true
    },
    {
      "words": ["ä¸º", "æ˜¯"],
      "partialReplacement": true,
    },
    {
      "words": ["ä¸¤ä¸¤ä¸åŒ", "ä¸¤ä¸¤ä¸ç­‰", "äº’ä¸ç›¸ç­‰", "å„ä¸ç›¸åŒ", "å„ä¸ç›¸ç­‰", "äº’å¼‚", "ä¸¤ä¸¤ä¸ä¸€æ ·"],
      "partialReplacement":  false,
    },
    {
      "words": ["||", "â€–"],
      "partialReplacement": true,
    },
    {
      "words": ["è¡¨ç¤ºä¸º", "è¡¨ç¤ºæˆ", "å†™æˆ", "å†™ä¸º"],
      "partialReplacement": false,
    },
    {
      "words": ["æ‰©å¼ ", "å»¶æ‹“"],
      "partialReplacement": false,
    },
    {
      "words": ["çº¿æ€§é—­åŒ…", "é—­çº¿æ€§æ‰©å¼ ", "é—­çº¿æ€§å¼ æˆ", "span é—­åŒ…"],
      "partialReplacement": false,
    },
    {
      "words": ["å¤å¯æµ‹å‡½æ•°", "å¯æµ‹å¤å‡½æ•°"],
      "partialReplacement": false,
    },
    {
      "words": ["å®å¯æµ‹å‡½æ•°", "å¯æµ‹å®å‡½æ•°"],
      "partialReplacement": false,
    },
    {
      "words": ["åƒç©ºé—´", "å€¼åŸŸ"],
      "partialReplacement": false,
    },
    {
      "words": ["æ˜¯å…¨ç©ºé—´", "ç­‰äºå…¨ç©ºé—´"],
      "partialReplacement": false,
    },
    {
      "words": ["è‡ªå·±", "è‡ªèº«"],
      "partialReplacement": false,
    },
    {
      "words": ["å¹¶", "å¹¶ä¸Š", "å¹¶é›†"],
      "partialReplacement": false,
    },
    {
      "words": ["äº¤", "äº¤ä¸Š", "äº¤é›†"],
      "partialReplacement": false,
    },
    {
      "words": ["ä¸€åˆ—{{}}çš„å¹¶", "{{}}çš„å¯åˆ—å¹¶"],
      "partialReplacement": false,
      "patternMode": true
    },
    {
      "words": ["ç¨ {{}}é›†", "ç¨ å¯†{{}}é›†","{{}}ç¨ é›†","{{}}ç¨ å¯†é›†"],
      "partialReplacement": false,
      "patternMode": true
    },
    {
      "words": ["ä¸ç›¸äº¤", "äº¤é›†ä¸ºç©º", "äº’ä¸ç›¸äº¤", "äº¤ä¸ºç©º", "äº¤é›†ä¸ºé›¶", "äº¤é›†ä¸ºç©ºé›†"],
      "partialReplacement": false,
    },
    {
      "words": ["[ab]", "[a,b]", "[a, b]"],
      "partialReplacement": false,
    },
    {
      "words": ["[01]", "[0,1]", "[0, 1]"],
      "partialReplacement": false,
    },
    {
      "words": ["ç¬¬äºŒçº²ç©ºé—´", "ç¬¬äºŒçº²çš„ç©ºé—´"],
      "partialReplacement": false,
    },
    {
      "words": ["ç¬¬ä¸€çº²ç©ºé—´", "ç¬¬ä¸€çº²çš„ç©ºé—´"],
      "partialReplacement": false,
    },
    {
      "words": ["å­å¼€é›†", "å¼€å­é›†"],
      "partialReplacement": false,
    },
    {
      "words": ["å­é—­é›†", "é—­å­é›†"],
      "partialReplacement": false,
    },
    {
      "words": ["å­å¼€çƒ", "å¼€å­çƒ"],
      "partialReplacement": false,
    },
    {
      "words": ["å­é—­çƒ", "é—­å­çƒ"],
      "partialReplacement": false,
    },
    {
      "words": ["å­˜åœ¨å†…ç‚¹","åŒ…å«å†…ç‚¹","æœ‰å†…ç‚¹", "å†…éƒ¨éç©º"],
    },
    {
      "words": ["æ— {{}}", "æ²¡æœ‰{{}}"],
      "partialReplacement": false,
      "patternMode": true
    },
    {
      "words": ["é—­åŒ…ç‚¹", "æ¥è§¦ç‚¹", "ç²˜ç€ç‚¹"],
      "partialReplacement": true,
    },
    {
      "words": ["ä¸æ˜¯{{}}", "é{{}}"],
      "partialReplacement": true,
      "patternMode": true
    },
    { "id": "group_1754759704820", "words": ["â‡”", "ç­‰ä»·", "ç­‰ä»·åˆ»ç”»", "ç­‰ä»·æ¡ä»¶", "å½“ä¸”ä»…å½“", "ç­‰ä»·äº"] },
    { "id": "group_1754814563774", "words": ["ä¾èŒƒæ•°æ”¶æ•›", "æŒ‰èŒƒæ•°æ”¶æ•›"] },
    { "id": "group_1754911082498", "words": ["ğ•‹", "å•ä½åœ†å‘¨"] },
    { "id": "group_1754913614715", "words": ["ä¸¥æ ¼æ­£", "ä¸¥æ ¼éè´Ÿ"] },
    { "id": "group_1754913687682", "words": ["ä¸ºé›¶", "ä¸º0", "ç­‰äºé›¶", "ç­‰äº0", "=0", "ä¸º 0", "ç­‰äº 0"], "partialReplacement": true },
    { "id": "group_1754918691589", "words": ["éé›¶", "ä¸æ˜¯é›¶", "ä¸ç­‰äºé›¶", "â‰ 0", "â‰  0", "é0", "é 0", "ä¸æ˜¯0", "ä¸æ˜¯ 0", "ä¸ç­‰äº0", "ä¸ç­‰äº 0", "0â‰ ", "0 â‰ "] },
    { "id": "group_1754967275234", "words": ["å‚…ç«‹å¶", "å‚…é‡Œå¶", "Fourier", "fourier"], "partialReplacement": true },
    { "id": "group_1754968276839", "words": ["âŠ‚", "âŠ†", "å­é›†", "åŒ…å«äº", "åŒ…å«åœ¨"], "partialReplacement": true },
    { "id": "group_1754968768370", "words": ["å®æ•°", "å®æ•°åŸŸ", "å®æƒ…å½¢"] },
    { "id": "group_1754979122102", "words": ["å¾„å‘æé™", "è¾¹ç•Œå€¼å‡½æ•°", "è¾¹ç•Œå‡½æ•°"] },
    { "id": "group_1755230758417", "words": ["æœ‰é™", "<âˆ", "å°äºæ— ç©·", "å°äºâˆ"] },
    { "id": "group_1755231235279", "words": ["æ¯”è¾ƒåˆ¤åˆ«æ³•", "æ¯”å€¼åˆ¤åˆ«æ³•"] },
    { "id": "group_1755313248014", "words": ["-âˆ<", "å¤§äºè´Ÿæ— ç©·", ">-âˆ"] },
    { "id": "group_1755328808715", "words": ["ä¸º1", "ç­‰äº1", "=1", "= 1", "ä¸º 1", "ç­‰äº 1"] },
    { "id": "group_1755330305335", "words": ["æŸ¯è¥¿", "Cauchy", "cauchy"], "partialReplacement": true },
    { "id": "group_1755333690290", "words": ["Blaschke ç§¯", "Blaschke ä¹˜ç§¯"] },
    { "id": "group_1755568637659", "words": ["å¯¹æ•°", "log", "ln"], "partialReplacement": true },
    { "id": "group_1755574929841", "words": ["å°äºç­‰äº", "ä¸è¶…è¿‡", "â‰¤"] },
    { "id": "group_1755837688967", "words": ["Laplace", "Laplacian", "æ‹‰æ™®æ‹‰æ–¯"], "partialReplacement": true },
    { "id": "group_1755838481600", "words": ["å¼€å³åŠå¹³é¢", "â„‚â‚Š", "â„â‚Š"], "partialReplacement": true },
    { "id": "group_1755867678146", "words": ["<0", "å°äºé›¶", "å°äº 0", "< 0", "å°äº0"] },
    { "id": "group_1755871359287", "words": ["å‡ ä¹å¤„å¤„", "a.e."] },
    { "id": "group_1755871688608", "words": ["ç­‰äº", "ç›¸ç­‰", "ç›¸åŒ", "ä¸€è‡´", "ä¸€æ ·", "å°±æ˜¯", "åŒä¸€ä¸ª"] },
    { "id": "group_1756092698001", "words": ["éé›¶å¤åŒæ€", "éé›¶å¯ä¹˜çº¿æ€§æ³›å‡½"] },
    { "id": "group_1756108949936", "words": ["æ˜ å°„ä¸º", "è¢«æ˜ æˆ", "è¢«æ˜ ä¸º", "æ˜ ä¸º", "æ˜ æˆ", "æ˜ åˆ°"] },
    { "id": "group_1756109335070", "words": ["â†’0", "è¶‹äºé›¶", "è¶‹äº 0", "è¶‹äº0", "æ”¶æ•›åˆ°0", "æ”¶æ•›åˆ°é›¶", "æ”¶æ•›åˆ° 0", "åˆ°é›¶", "åˆ°0", "åˆ° 0"], "partialReplacement": true },
    { "id": "group_1756111643605", "words": ["åŒ–å½’ä¸º", "åŒ–å½’åˆ°", "å½’ç»“ä¸º", "å½’ç»“åˆ°", "åŒ–å½’æˆ", "å½’ç»“æˆ"] },
    { "id": "group_1756113664796", "words": ["å¼±æ”¶æ•›æé™", "å¼±æé™", "wæé™", "w æé™"] },
    { "id": "group_1756128051903", "words": ["åˆ—ç´§çš„", "åˆ—ç´§é›†"], "partialReplacement": true },
    { "id": "group_1756182536173", "words": ["è‡ªåçš„", "è‡ªåç©ºé—´"], "partialReplacement": true },
    { "id": "group_1756187328315", "words": ["çº§æ•°å±•å¼€", "çº§æ•°è¡¨ç¤º"], "partialReplacement": true },
    { "id": "group_1756189859522", "words": ["éè´Ÿ", "å¤§äºç­‰äºé›¶", "å¤§äºç­‰äº0", "å¤§äºç­‰äº 0"] },
    { "id": "group_1756194705074", "words": ["Bergman æ ¸", "Bergman å†ç”Ÿæ ¸"] },
    { "id": "group_1756211764991", "words": ["ç›¸ä¹˜", "ä¹˜èµ·æ¥", "ä¹˜ä»¥", "ä¹˜ç§¯"] },
    { "id": "group_1756555538247", "words": ["å¼±æ”¶æ•›", "â‡€"] },
    { "id": "group_1756630934460", "words": ["Gelfand è¡¨ç¤º", "Gelfand æ˜ å°„"], "partialReplacement": true },
    { "id": "group_1756631329614", "words": ["å¯æ•°æ— é™ç»´", "å¯åˆ—æ— é™ç»´", "å¯æ•°æ— ç©·ç»´", "å¯åˆ—æ— ç©·ç»´"] },
    { "id": "group_1756631743105", "words": ["æ ‡å‡†æ­£äº¤", "è§„èŒƒæ­£äº¤"], "partialReplacement": true },
    { "id": "group_1756711035245", "words": ["Ker", "ker", "é›¶ç©ºé—´", "æ ¸ç©ºé—´", "æ ¸"], "partialReplacement": true },
    { "id": "group_1756996762450", "words": ["æ­£äº¤é›†", "æ­£äº¤ç³»"], "partialReplacement": true },
    { "id": "group_1757052040708", "words": ["æ­£äº¤", "å‚ç›´", "æ­£äº¤äº", "å‚ç›´äº"] },
    { "id": "group_1757055108773", "words": ["ä¸€åˆ—è§„èŒƒæ­£äº¤é›†", "ä¸€åˆ—æ ‡å‡†æ­£äº¤é›†", "è§„èŒƒæ­£äº¤åˆ—", "æ ‡å‡†æ­£äº¤åˆ—"] },
    { "id": "group_1757061618814", "words": ["{0}", "é›¶å‘é‡çš„å•ç‚¹é›†"] },
    { "id": "group_1757077322983", "words": ["é—­é›†", "é—­å­é›†"], "contextTriggers": ["å­é›†"], "contextMode": "any" },
    { "id": "group_1757077335882", "words": ["å¼€å­é›†", "å¼€é›†"], "contextTriggers": ["å­é›†"], "contextMode": "any" },
    { "id": "group_1757077345680", "words": ["ç´§é›†", "ç´§å­é›†"], "contextTriggers": ["å­é›†"], "contextMode": "any" },
    { "id": "group_1757088664654", "words": ["å…ƒç´ ", "å‘é‡"], "partialReplacement": true, "caseSensitive": true, "contextTriggers": ["å†…ç§¯ç©ºé—´", "Hilbert ç©ºé—´", "èµ‹èŒƒçº¿æ€§ç©ºé—´", "Banach ç©ºé—´", "çº¿æ€§ç©ºé—´"], "contextMode": "any" },
    { "id": "group_1757143821142", "words": ["æ­£äº¤è¡¥", "^âŠ¥"], "caseSensitive": true },
    { "id": "group_1757164613329", "words": ["è‡³å¤šæ˜¯å¯æ•°", "è‡³å¤šå¯æ•°", "è‡³å¤šå¯åˆ—", "è‡³å¤šæ˜¯å¯åˆ—"] },
    { "id": "group_1757337332491", "words": ["Span", "span", "çº¿æ€§æ‰©å¼ ", "çº¿æ€§å¼ æˆ"], "caseSensitive": true },
    { "id": "group_1757419393384", "words": ["éè´Ÿæ•´æ•°", "âˆˆâ„•"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1757420940564", "words": ["ä»»æ„", "ä»»å–", "ä»»æ„ä¸€ä¸ª", "ä»»å–ä¸€ä¸ª", "æ¯ä¸ª", "æ¯ä¸€ä¸ª"], "caseSensitive": true },
    { "id": "group_1757471519968", "words": ["Ïƒ ä»£æ•°", "Ïƒä»£æ•°", "Ïƒ-ä»£æ•°", "Ïƒ-algebra", "Ïƒ algebra"], "partialReplacement": true },
    { "id": "group_1757487049845", "words": ["èŒƒæ•°æé™", "å¼ºæé™"] },
    { "id": "group_1757666483247", "words": ["éç©º", "éç©ºé›†", "ä¸æ˜¯ç©ºé›†", "ä¸ç©º", "ä¸ç­‰äºç©ºé›†", "â‰ âˆ…", "â‰  âˆ…"], "caseSensitive": true },
    { "id": "group_1757673809311", "words": ["é›†ä»£æ•°", "å¸ƒå°”ä»£æ•°"], "caseSensitive": true },
    { "id": "group_1757675563901", "words": ["ç©ºé›†", "âˆ…"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1757675577813", "words": ["å±äº", "âˆˆ", "åŒ…å«"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1757755186225", "words": ["æ— é™", "âˆ", "æ— ç©·"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1757755714989", "words": ["è¡¥å°é—­", "è¡¥é›†å°é—­", "è¡¥è¿ç®—å°é—­", "è¡¥é›†è¿ç®—å°é—­"] },
    { "id": "group_1757938639733", "words": ["Tâ‚„ ç©ºé—´", "Tâ‚„ æ­£è§„ç©ºé—´", "æ»¡è¶³ Tâ‚ å’Œ Tâ‚„ å…¬ç†çš„æ­£è§„ç©ºé—´", "æ»¡è¶³ Tâ‚‚ å’Œ Tâ‚„ å…¬ç†çš„æ­£è§„ç©ºé—´", "æ»¡è¶³ Tâ‚ å’Œ Tâ‚„ å…¬ç†çš„ç©ºé—´", "æ»¡è¶³ Tâ‚‚ å’Œ Tâ‚„ å…¬ç†çš„ç©ºé—´"], "caseSensitive": true },
    { "id": "group_1758009495957", "words": ["{{}}å°é—­", "{{}}è¿ç®—å°é—­"], "patternMode": true, "caseSensitive": true },
    { "id": "group_1758012441679", "words": ["å•ä½æ¨¡é•¿", "æ¨¡é•¿ç­‰äº1", "æ¨¡é•¿ç­‰äºä¸€", "æ¨¡é•¿ç­‰äº 1", "æ¨¡é•¿ä¸º1", "æ¨¡é•¿ä¸º 1"], "caseSensitive": true },
    { "id": "group_1758087954345", "words": ["ç¨€ç–", "ç–æœ—", "æ— å¤„ç¨ å¯†"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758159036915", "words": ["å¤åŒæ€", "å¯ä¹˜çº¿æ€§æ³›å‡½"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758188346528", "words": ["é—­é›†", "é—­å­é›†"] },
    { "id": "group_1758286476524", "words": ["çº¿æ€§å•å°„", "å•å°„çº¿æ€§"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758286494590", "words": ["çº¿æ€§æ»¡å°„", "æ»¡å°„çº¿æ€§"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758287463421", "words": ["ä¸­çš„{{}}é›†", "{{}}å­é›†"], "patternMode": true, "caseSensitive": true },
    { "id": "group_1758291189939", "words": ["ä¸­é›†åˆ", "ä¸­çš„é›†åˆ", "çš„å­é›†", "ä¸­çš„å­é›†"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758353425664", "words": ["TVS", "æ‹“æ‰‘çº¿æ€§ç©ºé—´", "æ‹“æ‰‘å‘é‡ç©ºé—´", "çº¿æ€§æ‹“æ‰‘ç©ºé—´"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758370279950", "words": ["æœ‰é™æµ‹åº¦", "æµ‹åº¦æœ‰é™"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758448942673", "words": ["ä»»æ„ä¸ªé›†åˆ", "ä»»æ„å¤šä¸ªé›†åˆ", "ä¸€æ—é›†åˆ", "é›†åˆæ—"], "partialReplacement": true },
    { "id": "group_1758454305523", "words": ["ç®—å­å¤åˆ{{}}ç®—å­", "ç®—å­ä¹˜ä»¥{{}}ç®—å­"], "patternMode": true, "caseSensitive": true },
    { "id": "group_1758513747838", "words": ["ç­‰åŠ¿", "åŸºæ•°ç›¸ç­‰", "åŸºæ•°ç›¸åŒ"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758513869003", "words": ["æ‰©å¼ ", "å»¶æ‹“"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758528115814", "words": ["Hilbert-Schmidt", "Hilbertâ€“Schmidt"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758530473198", "words": ["*ç†æƒ³", "* ç†æƒ³", "*-ç†æƒ³", "âˆ—-ç†æƒ³", "âˆ—ç†æƒ³", "âˆ— ç†æƒ³"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758885172459", "words": ["å˜å…ƒ", "å˜é‡"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758886170428", "words": ["å¤æ•°åŸŸ", "å¤æ•°é›†", "å¤å¹³é¢", "â„‚"], "partialReplacement": true },
    { "id": "group_1758980638734", "words": ["æŸ¯è¥¿åˆ—", "Cauchy åˆ—", "æŸ¯è¥¿åºåˆ—", "Cauchy åºåˆ—"], "partialReplacement": true, "caseSensitive": true },
    { "id": "group_1758982023604", "words": ["æ”¶æ•›", "è¶‹äº", "é€¼è¿‘"], "partialReplacement": true, "caseSensitive": true }
  ],

  /**
   * æ’é™¤è¯ç»„é…ç½®ï¼ˆç”¨äºæœç´¢è¿‡æ»¤ï¼‰
   */
  exclusionGroups: [
    {
      "triggerWords": ["ğ”»", "å¼€å•ä½åœ†ç›˜", "å•ä½åœ†ç›˜"],
      "excludeWords": ["é—­å•ä½åœ†ç›˜"]
    },
    {
      "triggerWords": ["åŒ…å«", "åŒ…å«äº†"],
      "excludeWords": ["åŒ…å«äº", "åŒ…å«åœ¨"]
    },
    {
      "triggerWords": ["å¼€å³åŠå¹³é¢", "â„‚â‚Š"],
      "excludeWords": ["å³åŠå¹³é¢"]
    },
    {
      "triggerWords": ["æ­£äº¤é›†", "æ­£äº¤å­é›†"],
      "excludeWords": ["è§„èŒƒæ­£äº¤é›†", "æ ‡å‡†æ­£äº¤é›†"]
    },
    {
      "triggerWords": ["æ­£äº¤"],
      "excludeWords": ["æ­£äº¤é›†", "æ­£äº¤è¡¥", "æ­£äº¤æŠ•å½±", "æ­£äº¤åˆ†è§£"]
    },
    {
      "triggerWords": ["â„"],
      "excludeWords": ["â„Â²", "â„Â³", "â„â¿", "â„áµ", "RÂ²", "RÂ³", "Râ¿", "Ráµ"]
    }
  ],

    /**
   * æœç´¢ç±»å‹é¢„è®¾
   */
  typePresets: {
    all: {
      name: "å…¨éƒ¨ç±»å‹",
      types: ["å®šä¹‰", "å‘½é¢˜", "ä¾‹å­", "åä¾‹", "å½’ç±»", "æ€æƒ³æ–¹æ³•", "é—®é¢˜", "æ€è·¯", "æ€»ç»“"],
      icon: "ğŸ”"
    },
    definitionsAndClassifications: {
      name: "å®šä¹‰ä¸å½’ç±»",
      types: ["å®šä¹‰", "å½’ç±»"],
      icon: "ğŸ“’"
    },
    definitions: {
      name: "ä»…å®šä¹‰",
      types: ["å®šä¹‰"],
      icon: "ğŸ“˜"
    },
    classifications: {
      name: "ä»…å½’ç±»",
      types: ["å½’ç±»"],
      icon: "ğŸ“"
    },
    knowledge: {
      name: "çŸ¥è¯†ç‚¹å¡ç‰‡",
      types: ["å®šä¹‰", "å‘½é¢˜", "ä¾‹å­", "åä¾‹", "æ€æƒ³æ–¹æ³•"],
      icon: "ğŸ“š"
    }
  },
};


/**
 * çŸ¥è¯†åº“æ¨¡æ¿é…ç½®
 * åŒ…å«å¡ç‰‡ç±»å‹ã€æ¨¡æ¿IDã€å­—æ®µæ˜ å°„ç­‰æ ¸å¿ƒé…ç½®
 */
const kbTemplateConfig = {
  /**
   * å•æ¡ HtmlComment çš„æ¨¡æ¿å¡ç‰‡ id
   */
  singleHtmlCommentTemplateNoteIds: {
    "è¯æ˜": "749B2770-77A9-4D3D-9F6F-8B2EE21615AB",
    "åŸç†": "86F237E5-7BA3-4182-A9B9-A135D34CDC3A",
    "åä¾‹": "C33F6700-747F-48FF-999E-3783D596B0CF",
  },

  /**
   * å¡ç‰‡ç±»å‹
   *
   * refName: "xxx"ï¼š"yyy"ç›¸å…³ zz é‡Œçš„ zz
   * prefixName: ã€xxxï¼šyyyyã€‘zzz é‡Œçš„ xxx
   * englishName: å¯¹åº”çš„è‹±æ–‡ç¿»è¯‘
   * templateNoteId: å¯¹åº”æ¨¡æ¿å¡ç‰‡çš„ ID
   * ifIndependent: æ˜¯å¦æ˜¯ç‹¬ç«‹å¡ç‰‡ï¼Œå†³å®šäº†å¡ç‰‡çš„æ ‡é¢˜å¤„ç†æ˜¯æŒ‰ç…§å½’ç±»å¡ç‰‡è¿˜æ˜¯ä¸Šä¸€çº§å¡ç‰‡çš„æ ‡é¢˜è¿›è¡Œå¤„ç†
   * colorIndex: å¯¹åº”çš„å¡ç‰‡é¢œè‰²ç´¢å¼•
   * fields: å­—æ®µ
   */
  types: {
    å®šä¹‰: {
      refName: 'å®šä¹‰',
      prefixName: 'å®šä¹‰',
      englishName: 'definition',
      templateNoteId: '78D28C80-C4AC-48D1-A8E0-BF01908F6B60',
      ifIndependent: false,
      colorIndex: 2,  // æ·¡è“è‰²
      fields: [
        "ç›¸å…³æ€è€ƒ",
        "ç›¸å…³é“¾æ¥"
      ]
    },
    å‘½é¢˜: {
      refName: 'å‘½é¢˜',
      prefixName: 'å‘½é¢˜',
      englishName: 'proposition',
      templateNoteId: 'DDF06F4F-1371-42B2-94C4-111AE7F56CAB',
      ifIndependent: false,
      colorIndex: 10, // æ·±è“è‰²
      fields: [
        "è¯æ˜",
        "ç›¸å…³æ€è€ƒ",
        "å…³é”®è¯ï¼š ",
        "ç›¸å…³é“¾æ¥",
        "åº”ç”¨",
      ]
    },
    ä¾‹å­: {
      refName: 'ä¾‹å­',
      prefixName: 'ä¾‹å­',
      englishName: 'example',
      templateNoteId: 'DDF06F4F-1371-42B2-94C4-111AE7F56CAB',
      ifIndependent: false,
      colorIndex: 7,  // ç´«è‰²
      fields: [
        "è¯æ˜",
        "ç›¸å…³æ€è€ƒ",
        "å…³é”®è¯ï¼š ",
        "ç›¸å…³é“¾æ¥",
        "åº”ç”¨",
      ]
    },
    åä¾‹: {
      refName: 'åä¾‹',
      prefixName: 'åä¾‹',
      englishName: 'counterexample',
      templateNoteId: '4F85B579-FC0E-4657-B0DE-9557EDEB162A',
      ifIndependent: false,
      colorIndex: 3,  // ç²‰è‰²
      fields: [
        "åä¾‹",
        "ç›¸å…³æ€è€ƒ",
        "å…³é”®è¯ï¼š ",
        "ç›¸å…³é“¾æ¥",
        "åº”ç”¨",
      ]
    },
    å½’ç±»: {
      refName: 'å½’ç±»',
      prefixName: 'å½’ç±»',
      englishName: 'classification',
      templateNoteId: '68CFDCBF-5748-448C-91D0-7CE0D98BFE2C',
      ifIndependent: false,
      colorIndex: 0,  // æ·¡é»„è‰²
      fields: [
        "æ‰€å±",
        "ç›¸å…³æ€è€ƒ",
        "åŒ…å«"
      ]
    },
    æ€æƒ³æ–¹æ³•: {
      refName: 'æ€æƒ³æ–¹æ³•',
      prefixName: 'æ€æƒ³æ–¹æ³•',
      englishName: 'thoughtMethod',
      templateNoteId: '38B7FA59-8A23-498D-9954-A389169E5A64',
      ifIndependent: false,
      colorIndex: 9,  // æ·±ç»¿è‰²
      fields: [
        "åŸç†",
        "ç›¸å…³æ€è€ƒ",
        "å…³é”®è¯ï¼š ",
        "ç›¸å…³é“¾æ¥",
        "åº”ç”¨",
      ]
    },
    é—®é¢˜: {
      refName: 'é—®é¢˜',
      prefixName: 'é—®é¢˜',
      englishName: 'question',
      templateNoteId: 'BED89238-9D63-4150-8EB3-4AAF9179D338',
      ifIndependent: false,
      colorIndex: 12,  // æ©™è‰²
      fields: [
        "é—®é¢˜è¯¦æƒ…",
        "ç ”ç©¶è„‰ç»œ",
        "ç ”ç©¶æ€è·¯",
        "ç ”ç©¶ç»“è®º",
        "ç›¸å…³æ€è€ƒ",
        "ç›¸å…³é“¾æ¥",  // ç›¸å…³é“¾æ¥æ”¾åœ¨æœ€åæ˜¯ä¸ºäº†èƒ½å¤Ÿè‡ªåŠ¨è¯†åˆ«æœ€æ–°çš„å†…å®¹ï¼Œæ–¹ä¾¿åç»­ç§»åŠ¨ï¼Œå¦åˆ™å¦‚æœæ˜¯ç›¸å…³æ€è€ƒæ”¾åœ¨æœ€åçš„è¯ï¼Œå°±ä¼šè¢«â€œè¯¯è§¦â€
      ]
    },
    æ€è·¯: {
      refName: 'æ€è·¯',
      prefixName: 'æ€è·¯',
      englishName: 'idea',
      templateNoteId: '6FF1D6DB-3349-4617-9972-FC55BFDCB675',
      ifIndependent: true,
      colorIndex: 5,  // è§å…‰ç»¿
      fields: [
        "æ€è·¯è¯¦æƒ…",
        "å…·ä½“å°è¯•",
        "ç»“è®º",
        "ç›¸å…³æ€è€ƒ",
        "ç›¸å…³é“¾æ¥", // ç›¸å…³é“¾æ¥æ”¾åœ¨æœ€åæ˜¯ä¸ºäº†èƒ½å¤Ÿè‡ªåŠ¨è¯†åˆ«æœ€æ–°çš„å†…å®¹ï¼Œæ–¹ä¾¿åç»­ç§»åŠ¨ï¼Œå¦åˆ™å¦‚æœæ˜¯ç›¸å…³æ€è€ƒæ”¾åœ¨æœ€åçš„è¯ï¼Œå°±ä¼šè¢«â€œè¯¯è§¦â€
      ]
    },
    ä½œè€…: {
      refName: 'ä½œè€…',
      prefixName: 'ä½œè€…',
      englishName: 'author',
      templateNoteId: '143B444E-9E4F-4373-B635-EF909248D8BF',
      ifIndependent: false,
      colorIndex: 2,  // æ·¡è“è‰²
      fields: [
        "ä¸ªäººä¿¡æ¯",
        "ç ”ç©¶è¿›å±•",
        "æ–‡çŒ®",
      ]
    },
    ç ”ç©¶è¿›å±•: {
      refName: 'ç ”ç©¶è¿›å±•',
      prefixName: 'ç ”ç©¶è¿›å±•',
      englishName: 'researchProgress',
      templateNoteId: 'C59D8428-68EA-4161-82BE-EA4314C3B5E9',
      ifIndependent: true,
      colorIndex: 6,  // è“è‰²
      fields: [
        "è¿›å±•è¯¦æƒ…",
        "ç›¸å…³æ€è€ƒ",
        "ç›¸å…³ä½œè€…",
        "è¢«å¼•ç”¨æƒ…å†µ",
      ]
    },
    è®ºæ–‡: {
      refName: 'è®ºæ–‡',
      prefixName: 'è®ºæ–‡',
      englishName: 'paper',
      templateNoteId: '032FC61B-37BD-4A90-AE9D-5A946842F49B',
      ifIndependent: false,
      colorIndex: 11,  // ç´«è‰²
      fields: [
        "æ–‡çŒ®ä¿¡æ¯",
        "ç›¸å…³æ€è€ƒ",
        "ç¬¦å·ä¸çº¦å®š",
        "å‚è€ƒæ–‡çŒ®",
        "è¢«å¼•ç”¨æƒ…å†µ",
      ]
    },
    ä¹¦ä½œ: {
      refName: 'ä¹¦ä½œ',
      prefixName: 'ä¹¦ä½œ',
      englishName: 'book',
      templateNoteId: '032FC61B-37BD-4A90-AE9D-5A946842F49B',
      ifIndependent: false,
      colorIndex: 11,  // ç´«è‰²
      fields: [
        "æ–‡çŒ®ä¿¡æ¯",
        "ç›¸å…³æ€è€ƒ",
        "ç¬¦å·ä¸çº¦å®š",
        "å‚è€ƒæ–‡çŒ®",
        "è¢«å¼•ç”¨æƒ…å†µ",
      ]
    },
    æ–‡çŒ®: {
      refName: 'æ–‡çŒ®',
      prefixName: 'æ–‡çŒ®',
      englishName: 'literature',
      templateNoteId: '032FC61B-37BD-4A90-AE9D-5A946842F49B',
      ifIndependent: false,
      colorIndex: 11,  // ç´«è‰²
      fields: [
        "æ–‡çŒ®ä¿¡æ¯",
        "ç›¸å…³æ€è€ƒ",
        "ç¬¦å·ä¸çº¦å®š",
        "å‚è€ƒæ–‡çŒ®",
        "è¢«å¼•ç”¨æƒ…å†µ",
      ]
    },
    æ€»ç»“: {
      refName: 'æ€»ç»“',
      prefixName: 'æ€»ç»“',
      englishName: 'summary',
      templateNoteId: 'F6FCB6B6-E40A-4937-8918-D53F332CD2D8',
      ifIndependent: true,
      colorIndex: 8,  // æ©™è‰²
      fields: [
        "æ ¸å¿ƒæ€»ç»“",
        "è¦ç‚¹åˆ—ä¸¾",
        "ç›¸å…³æ€è€ƒ",
        "ç›¸å…³é“¾æ¥"
      ]
    },
  },

  /**
   * å…³é”®è¯åˆ°å¡ç‰‡ç±»å‹çš„æ˜ å°„è¡¨
   */
  keywordTypeMapping: {
    "åŸºæœ¬æ€§è´¨": "å‘½é¢˜",
    "åˆ¤å®š": "å‘½é¢˜",
    "æ–¹æ³•": "æ€æƒ³æ–¹æ³•",
    "æ€è·¯": "æ€æƒ³æ–¹æ³•",
  },

  /**
   * é“¾æ¥è¯å¿«æ·çŸ­è¯­åˆ—è¡¨ï¼ˆä»£ç å±‚é¢ç®¡ç†ï¼‰
   * æ”¯æŒ {{}} å ä½ç¬¦ï¼Œä¼šè‡ªåŠ¨æ›¿æ¢ä¸ºè¾“å…¥æ¡†çš„å†…å®¹
   * ä¾‹å¦‚ï¼šçŸ­è¯­ "ä½œä¸º{{}}ç‰¹ä¾‹" + è¾“å…¥ "åº¦é‡ç©ºé—´" â†’ "ä½œä¸ºåº¦é‡ç©ºé—´ç‰¹ä¾‹"
   *       çŸ­è¯­ "ä½œä¸º{{}}ç‰¹ä¾‹" + è¾“å…¥ä¸ºç©º â†’ "ä½œä¸ºç‰¹ä¾‹"
   */
  inlineLinkPhrases: [
    "ä½œä¸º{{}}çš„ç‰¹ä¾‹",
    "{{}}æƒ…å½¢",
    "å› æ­¤",
  ],

  /**
   * çŸ¥è¯†ç‚¹å¡ç‰‡ç±»å‹
   */
  knowledgeNoteTypes: [
    "å®šä¹‰",
    "å‘½é¢˜",
    "ä¾‹å­",
    "åä¾‹",
    "æ€æƒ³æ–¹æ³•",
    "é—®é¢˜",
    "æ€è·¯",
    "æ€»ç»“"
  ],

  /**
   * å¡ç‰‡ç±»å‹ä¸é»˜è®¤ç§»åŠ¨å­—æ®µçš„æ˜ å°„å…³ç³»
   *
   * å®šä¹‰äº†æ¯ç§å¡ç‰‡ç±»å‹çš„æ–°å†…å®¹åº”è¯¥ç§»åŠ¨åˆ°å“ªä¸ªå­—æ®µä¸‹
   * ç”¨äº mergeTemplateAndAutoMoveNoteContent å’Œ autoMoveNewContentByType ç­‰å‡½æ•°
   */
  typeDefaultFieldMap: {
    "å®šä¹‰": "æ‘˜å½•",
    "å‘½é¢˜": "è¯æ˜",
    "åä¾‹": "åä¾‹",
    "ä¾‹å­": "è¯æ˜",
    "æ€æƒ³æ–¹æ³•": "åŸç†",
    "å½’ç±»": "ç›¸å…³æ€è€ƒ",
    "é—®é¢˜": "ç ”ç©¶è„‰ç»œ",
    "æ€è·¯": "å…·ä½“å°è¯•",
    "ä½œè€…": "ä¸ªäººä¿¡æ¯",
    "æ–‡çŒ®": "æ–‡çŒ®ä¿¡æ¯",
    "è®ºæ–‡": "æ–‡çŒ®ä¿¡æ¯",
    "ä¹¦ä½œ": "æ–‡çŒ®ä¿¡æ¯",
    "ç ”ç©¶è¿›å±•": "è¿›å±•è¯¦æƒ…",
    "æ€»ç»“": "è¦ç‚¹åˆ—ä¸¾"
  },

  /**
   * å­—æ®µåˆ«åæ˜ å°„è¡¨
   *
   * å°†é€»è¾‘å­—æ®µåæ˜ å°„åˆ°ä¸åŒå¡ç‰‡ç±»å‹çš„å®é™…å­—æ®µå
   * ä¸»è¦ç”¨äºå¤„ç†åŒä¸€æ€§è´¨ä½†ä¸åŒå‘½åçš„å­—æ®µï¼ˆå¦‚"è¯æ˜"å­—æ®µåœ¨ä¸åŒå¡ç‰‡ç±»å‹ä¸­çš„å¯¹åº”å­—æ®µï¼‰
   *
   * ç»“æ„: { é€»è¾‘å­—æ®µå: { å¡ç‰‡ç±»å‹: å®é™…å­—æ®µå } }
   */
  fieldAliasMapping: {
    "è¯æ˜": {
      "å‘½é¢˜": "è¯æ˜",
      "ä¾‹å­": "è¯æ˜",
      "åä¾‹": "åä¾‹",
      "æ€æƒ³æ–¹æ³•": "åŸç†"
    }
    // å¯æ‰©å±•å…¶ä»–éœ€è¦åˆ«åçš„å­—æ®µ
  },

  /**
   * æ€è·¯é“¾æ¥å­—æ®µæ˜ å°„ï¼ˆéƒ¨åˆ†å¡ç‰‡ç±»å‹åœ¨æ·»åŠ æ€è·¯é“¾æ¥æ—¶ä½¿ç”¨ä¸åŒçš„å­—æ®µï¼‰
   */
  ideaLinkFieldMap: {
    "å‘½é¢˜": "è¯æ˜",
    "ä¾‹å­": "è¯æ˜",
    "åä¾‹": "åä¾‹",
    "æ€æƒ³æ–¹æ³•": "åŸç†",
    "é—®é¢˜": "ç ”ç©¶æ€è·¯"  // æ³¨æ„ï¼šè¿™é‡Œæ˜¯"ç ”ç©¶æ€è·¯"è€Œä¸æ˜¯é»˜è®¤çš„"ç ”ç©¶è„‰ç»œ"
  }
};


/**
 * OCR åå¤„ç†é…ç½®
 * ç”¨äºä¿®æ­£ AI OCR çš„å¸¸è§é”™è¯¯è¾“å‡º
 */
const kbOCRConfig = {
  /**
   * OCR ç»“æœåå¤„ç†æ­£åˆ™æ›¿æ¢è§„åˆ™
   * â­ è¿™æ˜¯ç”¨æˆ·ç»å¸¸æ‰‹åŠ¨ç»´æŠ¤çš„æ ¸å¿ƒé…ç½®ä¹‹ä¸€
   */
  postProcessingRules: [
    {
      pattern: /\^âˆ/g,
      replacement: 'âˆ',
      description: 'ç§»é™¤ç§¯åˆ†/æ±‚å’Œä¸Šé™ä¸­ä¸å¿…è¦çš„ ^'
    },
    {
      pattern: /\s*Ï†|Î¦\s*/g,
      replacement: 'Ï•',
      description: 'ç»Ÿä¸€ phi å­—ç¬¦ä¸ºç›´ç«‹å½¢å¼ (U+03D5)'
    },
    {
      pattern: /âˆ‘/g,
      replacement: 'Î£',
      description: 'æ±‚å’Œç¬¦å·ç”¨å°çš„'
    },
    {
      pattern: /\s*(âŠ‚|âˆª|âˆ©|âŠ†|âŠ‡|âˆˆ|âˆ‰|âŠ„|âŠ…)\s*/g,
      replacement: '$1',
      description: 'å»æ‰é›†åˆè¿ç®—ç¬¦ä¸¤è¾¹çš„ç©ºæ ¼'
    },
    {
      pattern: /\s*(â‰¤|â‰¥|â‰ |â‰ˆ|â‰¡|âˆ|âˆ¼|â‰ƒ|â‰…|â‰ˆ)\s*/g,
      replacement: '$1',
      description: 'å»æ‰æ¯”è¾ƒè¿ç®—ç¬¦ä¸¤è¾¹çš„ç©ºæ ¼'
    },
    {
      pattern: /\s*ï¼Œ|,\s*/g,
      replacement: ", ",
      description: "ç»Ÿä¸€é€—å·æ ¼å¼ï¼ˆä¸­è‹±æ–‡é€—å· + ç©ºæ ¼ï¼‰"
    },
    {
      pattern: /\s*:\s*/g,
      replacement: ": ",
      description: "ç»Ÿä¸€å†’å·æ ¼å¼ï¼ˆå†’å· + ç©ºæ ¼ï¼‰"
    },
    {
      pattern: /\{?(âˆ‚ğ”»)\}?/g,
      replacement: "ğ•‹",
      description: "æ›¿æ¢æ•°å­¦ç¬¦å·ï¼ˆè¾¹ç•Œç¬¦å·ï¼‰"
    },

    // === æ‹¬å·ç¼–å·æ ¼å¼å¤„ç†è§„åˆ™ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰===
    // å¤„ç† (2.2) Corollary. å’Œ ï¼ˆ2.2ï¼‰æ¨è®º ç­‰æ‹¬å·ç¼–å·æ ¼å¼

    // 1. è‹±æ–‡æ‹¬å·ç¼–å· + å…³é”®è¯ + åç§° + å†…å®¹ï¼ˆæœ‰ç‚¹å·ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(Theorem|Lemma|Corollary|Proposition|Definition|Example)\s*\(([^)]+)\)[:.ã€‚]\s*(.+)/ig,
      replacement: '$3; $2',
      description: 'ã€æ‹¬å·ç¼–å·-è‹±æ–‡-æœ‰ç‚¹ã€‘ç§»é™¤ç¼–å·ï¼Œå°†åç§°ç§»åˆ°æœ«å°¾ï¼ˆ(2.2) Corollary. (Name) Content â†’ Content; Nameï¼‰'
    },
    // 2. è‹±æ–‡æ‹¬å·ç¼–å· + å…³é”®è¯ + åç§° + å†…å®¹ï¼ˆæ— ç‚¹å·ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(Theorem|Lemma|Corollary|Proposition|Definition|Example)\s*\(([^)]+)\)\s+(.+)/ig,
      replacement: '$3; $2',
      description: 'ã€æ‹¬å·ç¼–å·-è‹±æ–‡-æ— ç‚¹ã€‘ç§»é™¤ç¼–å·ï¼Œå°†åç§°ç§»åˆ°æœ«å°¾ï¼ˆ(2.2) Corollary (Name) Content â†’ Content; Nameï¼‰'
    },

    // 3. è‹±æ–‡æ‹¬å·ç¼–å· + å…³é”®è¯ + åç§°ï¼ˆæœ‰ç‚¹å·ï¼Œæ— å†…å®¹ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(Theorem|Lemma|Corollary|Proposition|Definition|Example)\s*\(([^)]+)\)[:.ã€‚]\s*$/ig,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-è‹±æ–‡-æœ‰ç‚¹ã€‘ä»…ä¿ç•™åç§°ï¼ˆ(2.2) Theorem. (Name) â†’ Nameï¼‰'
    },
    // 4. è‹±æ–‡æ‹¬å·ç¼–å· + å…³é”®è¯ + åç§°ï¼ˆæ— ç‚¹å·ï¼Œæ— å†…å®¹ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(Theorem|Lemma|Corollary|Proposition|Definition|Example)\s*\(([^)]+)\)\s*$/ig,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-è‹±æ–‡-æ— ç‚¹ã€‘ä»…ä¿ç•™åç§°ï¼ˆ(2.2) Theorem (Name) â†’ Nameï¼‰'
    },

    // 5. è‹±æ–‡æ‹¬å·ç¼–å· + å…³é”®è¯ + å†…å®¹ï¼ˆæœ‰ç‚¹å·ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(Theorem|Lemma|Corollary|Proposition|Definition|Example|Counterexample|Remark|Exercise|Problem)[:.ã€‚]\s+(.+)/ig,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-è‹±æ–‡-æœ‰ç‚¹ã€‘ç§»é™¤ç¼–å·å’Œå…³é”®è¯ï¼ˆ(2.2) Corollary. Content â†’ Contentï¼‰'
    },
    // 6. è‹±æ–‡æ‹¬å·ç¼–å· + å…³é”®è¯ + å†…å®¹ï¼ˆæ— ç‚¹å·ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(Theorem|Lemma|Corollary|Proposition|Definition|Example|Counterexample|Remark|Exercise|Problem)\s+(.+)/ig,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-è‹±æ–‡-æ— ç‚¹ã€‘ç§»é™¤ç¼–å·å’Œå…³é”®è¯ï¼ˆ(2.2) Corollary Content â†’ Contentï¼‰'
    },

    // 7. è‹±æ–‡æ‹¬å·ç¼–å· + å…³é”®è¯ï¼ˆæœ‰ç‚¹å·ï¼Œå…œåº•ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(Theorem|Lemma|Corollary|Proposition|Definition|Example|Counterexample|Remark|Exercise|Problem)[:.ã€‚]\s*$/ig,
      replacement: '',
      description: 'ã€æ‹¬å·ç¼–å·-è‹±æ–‡-æœ‰ç‚¹ã€‘ç§»é™¤æ•´è¡Œï¼ˆ(2.2) Corollary. â†’ ç©ºï¼‰'
    },
    // 8. è‹±æ–‡æ‹¬å·ç¼–å· + å…³é”®è¯ï¼ˆæ— ç‚¹å·ï¼Œå…œåº•ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(Theorem|Lemma|Corollary|Proposition|Definition|Example|Counterexample|Remark|Exercise|Problem)\s*$/ig,
      replacement: '',
      description: 'ã€æ‹¬å·ç¼–å·-è‹±æ–‡-æ— ç‚¹ã€‘ç§»é™¤æ•´è¡Œï¼ˆ(2.2) Corollary â†’ ç©ºï¼‰'
    },

    // 9. ä¸­æ–‡æ‹¬å·ç¼–å·ï¼ˆè‹±æ–‡æ‹¬å·ï¼‰+ å…³é”®è¯ + åç§° + å†…å®¹ï¼ˆæœ‰ç‚¹å·ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰][:.ã€‚]\s*(.+)/g,
      replacement: '$3; $2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-è‹±æ–‡æ‹¬å·-æœ‰ç‚¹ã€‘ç§»é™¤ç¼–å·ï¼Œå°†åç§°ç§»åˆ°æœ«å°¾ï¼ˆ(3.1) æ¨è®º. (åç§°) å†…å®¹ â†’ å†…å®¹; åç§°ï¼‰'
    },
    // 10. ä¸­æ–‡æ‹¬å·ç¼–å·ï¼ˆè‹±æ–‡æ‹¬å·ï¼‰+ å…³é”®è¯ + åç§° + å†…å®¹ï¼ˆæ— ç‚¹å·ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰]\s+(.+)/g,
      replacement: '$3; $2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-è‹±æ–‡æ‹¬å·-æ— ç‚¹ã€‘ç§»é™¤ç¼–å·ï¼Œå°†åç§°ç§»åˆ°æœ«å°¾ï¼ˆ(3.1) æ¨è®º (åç§°) å†…å®¹ â†’ å†…å®¹; åç§°ï¼‰'
    },

    // 11. ä¸­æ–‡æ‹¬å·ç¼–å·ï¼ˆè‹±æ–‡æ‹¬å·ï¼‰+ å…³é”®è¯ + åç§°ï¼ˆæœ‰ç‚¹å·ï¼Œæ— å†…å®¹ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰][:.ã€‚]\s*$/g,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-è‹±æ–‡æ‹¬å·-æœ‰ç‚¹ã€‘ä»…ä¿ç•™åç§°ï¼ˆ(3.1) å®šç†. (åç§°) â†’ åç§°ï¼‰'
    },
    // 12. ä¸­æ–‡æ‹¬å·ç¼–å·ï¼ˆè‹±æ–‡æ‹¬å·ï¼‰+ å…³é”®è¯ + åç§°ï¼ˆæ— ç‚¹å·ï¼Œæ— å†…å®¹ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰]\s*$/g,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-è‹±æ–‡æ‹¬å·-æ— ç‚¹ã€‘ä»…ä¿ç•™åç§°ï¼ˆ(3.1) å®šç† (åç§°) â†’ åç§°ï¼‰'
    },

    // 13. ä¸­æ–‡æ‹¬å·ç¼–å·ï¼ˆè‹±æ–‡æ‹¬å·ï¼‰+ å…³é”®è¯ + å†…å®¹ï¼ˆæœ‰ç‚¹å·ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)[:.ã€‚]\s*(.+)/g,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-è‹±æ–‡æ‹¬å·-æœ‰ç‚¹ã€‘ç§»é™¤ç¼–å·å’Œå…³é”®è¯ï¼ˆ(3.1) æ¨è®º. å†…å®¹ â†’ å†…å®¹ï¼‰'
    },
    // 14. ä¸­æ–‡æ‹¬å·ç¼–å·ï¼ˆè‹±æ–‡æ‹¬å·ï¼‰+ å…³é”®è¯ + å†…å®¹ï¼ˆæ— ç‚¹å·ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)\s+(.+)/g,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-è‹±æ–‡æ‹¬å·-æ— ç‚¹ã€‘ç§»é™¤ç¼–å·å’Œå…³é”®è¯ï¼ˆ(3.1) æ¨è®º å†…å®¹ â†’ å†…å®¹ï¼‰'
    },

    // 15. ä¸­æ–‡æ‹¬å·ç¼–å·ï¼ˆè‹±æ–‡æ‹¬å·ï¼‰+ å…³é”®è¯ï¼ˆæœ‰ç‚¹å·ï¼Œå…œåº•ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)[:.ã€‚]\s*$/g,
      replacement: '',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-è‹±æ–‡æ‹¬å·-æœ‰ç‚¹ã€‘ç§»é™¤æ•´è¡Œï¼ˆ(3.1) æ¨è®º. â†’ ç©ºï¼‰'
    },
    // 16. ä¸­æ–‡æ‹¬å·ç¼–å·ï¼ˆè‹±æ–‡æ‹¬å·ï¼‰+ å…³é”®è¯ï¼ˆæ— ç‚¹å·ï¼Œå…œåº•ï¼‰
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)\s*$/g,
      replacement: '',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-è‹±æ–‡æ‹¬å·-æ— ç‚¹ã€‘ç§»é™¤æ•´è¡Œï¼ˆ(3.1) æ¨è®º â†’ ç©ºï¼‰'
    },

    // 17. ä¸­æ–‡å…¨è§’æ‹¬å·ç¼–å· + å…³é”®è¯ + åç§° + å†…å®¹ï¼ˆæœ‰ç‚¹å·ï¼‰
    {
      pattern: /^ï¼ˆ\d+(?:\.\d+)*ï¼‰\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰][:.ã€‚]\s*(.+)/g,
      replacement: '$3; $2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-å…¨è§’æ‹¬å·-æœ‰ç‚¹ã€‘ç§»é™¤ç¼–å·ï¼Œå°†åç§°ç§»åˆ°æœ«å°¾ï¼ˆï¼ˆ3.1ï¼‰æ¨è®º.ï¼ˆåç§°ï¼‰å†…å®¹ â†’ å†…å®¹; åç§°ï¼‰'
    },
    // 17b. ä¸­æ–‡å…¨è§’æ‹¬å·ç¼–å· + å…³é”®è¯ + åç§° + å†…å®¹ï¼ˆæ— ç‚¹å·ï¼‰
    {
      pattern: /^ï¼ˆ\d+(?:\.\d+)*ï¼‰\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰]\s+(.+)/g,
      replacement: '$3; $2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-å…¨è§’æ‹¬å·-æ— ç‚¹ã€‘ç§»é™¤ç¼–å·ï¼Œå°†åç§°ç§»åˆ°æœ«å°¾ï¼ˆï¼ˆ3.1ï¼‰æ¨è®ºï¼ˆåç§°ï¼‰å†…å®¹ â†’ å†…å®¹; åç§°ï¼‰'
    },

    // 17c. ä¸­æ–‡å…¨è§’æ‹¬å·ç¼–å· + å…³é”®è¯ + åç§°ï¼ˆæœ‰ç‚¹å·ï¼Œæ— å†…å®¹ï¼‰
    {
      pattern: /^ï¼ˆ\d+(?:\.\d+)*ï¼‰\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰][:.ã€‚]\s*$/g,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-å…¨è§’æ‹¬å·-æœ‰ç‚¹ã€‘ä»…ä¿ç•™åç§°ï¼ˆï¼ˆ3.1ï¼‰å®šç†.ï¼ˆåç§°ï¼‰â†’ åç§°ï¼‰'
    },
    // 17d. ä¸­æ–‡å…¨è§’æ‹¬å·ç¼–å· + å…³é”®è¯ + åç§°ï¼ˆæ— ç‚¹å·ï¼Œæ— å†…å®¹ï¼‰
    {
      pattern: /^ï¼ˆ\d+(?:\.\d+)*ï¼‰\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰]\s*$/g,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-å…¨è§’æ‹¬å·-æ— ç‚¹ã€‘ä»…ä¿ç•™åç§°ï¼ˆï¼ˆ3.1ï¼‰å®šç†ï¼ˆåç§°ï¼‰â†’ åç§°ï¼‰'
    },

    // 17e. ä¸­æ–‡å…¨è§’æ‹¬å·ç¼–å· + å…³é”®è¯ + å†…å®¹ï¼ˆæœ‰ç‚¹å·ï¼‰
    {
      pattern: /^ï¼ˆ\d+(?:\.\d+)*ï¼‰\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)[:.ã€‚]\s*(.+)/g,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-å…¨è§’æ‹¬å·-æœ‰ç‚¹ã€‘ç§»é™¤ç¼–å·å’Œå…³é”®è¯ï¼ˆï¼ˆ3.1ï¼‰æ¨è®º. å†…å®¹ â†’ å†…å®¹ï¼‰'
    },
    // 17f. ä¸­æ–‡å…¨è§’æ‹¬å·ç¼–å· + å…³é”®è¯ + å†…å®¹ï¼ˆæ— ç‚¹å·ï¼‰
    {
      pattern: /^ï¼ˆ\d+(?:\.\d+)*ï¼‰\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)\s+(.+)/g,
      replacement: '$2',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-å…¨è§’æ‹¬å·-æ— ç‚¹ã€‘ç§»é™¤ç¼–å·å’Œå…³é”®è¯ï¼ˆï¼ˆ3.1ï¼‰æ¨è®º å†…å®¹ â†’ å†…å®¹ï¼‰'
    },

    // 17g. ä¸­æ–‡å…¨è§’æ‹¬å·ç¼–å· + å…³é”®è¯ï¼ˆæœ‰ç‚¹å·ï¼Œå…œåº•ï¼‰
    {
      pattern: /^ï¼ˆ\d+(?:\.\d+)*ï¼‰\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)[:.ã€‚]\s*$/g,
      replacement: '',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-å…¨è§’æ‹¬å·-æœ‰ç‚¹ã€‘ç§»é™¤æ•´è¡Œï¼ˆï¼ˆ3.1ï¼‰æ¨è®º. â†’ ç©ºï¼‰'
    },
    // 17h. ä¸­æ–‡å…¨è§’æ‹¬å·ç¼–å· + å…³é”®è¯ï¼ˆæ— ç‚¹å·ï¼Œå…œåº•ï¼‰
    {
      pattern: /^ï¼ˆ\d+(?:\.\d+)*ï¼‰\s*(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)\s*$/g,
      replacement: '',
      description: 'ã€æ‹¬å·ç¼–å·-ä¸­æ–‡-å…¨è§’æ‹¬å·-æ— ç‚¹ã€‘ç§»é™¤æ•´è¡Œï¼ˆï¼ˆ3.1ï¼‰æ¨è®º â†’ ç©ºï¼‰'
    },

    // === å®šç†ç¼–å·å¤„ç†è§„åˆ™ï¼ˆæŒ‰å¤æ‚åº¦ä»é«˜åˆ°ä½æ’åˆ—ï¼‰===
    // 1. å¤„ç†å¸¦åç§°+å†…å®¹çš„å®Œæ•´æ ¼å¼ï¼ˆæœ€ä¼˜å…ˆï¼‰
    {
      pattern: /^(Theorem|Lemma|Corollary|Proposition|Definition|Example)\s+\d+(?:\.\d+)*\s*\(([^)]+)\)[:.:]?\s*(.+)/ig,
      replacement: '$3; $2',
      description: 'ç§»é™¤è‹±æ–‡å®šç†ç¼–å·ï¼Œå°†æ‹¬å·åç§°ç§»åˆ°æœ«å°¾'
    },
    {
      pattern: /^(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*\d+(?:\.\d+)*\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰][:.:]?\s*(.+)/g,
      replacement: '$3; $2',
      description: 'ç§»é™¤ä¸­æ–‡å®šç†ç¼–å·ï¼Œå°†æ‹¬å·åç§°ç§»åˆ°æœ«å°¾'
    },

    // 2. å¤„ç†ä»…æœ‰åç§°æ— å†…å®¹çš„æ ¼å¼
    {
      pattern: /^(Theorem|Lemma|Corollary|Proposition|Definition|Example)\s+\d+(?:\.\d+)*\s*\(([^)]+)\)[:.:]?\s*$/ig,
      replacement: '$2',
      description: 'ä»…ä¿ç•™è‹±æ–‡å®šç†åç§°ï¼ˆæ— åç»­å†…å®¹ï¼‰'
    },
    {
      pattern: /^(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*\d+(?:\.\d+)*\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰][:.:]?\s*$/g,
      replacement: '$2',
      description: 'ä»…ä¿ç•™ä¸­æ–‡å®šç†åç§°ï¼ˆæ— åç»­å†…å®¹ï¼‰'
    },

    // 3. ç§»é™¤çº¯ç¼–å·ï¼ˆå…œåº•è§„åˆ™ï¼‰
    {
      pattern: /^(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)\s*\d+(?:\.\d+)*[:.:]?\s*/g,
      replacement: '',
      description: 'ç§»é™¤ä¸­æ–‡å®šç†ç±»çº¯ç¼–å·'
    },
    {
      pattern: /^(Theorem|Lemma|Corollary|Proposition|Example|Counterexample|Remark|Exercise|Problem)\s+\d+(?:\.\d+)*[:.:]?\s*/ig,
      replacement: '',
      description: 'ç§»é™¤è‹±æ–‡å®šç†ç±»çº¯ç¼–å·'
    },

    // === å®šç†ç¼–å·å‰ç½®æ ¼å¼å¤„ç†è§„åˆ™ ===
    // 1. ç¼–å·å‰ç½® + å¸¦åç§° + æœ‰å†…å®¹
    {
      pattern: /^\d+(?:\.\d+)*\s+(Theorem|Lemma|Corollary|Proposition|Definition|Example)\s*\(([^)]+)\)[:.:]?\s*(.+)/ig,
      replacement: '$3; $2',
      description: 'ã€ç¼–å·å‰ç½®-è‹±æ–‡ã€‘ç§»é™¤ç¼–å·ï¼Œå°†åç§°ç§»åˆ°æœ«å°¾ï¼ˆ4.1.3 Theorem (Name) Content â†’ Content; Nameï¼‰'
    },
    {
      pattern: /^\d+(?:\.\d+)*\s+(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰][:.:]?\s*(.+)/g,
      replacement: '$3; $2',
      description: 'ã€ç¼–å·å‰ç½®-ä¸­æ–‡ã€‘ç§»é™¤ç¼–å·ï¼Œå°†åç§°ç§»åˆ°æœ«å°¾ï¼ˆ4.1.3 å®šç† (åç§°) å†…å®¹ â†’ å†…å®¹; åç§°ï¼‰'
    },

    // 2. ç¼–å·å‰ç½® + å¸¦åç§° + æ— å†…å®¹
    {
      pattern: /^\d+(?:\.\d+)*\s+(Theorem|Lemma|Corollary|Proposition|Definition|Example)\s*\(([^)]+)\)[:.:]?\s*$/ig,
      replacement: '$2',
      description: 'ã€ç¼–å·å‰ç½®-è‹±æ–‡ã€‘ä»…ä¿ç•™åç§°ï¼ˆ4.1.3 Theorem (Name) â†’ Nameï¼‰'
    },
    {
      pattern: /^\d+(?:\.\d+)*\s+(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­)\s*[ï¼ˆ(]([^)ï¼‰]+)[)ï¼‰][:.:]?\s*$/g,
      replacement: '$2',
      description: 'ã€ç¼–å·å‰ç½®-ä¸­æ–‡ã€‘ä»…ä¿ç•™åç§°ï¼ˆ4.1.3 å®šç† (åç§°) â†’ åç§°ï¼‰'
    },

    // 3. ç¼–å·å‰ç½® + æ— åç§° + æœ‰å†…å®¹
    {
      pattern: /^\d+(?:\.\d+)*\s+(Theorem|Lemma|Corollary|Proposition|Definition|Example|Counterexample|Remark|Exercise|Problem)[:.:]?\s+(.+)/ig,
      replacement: '$2',
      description: 'ã€ç¼–å·å‰ç½®-è‹±æ–‡ã€‘ç§»é™¤ç¼–å·å’Œå…³é”®è¯ï¼Œä¿ç•™å†…å®¹ï¼ˆ4.1.3 Theorem Content â†’ Contentï¼‰'
    },
    {
      pattern: /^\d+(?:\.\d+)*\s+(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)[:.:]?\s*(.+)/g,
      replacement: '$2',
      description: 'ã€ç¼–å·å‰ç½®-ä¸­æ–‡ã€‘ç§»é™¤ç¼–å·å’Œå…³é”®è¯ï¼Œä¿ç•™å†…å®¹ï¼ˆ4.1.3 å®šç† å†…å®¹ â†’ å†…å®¹ï¼‰'
    },

    // 4. ç¼–å·å‰ç½® + æ— åç§° + æ— å†…å®¹ï¼ˆå…œåº•ï¼‰
    {
      pattern: /^\d+(?:\.\d+)*\s+(Theorem|Lemma|Corollary|Proposition|Definition|Example|Counterexample|Remark|Exercise|Problem)[:.:]?\s*$/ig,
      replacement: '',
      description: 'ã€ç¼–å·å‰ç½®-è‹±æ–‡ã€‘ç§»é™¤æ•´è¡Œï¼ˆ4.1.3 Theorem â†’ ç©ºï¼‰'
    },
    {
      pattern: /^\d+(?:\.\d+)*\s+(å®šç†|å¼•ç†|æ¨è®º|å‘½é¢˜|å®šä¹‰|ä¾‹å­|ä¾‹|åä¾‹|æ³¨é‡Š|æ³¨|ç»ƒä¹ |ä¹ é¢˜|é—®é¢˜|é¢˜)[:.:]?\s*$/g,
      replacement: '',
      description: 'ã€ç¼–å·å‰ç½®-ä¸­æ–‡ã€‘ç§»é™¤æ•´è¡Œï¼ˆ4.1.3 å®šç† â†’ ç©ºï¼‰'
    },

    // === Question é—®å·å¼ºåˆ¶è§„åˆ™ ===
    {
      pattern: /^Question[:.:]?\s*(.+[^?])$/ig,
      replacement: '$1?',
      description: 'ã€Questionã€‘ç¡®ä¿ä»¥é—®å·ç»“å°¾ï¼ˆQuestion: What is X â†’ What is X?ï¼‰'
    },

    // === Conjecture/çŒœæƒ³ ç‰¹æ®Šå¤„ç†è§„åˆ™ ===
    // 1. æ‹¬å·ç¼–å· + Conjecture + å†…å®¹
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*Conjecture[:.ã€‚]?\s*(.+)/ig,
      replacement: 'Conjecture: $1',
      description: 'ã€Conjecture-æ‹¬å·ç¼–å·ã€‘ç§»é™¤ç¼–å·ï¼Œä¿ç•™å…³é”®è¯ï¼ˆ(6.3) Conjecture Content â†’ Conjecture: Contentï¼‰'
    },
    // 2. ç¼–å·å‰ç½® + Conjecture + å†…å®¹
    {
      pattern: /^\d+(?:\.\d+)*\s+Conjecture[:.ã€‚]?\s*(.+)/ig,
      replacement: 'Conjecture: $1',
      description: 'ã€Conjecture-ç¼–å·å‰ç½®ã€‘ç§»é™¤ç¼–å·ï¼Œä¿ç•™å…³é”®è¯ï¼ˆ6.3 Conjecture Content â†’ Conjecture: Contentï¼‰'
    },
    // 3. æ‹¬å·ç¼–å· + çŒœæƒ³ + å†…å®¹
    {
      pattern: /^\(\d+(?:\.\d+)*\)\s*çŒœæƒ³[:.ã€‚]?\s*(.+)/g,
      replacement: 'çŒœæƒ³ï¼š$1',
      description: 'ã€çŒœæƒ³-æ‹¬å·ç¼–å·ã€‘ç§»é™¤ç¼–å·ï¼Œä¿ç•™å…³é”®è¯ï¼ˆ(6.3) çŒœæƒ³ å†…å®¹ â†’ çŒœæƒ³ï¼šå†…å®¹ï¼‰'
    },
    // 4. ç¼–å·å‰ç½® + çŒœæƒ³ + å†…å®¹
    {
      pattern: /^\d+(?:\.\d+)*\s+çŒœæƒ³[:.ã€‚]?\s*(.+)/g,
      replacement: 'çŒœæƒ³ï¼š$1',
      description: 'ã€çŒœæƒ³-ç¼–å·å‰ç½®ã€‘ç§»é™¤ç¼–å·ï¼Œä¿ç•™å…³é”®è¯ï¼ˆ6.3 çŒœæƒ³ å†…å®¹ â†’ çŒœæƒ³ï¼šå†…å®¹ï¼‰'
    },
    // 5. å…¨è§’æ‹¬å·ç¼–å· + çŒœæƒ³ + å†…å®¹
    {
      pattern: /^ï¼ˆ\d+(?:\.\d+)*ï¼‰\s*çŒœæƒ³[:.ã€‚]?\s*(.+)/g,
      replacement: 'çŒœæƒ³ï¼š$1',
      description: 'ã€çŒœæƒ³-å…¨è§’æ‹¬å·ã€‘ç§»é™¤ç¼–å·ï¼Œä¿ç•™å…³é”®è¯ï¼ˆï¼ˆ6.3ï¼‰çŒœæƒ³ å†…å®¹ â†’ çŒœæƒ³ï¼šå†…å®¹ï¼‰'
    },

    {
      pattern: /C_Ï•/g,
      replacement: "Cáµ©",
      description: "æ›¿æ¢ä¸‹æ ‡ phi ç¬¦å·"
    },
    {
      pattern: /limâ€¾/g,
      replacement: "limsup",
      description: "æ›¿æ¢æé™ç¬¦å·ï¼ˆä¸Šæé™ï¼‰"
    },
    {
      pattern: /å¦‚æœ/g,
      replacement: "è‹¥",
      description: "ç®€åŒ–æ¡ä»¶è¯"
    },
    {
      pattern: /é‚£ä¹ˆ/g,
      replacement: "åˆ™",
      description: "ç®€åŒ–ç»“è®ºè¯"
    },
    {
      pattern: /[ã€‚ï¼Œã€ï¼›ï¼šï¼ï¼Ÿ,.;:!?\s]+$/g,
      replacement: "",
      description: "ç§»é™¤æ–‡æœ¬æœ«å°¾çš„æ ‡ç‚¹ç¬¦å·å’Œç©ºæ ¼"
    },
    {
      pattern: /å¯è¯æ˜|è¯æ˜|å¯çŸ¥/g,
      replacement: "å¾—",
      description: "ç®€åŒ–æ¨ç†è¯"
    },
    {
      pattern: /â‚â‰¤â‚–â‰¤â‚™/g,
      replacement: "_{1â‰¤kâ‰¤n}",
      description: "ä¸‹æ ‡æ ¼å¼åŒ–"
    },
    {
      pattern: /LáµƒÂ²/g,
      replacement: "LÂ²â‚",
      description: "è°ƒæ•´ä¸Šä¸‹æ ‡é¡ºåº"
    },
    {
      pattern: /å¸Œå°”ä¼¯ç‰¹/g,
      replacement: " Hilbert ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ³›å‡½åˆ†æï¼šHilbert ç©ºé—´ï¼‰"
    },

    // === æ•°å­¦å®¶äººåä¸­è‹±æ–‡è½¬æ¢è§„åˆ™ ===
    // ã€åˆ†æå­¦ã€‘
    {
      pattern: /é˜¿è´å°”/g,
      replacement: " Abel ",
    },
    {
      pattern: /æŸ¯è¥¿/g,
      replacement: " Cauchy ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆåˆ†æå­¦ï¼šCauchy åºåˆ—ã€Cauchy å®šç†ï¼‰"
    },
    {
      pattern: /é»æ›¼/g,
      replacement: " Riemann ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆåˆ†æå­¦ï¼šRiemann ç§¯åˆ†ã€Riemann å‡ ä½•ï¼‰"
    },
    {
      pattern: /å‹’è´æ ¼/g,
      replacement: " Lebesgue ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæµ‹åº¦è®ºï¼šLebesgue ç§¯åˆ†ã€Lebesgue æµ‹åº¦ï¼‰"
    },
    {
      pattern: /é­å°”æ–¯ç‰¹æ‹‰æ–¯/g,
      replacement: " Weierstrass ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆåˆ†æå­¦ï¼šWeierstrass é€¼è¿‘å®šç†ï¼‰"
    },
    {
      pattern: /å‚…é‡Œå¶/g,
      replacement: " Fourier ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆåˆ†æå­¦ï¼šFourier çº§æ•°ã€Fourier å˜æ¢ï¼‰"
    },
    {
      pattern: /æ‹‰æ™®æ‹‰æ–¯/g,
      replacement: " Laplace ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆåˆ†æå­¦ï¼šLaplace å˜æ¢ã€Laplace æ–¹ç¨‹ï¼‰"
    },
    {
      pattern: /ç‹„åˆ©å…‹é›·/g,
      replacement: " Dirichlet ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆåˆ†æå­¦ï¼šDirichlet çº§æ•°ï¼‰"
    },
    {
      pattern: /æ¬§æ‹‰/g,
      replacement: " Euler ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆåˆ†æå­¦ï¼šEuler å…¬å¼ã€Euler å¸¸æ•°ï¼‰"
    },
    {
      pattern: /æ³°å‹’/g,
      replacement: " Taylor ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆåˆ†æå­¦ï¼šTaylor çº§æ•°ï¼‰"
    },
    {
      pattern: /æ‹‰æ ¼æœ—æ—¥/g,
      replacement: " Lagrange ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆåˆ†æå­¦ï¼šLagrange ä¸­å€¼å®šç†ï¼‰"
    },

    // ã€æ³›å‡½åˆ†æã€‘
    {
      pattern: /å·´æ‹¿èµ«/g,
      replacement: " Banach ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ³›å‡½åˆ†æï¼šBanach ç©ºé—´ï¼‰"
    },
    {
      pattern: /ç´¢ä¼¯åˆ—å¤«/g,
      replacement: " Sobolev ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ³›å‡½åˆ†æï¼šSobolev ç©ºé—´ï¼‰"
    },
    {
      pattern: /èµ«å°”å¾·/g,
      replacement: " HÃ¶lder ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ³›å‡½åˆ†æï¼šHÃ¶lder ä¸ç­‰å¼ï¼‰"
    },
    {
      pattern: /æ–½ç“¦èŒ¨/g,
      replacement: " Schwartz ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ³›å‡½åˆ†æï¼šå¹¿ä¹‰å‡½æ•°ç†è®ºï¼‰"
    },
    {
      pattern: /é‡Œæ–¯/g,
      replacement: " Riesz ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ³›å‡½åˆ†æï¼šRiesz è¡¨ç¤ºå®šç†ï¼‰"
    },
    {
      pattern: /å“ˆæ©/g,
      replacement: " Hahn ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ³›å‡½åˆ†æï¼šHahn-Banach å®šç†ï¼‰"
    },
    {
      pattern: /é—µå¯å¤«æ–¯åŸº/g,
      replacement: " Minkowski ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ³›å‡½åˆ†æï¼šMinkowski ä¸ç­‰å¼ï¼‰"
    },

    // ã€æµ‹åº¦è®ºã€‘
    {
      pattern: /åšé›·å°”/g,
      replacement: " Borel ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæµ‹åº¦è®ºï¼šBorel é›†ã€Borel æµ‹åº¦ï¼‰"
    },
    {
      pattern: /è‹¥å°”å½“/g,
      replacement: " Jordan ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæµ‹åº¦è®ºï¼šJordan æµ‹åº¦ï¼‰"
    },
    {
      pattern: /å¡æ‹‰æ³°å¥¥å¤šé‡Œ/g,
      replacement: " CarathÃ©odory ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæµ‹åº¦è®ºï¼šCarathÃ©odory æ‰©å¼ å®šç†ï¼‰"
    },
    {
      pattern: /æ‹‰ä¸œ/g,
      replacement: " Radon ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæµ‹åº¦è®ºï¼šRadon æµ‹åº¦ï¼‰"
    },

    // ã€æ‹“æ‰‘å­¦ã€‘
    {
      pattern: /è±ªæ–¯å¤šå¤«/g,
      replacement: " Hausdorff ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ‹“æ‰‘å­¦ï¼šHausdorff ç©ºé—´ï¼‰"
    },
    {
      pattern: /å‰æ´ªè¯ºå¤«/g,
      replacement: " Tychonoff ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ‹“æ‰‘å­¦ï¼šTychonoff å®šç†ï¼‰"
    },
    {
      pattern: /ä¹Œé‡Œæ¾/g,
      replacement: " Urysohn ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ‹“æ‰‘å­¦ï¼šUrysohn å¼•ç†ï¼‰"
    },
    {
      pattern: /è´å°”/g,
      replacement: " Baire ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ‹“æ‰‘å­¦ï¼šBaire çº²å®šç†ï¼‰"
    },

    // ã€æ¦‚ç‡è®ºã€‘
    {
      pattern: /æŸ¯å°”è«å“¥æ´›å¤«/g,
      replacement: " Kolmogorov ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ¦‚ç‡è®ºï¼šæ¦‚ç‡è®ºå…¬ç†åŒ–ï¼‰"
    },
    {
      pattern: /åˆ‡æ¯”é›ªå¤«/g,
      replacement: " Chebyshev ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ¦‚ç‡è®ºï¼šChebyshev ä¸ç­‰å¼ï¼‰"
    },
    {
      pattern: /é©¬å°”å¯å¤«/g,
      replacement: " Markov ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ¦‚ç‡è®ºï¼šMarkov é“¾ï¼‰"
    },
    {
      pattern: /æ³Šæ¾/g,
      replacement: " Poisson ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ¦‚ç‡è®ºï¼šPoisson åˆ†å¸ƒï¼‰"
    },
    {
      pattern: /é«˜æ–¯/g,
      replacement: " Gauss ",
      description: "ä¸­æ–‡äººåè½¬è‹±æ–‡ï¼ˆæ¦‚ç‡è®ºï¼šGauss åˆ†å¸ƒï¼‰"
    },

    {
      pattern: /å†¯Â·è¯ºä¾æ›¼/g,
      replacement: " von Neumann ",
    },

    {
      pattern: /\^\*/g,
      replacement: "*",
      description: "ç§»é™¤ä¸Šæ ‡ç¬¦å·å‰çš„è„±å­—ç¬¦"
    },
    {
      pattern: /_Ï•\s*/g,
      replacement: "áµ© ",
      description: "ä¸‹æ ‡ phi ç¬¦å·è½¬æ¢"
    }
  ]
};

// ============================================
// ğŸ“¦ ç±»å®šä¹‰åŒºï¼ˆä½¿ç”¨ä¸Šé¢çš„é…ç½®ï¼‰
// ============================================

class KnowledgeBaseTemplate {
  /**
   * å•æ¡ HtmlComment çš„æ¨¡æ¿å¡ç‰‡ id
   */
  static singleHtmlCommentTemplateNoteIds = kbTemplateConfig.singleHtmlCommentTemplateNoteIds;

  /**
   * å¡ç‰‡ç±»å‹
   */
  static types = kbTemplateConfig.types;

  /**
   * å…³é”®è¯åˆ°å¡ç‰‡ç±»å‹çš„æ˜ å°„è¡¨
   */
  static keywordTypeMapping = kbTemplateConfig.keywordTypeMapping;

  /**
   * é“¾æ¥è¯å¿«æ·çŸ­è¯­åˆ—è¡¨
   */
  static inlineLinkPhrases = kbTemplateConfig.inlineLinkPhrases;

  /**
   * å¡ç‰‡ç±»å‹ç¼“å­˜ - ç”¨äºä¼˜åŒ– getNoteType æ€§èƒ½
   * ä½¿ç”¨ WeakMap é¿å…å†…å­˜æ³„æ¼
   */
  static noteTypeCache = new WeakMap();

  /**
   * å½’ç±»çˆ¶å¡ç‰‡ç¼“å­˜ - ç”¨äºä¼˜åŒ– getFirstClassificationParentNote æ€§èƒ½
   * ä½¿ç”¨ WeakMap é¿å…å†…å­˜æ³„æ¼
   */
  static classificationParentCache = new WeakMap();

  /**
   * æ ¹æ®ç”¨æˆ·è¾“å…¥æ–‡æœ¬æ™ºèƒ½è¯†åˆ«å¡ç‰‡ç±»å‹
   * @param {string} userInputText - ç”¨æˆ·è¾“å…¥çš„æ–‡æœ¬
   * @returns {string|null} - è¯†åˆ«å‡ºçš„ç±»å‹ï¼ŒæœªåŒ¹é…æ—¶è¿”å›null
   */
  static getTypeFromInputText(userInputText) {
    for (const [keyword, type] of Object.entries(this.keywordTypeMapping)) {
      if (userInputText.includes(keyword)) {
        return type;
      }
    }
    return null;
  }

  /**
   * çŸ¥è¯†ç‚¹å¡ç‰‡ç±»å‹
   */
  static knowledgeNoteTypes = kbTemplateConfig.knowledgeNoteTypes;

  /**
   * å¡ç‰‡ç±»å‹ä¸é»˜è®¤ç§»åŠ¨å­—æ®µçš„æ˜ å°„å…³ç³»
   */
  static typeDefaultFieldMap = kbTemplateConfig.typeDefaultFieldMap;

  /**
   * è·å–å¡ç‰‡ç±»å‹å¯¹åº”çš„é»˜è®¤å­—æ®µ
   *
   * @param {string} noteType - å¡ç‰‡ç±»å‹
   * @returns {string} é»˜è®¤å­—æ®µåï¼Œå¦‚æœç±»å‹æœªå®šä¹‰åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²
   */
  static getDefaultFieldForType(noteType) {
    return this.typeDefaultFieldMap[noteType] || "";
  }

  /**
   * å­—æ®µåˆ«åæ˜ å°„è¡¨
   */
  static fieldAliasMapping = kbTemplateConfig.fieldAliasMapping;

  /**
   * æ ¹æ®å¡ç‰‡ç±»å‹è§£æå®é™…å­—æ®µå
   *
   * ä½¿ç”¨å­—æ®µåˆ«åæ˜ å°„è¡¨å°†é€»è¾‘å­—æ®µåè½¬æ¢ä¸ºè¯¥å¡ç‰‡ç±»å‹å¯¹åº”çš„å®é™…å­—æ®µå
   * å¦‚æœæ²¡æœ‰æ˜ å°„å…³ç³»ï¼Œè¿”å›åŸå­—æ®µå
   *
   * @param {string} logicalFieldName - é€»è¾‘å­—æ®µåï¼ˆå¦‚"è¯æ˜"ï¼‰
   * @param {string} noteType - å¡ç‰‡ç±»å‹ï¼ˆå¦‚"å‘½é¢˜"ã€"åä¾‹"ç­‰ï¼‰
   * @returns {string} å®é™…å­—æ®µå
   *
   * @example
   * resolveFieldName("è¯æ˜", "åä¾‹")  // è¿”å› "åä¾‹"
   * resolveFieldName("è¯æ˜", "å‘½é¢˜")  // è¿”å› "è¯æ˜"
   * resolveFieldName("ç›¸å…³æ€è€ƒ", "å‘½é¢˜")  // è¿”å› "ç›¸å…³æ€è€ƒ"ï¼ˆæ— æ˜ å°„ï¼Œè¿”å›åŸå€¼ï¼‰
   */
  static resolveFieldName(logicalFieldName, noteType) {
    // æ£€æŸ¥æ˜¯å¦æœ‰åˆ«åæ˜ å°„
    const aliasMap = this.fieldAliasMapping[logicalFieldName];
    if (aliasMap && aliasMap[noteType]) {
      return aliasMap[noteType];
    }
    // æ²¡æœ‰æ˜ å°„ï¼Œè¿”å›åŸå­—æ®µå
    return logicalFieldName;
  }

  /**
   * æ€è·¯é“¾æ¥å­—æ®µæ˜ å°„
   */
  static ideaLinkFieldMap = kbTemplateConfig.ideaLinkFieldMap;

  /**
   * æ ¹æ®é¢œè‰²ç´¢å¼•è·å–å¡ç‰‡ç±»å‹ï¼ˆç²—è¯»æ¨¡å¼ä½¿ç”¨ï¼‰
   * @param {number} colorIndex - é¢œè‰²ç´¢å¼•
   * @returns {string|null} å¡ç‰‡ç±»å‹ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› null
   */
  static getNoteTypeByColor(colorIndex) {
    // å»ºç«‹é¢œè‰²åˆ°ç±»å‹çš„æ˜ å°„
    const colorTypeMap = {
      0: "å½’ç±»",       // æ·¡é»„è‰²
      1: "é—®é¢˜",       // æ·¡ç»¿è‰²
      2: "å®šä¹‰",       // æ·¡è“è‰²ï¼ˆä½œè€…ä¹Ÿæ˜¯æ·¡è“è‰²ï¼Œä½†ç²—è¯»æ¨¡å¼ä¼˜å…ˆå®šä¹‰ï¼‰
      3: "åä¾‹",       // ç²‰è‰²
      6: "ç ”ç©¶è¿›å±•",   // è“è‰²ï¼ˆæ€»ç»“ä¹Ÿæ˜¯è“è‰²ï¼Œä½†ç²—è¯»æ¨¡å¼ä¼˜å…ˆç ”ç©¶è¿›å±•ï¼‰
      9: "æ€æƒ³æ–¹æ³•",   // æ·±ç»¿è‰²
      10: "å‘½é¢˜",      // æ·±è“è‰²
      13: "æ€è·¯",      // æ·¡ç°è‰²
      15: "ä¾‹å­"       // ç´«è‰²ï¼ˆç²—è¯»æ¨¡å¼ä¸‹ç»Ÿä¸€ä¸ºä¾‹å­ï¼Œä¸è€ƒè™‘æ–‡çŒ®/è®ºæ–‡/ä¹¦ä½œï¼‰
    }
    return colorTypeMap[colorIndex] || null
  }

  /**
   * åˆ¶å¡ï¼ˆåªæ”¯æŒéæ‘˜å½•ç‰ˆæœ¬ï¼‰
   */
  static makeCard(note, addToReview = true, reviewEverytime = true) {
    try {
      // KnowledgeBaseUtils.log("å¼€å§‹æ‰§è¡Œ makeCard", "makeCard", {
      //   noteId: note.noteId,
      //   noteTitle: note.noteTitle
      // })

      this.renewNote(note) // å¤„ç†æ—§å¡ç‰‡
      // KnowledgeBaseUtils.log("å®Œæˆ renewNote", "makeCard", {
      //   step: "renewNote",
      //   noteId: note.noteId
      // })

      this.mergeTemplateAndAutoMoveNoteContent(note) // åˆå¹¶æ¨¡æ¿å¡ç‰‡å¹¶è‡ªåŠ¨ç§»åŠ¨å†…å®¹
      // KnowledgeBaseUtils.log("å®Œæˆ mergeTemplateAndAutoMoveNoteContent", "makeCard", {
      //   step: "mergeTemplateAndAutoMoveNoteContent",
      //   noteId: note.noteId
      // })

      this.templateMergedCardMake(note)
      // KnowledgeBaseUtils.log("å®Œæˆ templateMergedCardMake", "makeCard", {
      //   step: "templateMergedCardMake",
      //   noteId: note.noteId
      // })

      if (addToReview) {
        this.addToReview(note, reviewEverytime) // åŠ å…¥å¤ä¹ 
        // KnowledgeBaseUtils.log("å®Œæˆ addToReview", "makeCard", {
        //   step: "addToReview",
        //   noteId: note.noteId,
        //   reviewEverytime: reviewEverytime
        // })
      }

      // KnowledgeBaseUtils.log("makeCard æ‰§è¡Œå®Œæˆ", "makeCard", {
      //   noteId: note.noteId
      // })
    } catch (error) {
      KnowledgeBaseUtils.addErrorLog(error, "makeCard")
    }
  }

  /**
   * å·²åˆå¹¶æ¨¡æ¿çš„å¡ç‰‡åˆ¶å¡
   *
   * æš‚ä¸åœ¨è¿™å¤„ç†å¤ä¹ 
   * @param note
   */
  static templateMergedCardMake(note) {
    // KnowledgeBaseUtils.log("å¼€å§‹æ‰§è¡Œ templateMergedCardMake", "templateMergedCardMake", {
    //   noteId: note.noteId,
    //   noteTitle: note.noteTitle
    // })

    this.changeTitle(note) // ä¿®æ”¹å¡ç‰‡æ ‡é¢˜
    // KnowledgeBaseUtils.log("å®Œæˆ changeTitle", "templateMergedCardMake", {
    //   step: "changeTitle",
    //   noteId: note.noteId
    // })

    this.changeNoteColor(note) // ä¿®æ”¹å¡ç‰‡é¢œè‰²
    // KnowledgeBaseUtils.log("å®Œæˆ changeNoteColor", "templateMergedCardMake", {
    //   step: "changeNoteColor",
    //   noteId: note.noteId
    // })

    this.linkParentNote(note) // é“¾æ¥å¹¿ä¹‰çš„çˆ¶å¡ç‰‡ï¼ˆå¯èƒ½æ˜¯é“¾æ¥å½’ç±»å¡ç‰‡ï¼‰
    // KnowledgeBaseUtils.log("å®Œæˆ linkParentNote", "templateMergedCardMake", {
    //   step: "linkParentNote",
    //   noteId: note.noteId
    // })

    this.autoMoveNewContent(note) // è‡ªåŠ¨ç§»åŠ¨æ–°å†…å®¹åˆ°å¯¹åº”å­—æ®µ
    // KnowledgeBaseUtils.log("å®Œæˆ autoMoveNewContent", "templateMergedCardMake", {
    //   step: "autoMoveNewContent",
    //   noteId: note.noteId
    // })

    this.moveTaskCardLinksToRelatedField(note) // ç§»åŠ¨ä»»åŠ¡å¡ç‰‡é“¾æ¥åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ
    // KnowledgeBaseUtils.log("å®Œæˆ moveTaskCardLinksToRelatedField", "templateMergedCardMake", {
    //   step: "moveTaskCardLinksToRelatedField",
    //   noteId: note.noteId
    // })

    this.moveSummaryLinksToTop(note) // ç§»åŠ¨æ€»ç»“é“¾æ¥åˆ°å¡ç‰‡æœ€ä¸Šæ–¹
    // KnowledgeBaseUtils.log("å®Œæˆ moveSummaryLinksToTop", "templateMergedCardMake", {
    //   step: "moveSummaryLinksToTop",
    //   noteId: note.noteId
    // })

    this.handleDefinitionPropositionLinks(note) // å¤„ç†å®šä¹‰-å‘½é¢˜/ä¾‹å­ä¹‹é—´çš„é“¾æ¥
    // KnowledgeBaseUtils.log("å®Œæˆ handleDefinitionPropositionLinks", "templateMergedCardMake", {
    //   step: "handleDefinitionPropositionLinks",
    //   noteId: note.noteId
    // })

    this.refreshNotes(note) // åˆ·æ–°å¡ç‰‡
    // KnowledgeBaseUtils.log("å®Œæˆ refreshNotes", "templateMergedCardMake", {
    //   step: "refreshNotes",
    //   noteId: note.noteId
    // })

    // KnowledgeBaseUtils.log("templateMergedCardMake æ‰§è¡Œå®Œæˆ", "templateMergedCardMake", {
    //   noteId: note.noteId
    // })
  }

  /**
   * å¤„ç†å®šä¹‰å¡ç‰‡ä¸å‘½é¢˜/ä¾‹å­å¡ç‰‡ä¹‹é—´çš„é“¾æ¥
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   */
  static handleDefinitionPropositionLinks(note) {
    const noteType = this.getNoteType(note);
    const parentNote = note.parentNote;
    
    if (!parentNote) return;
    
    const parentType = this.getNoteType(parentNote);
    const supportedCombinations = [
      { child: "å®šä¹‰", parents: ["å‘½é¢˜", "ä¾‹å­"] },
      { child: "å‘½é¢˜", parents: ["å®šä¹‰"] },
      { child: "ä¾‹å­", parents: ["å®šä¹‰"] }
    ];
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯éœ€è¦å¤„ç†çš„ç»„åˆ
    let shouldProcess = false;
    let isDefinitionChild = false;
    
    for (let combo of supportedCombinations) {
      if (noteType === combo.child && combo.parents.includes(parentType)) {
        shouldProcess = true;
        isDefinitionChild = (combo.child === "å®šä¹‰");
        break;
      }
    }
    
    if (!shouldProcess) return;
    
    // è·å–åŒæ–¹çš„é“¾æ¥ç´¢å¼•
    let parentInChildIndex = this.getNoteIndexInAnotherNote(parentNote, note);
    let childInParentIndex = this.getNoteIndexInAnotherNote(note, parentNote);
    
    // ç¡®ä¿åŒå‘é“¾æ¥
    if (parentInChildIndex === -1) {
      note.appendNoteLink(parentNote, "To");
      parentInChildIndex = this.getNoteIndexInAnotherNote(parentNote, note);
    }
    
    if (childInParentIndex === -1) {
      parentNote.appendNoteLink(note, "To");
      childInParentIndex = this.getNoteIndexInAnotherNote(note, parentNote);
    }
    
    // æ ¹æ®ç±»å‹ç§»åŠ¨é“¾æ¥åˆ°ç›¸åº”å­—æ®µ
    if (isDefinitionChild) {
      // å®šä¹‰æ˜¯å­å¡ç‰‡ï¼šåœ¨çˆ¶å¡ç‰‡ï¼ˆå‘½é¢˜/ä¾‹å­ï¼‰ä¸­ç§»åŠ¨å®šä¹‰é“¾æ¥åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ
      if (childInParentIndex !== -1) {
        this.moveCommentsArrToField(parentNote, [childInParentIndex], "ç›¸å…³é“¾æ¥", true);
      }
      // å®šä¹‰å¡ç‰‡ä¸­çš„çˆ¶é“¾æ¥ä¿æŒåœ¨æœ«å°¾ï¼ˆç›¸å…³é“¾æ¥å­—æ®µæœ¬èº«å°±æ˜¯æœ€åï¼‰
    } else {
      // å‘½é¢˜/ä¾‹å­æ˜¯å­å¡ç‰‡ï¼šåœ¨å®šä¹‰å¡ç‰‡ï¼ˆçˆ¶ï¼‰ä¸­ç§»åŠ¨å‘½é¢˜/ä¾‹å­é“¾æ¥åˆ°æœ«å°¾
      // åœ¨å‘½é¢˜/ä¾‹å­å¡ç‰‡ä¸­ç§»åŠ¨å®šä¹‰é“¾æ¥åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ
      if (parentInChildIndex !== -1) {
        this.moveCommentsArrToField(note, [parentInChildIndex], "ç›¸å…³é“¾æ¥", true);
      }
    }
  }


  /**
   * æ˜¯å¦å·²ç»é“¾æ¥å¹¿ä¹‰çˆ¶å¡ç‰‡äº†
   */
  static ifLinkParentNote(note) {
    let linkHtmlCommentObj = this.parseNoteComments(note).htmlCommentsObjArr.find(htmlObj => ["ç›¸å…³é“¾æ¥", "ç›¸å…³é“¾æ¥ï¼š","æ‰€å±", "æ‰€å±ï¼š"].includes(htmlObj.text))
    return linkHtmlCommentObj.excludingFieldBlockIndexArr??linkHtmlCommentObj.excludingFieldBlockIndexArr.length > 0
  } 

  /**
   * ä¸€é”®åˆ¶å¡ï¼ˆæ”¯æŒæ‘˜å½•ç‰ˆæœ¬ï¼‰
   */
  static makeNote(note, addToReview = true, reviewEverytime = true, focus = true) {
    try {
      // const startTime = Date.now();
      // KnowledgeBaseUtils.log("å¼€å§‹æ‰§è¡Œ makeNote", "makeNote", {
      //   noteId: note.noteId,
      //   noteTitle: note.noteTitle,
      //   classificationMode: KnowledgeBaseConfig.config.classificationMode,
      //   preProcessMode: KnowledgeBaseConfig.config.preProcessMode,
      //   timestamp: startTime
      // })

      if (KnowledgeBaseConfig.config.classificationMode) {
        // å½’ç±»æ¨¡å¼ï¼šå¿«é€Ÿåˆ›å»ºå½’ç±»å¡ç‰‡
        // const classificationStartTime = Date.now();
        // KnowledgeBaseUtils.log("è¿›å…¥å½’ç±»æ¨¡å¼", "makeNote", {
        //   noteId: note.noteId,
        //   elapsedMs: Date.now() - startTime
        // })

        // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šæå‰è·å–ç±»å‹ï¼Œåç»­æ–¹æ³•ä¼šä»ç¼“å­˜è·å–ï¼Œé¿å…é‡å¤æŸ¥æ‰¾
        const noteType = this.getNoteType(note);
        // KnowledgeBaseUtils.log("å½’ç±»æ¨¡å¼ï¼šè·å–å¡ç‰‡ç±»å‹", "makeNote", {
        //   noteId: note.noteId,
        //   noteType: noteType
        // })

        this.changeTitle(note, true, noteType)  // ä¼ é€’ç±»å‹ï¼Œé¿å…å†…éƒ¨é‡æ–°æŸ¥æ‰¾
        // KnowledgeBaseUtils.log("å½’ç±»æ¨¡å¼ï¼šå®Œæˆ changeTitle", "makeNote", {
        //   noteId: note.noteId,
        //   stepDurationMs: Date.now() - classificationStartTime
        // })

        // const colorStartTime = Date.now();
        this.changeNoteColor(note, true)
        // KnowledgeBaseUtils.log("å½’ç±»æ¨¡å¼ï¼šå®Œæˆ changeNoteColor", "makeNote", {
        //   noteId: note.noteId,
        //   stepDurationMs: Date.now() - colorStartTime
        // })

        // const mergeStartTime = Date.now();
        this.mergeTemplateAndAutoMoveNoteContent(note)
        // KnowledgeBaseUtils.log("å½’ç±»æ¨¡å¼ï¼šå®Œæˆ mergeTemplateAndAutoMoveNoteContent", "makeNote", {
        //   noteId: note.noteId,
        //   stepDurationMs: Date.now() - mergeStartTime
        // })

        if (this.ifLinkParentNote(note)) {
          // const linkStartTime = Date.now();
          this.linkParentNote(note, false) // é“¾æ¥å¹¿ä¹‰çš„çˆ¶å¡ç‰‡ï¼ˆå¯èƒ½æ˜¯é“¾æ¥å½’ç±»å¡ç‰‡ï¼‰æ­¤æ—¶ä¸»è¦è€ƒè™‘åŒæ—¶å±äºå¤šå¼ çˆ¶å¡ç‰‡çš„æƒ…å½¢
          // KnowledgeBaseUtils.log("å½’ç±»æ¨¡å¼ï¼šå®Œæˆ linkParentNote", "makeNote", {
          //   noteId: note.noteId,
          //   stepDurationMs: Date.now() - linkStartTime
          // })
        }

        // KnowledgeBaseUtils.log("å½’ç±»æ¨¡å¼æ‰§è¡Œå®Œæˆ", "makeNote", {
        //   noteId: note.noteId,
        //   totalDurationMs: Date.now() - startTime
        // })
        return
      }

      // æ£€æŸ¥æ˜¯å¦å¯ç”¨é¢„å¤„ç†æ¨¡å¼
      if (KnowledgeBaseConfig.config.preProcessMode) {
        // é¢„å¤„ç†æ¨¡å¼ï¼šç®€åŒ–çš„åˆ¶å¡æµç¨‹
        // const preProcessStartTime = Date.now();
        // KnowledgeBaseUtils.log("è¿›å…¥é¢„å¤„ç†æ¨¡å¼", "makeNote", {
        //   noteId: note.noteId,
        //   elapsedMs: Date.now() - startTime
        // })

        MNUtil.undoGrouping(() => {
          // const processStartTime = Date.now();
          let processedNote = this.processNote(note)
          // KnowledgeBaseUtils.log("é¢„å¤„ç†æ¨¡å¼ï¼šå®Œæˆ processNote", "makeNote", {
          //   noteId: note.noteId,
          //   processedNoteId: processedNote.noteId,
          //   noteType: this.getNoteType(processedNote),
          //   stepDurationMs: Date.now() - processStartTime
          // })

          switch (this.getNoteType(processedNote, true)) {
            case "å®šä¹‰":
              // const makeCardStartTime = Date.now();
              this.makeCard(processedNote, true, true)
              // KnowledgeBaseUtils.log("é¢„å¤„ç†æ¨¡å¼ï¼šå®Œæˆ makeCardï¼ˆå®šä¹‰ï¼‰", "makeNote", {
              //   noteId: processedNote.noteId,
              //   stepDurationMs: Date.now() - makeCardStartTime
              // })
              break;
            default:
              this.changeTitle(processedNote, true)
              this.mergeTemplateAndAutoMoveNoteContent(processedNote)
              break;
          }

          if (KnowledgeBaseConfig.config.classAutoPinMode) {
            pinnerUtils.pinCard(processedNote.noteId, { section: "class"})
          }
          if (focus) { processedNote.focusInMindMap(0.3) }
          // KnowledgeBaseUtils.log("é¢„å¤„ç†æ¨¡å¼ï¼šå®Œæˆ focusInMindMap", "makeNote", {
          //   noteId: processedNote.noteId
          // })
        })

        // KnowledgeBaseUtils.log("é¢„å¤„ç†æ¨¡å¼æ‰§è¡Œå®Œæˆ", "makeNote", {
        //   noteId: note.noteId,
        //   totalDurationMs: Date.now() - startTime
        // })
        return
      }


      // æ­£å¸¸æ¨¡å¼ï¼šå®Œæ•´åˆ¶å¡æµç¨‹
      // const normalModeStartTime = Date.now();
      // KnowledgeBaseUtils.log("è¿›å…¥æ­£å¸¸æ¨¡å¼", "makeNote", {
      //   noteId: note.noteId,
      //   elapsedMs: Date.now() - startTime
      // })

      MNUtil.undoGrouping(() => {
        // const processStartTime = Date.now();
        let processedNote = this.processNote(note)
        // KnowledgeBaseUtils.log("æ­£å¸¸æ¨¡å¼ï¼šå®Œæˆ processNote", "makeNote", {
        //   noteId: note.noteId,
        //   processedNoteId: processedNote.noteId,
        //   stepDurationMs: Date.now() - processStartTime
        // })

        // const makeCardStartTime = Date.now();
        this.makeCard(processedNote, addToReview, reviewEverytime)
        // KnowledgeBaseUtils.log("æ­£å¸¸æ¨¡å¼ï¼šå®Œæˆ makeCard", "makeNote", {
        //   noteId: processedNote.noteId,
        //   addToReview: addToReview,
        //   reviewEverytime: reviewEverytime,
        //   stepDurationMs: Date.now() - makeCardStartTime
        // })
        if (KnowledgeBaseConfig.config.classAutoPinMode) {
          pinnerUtils.pinCard(processedNote.noteId, { section: "class"})
        }
        if (focus) { processedNote.focusInMindMap(0.4) }
        // KnowledgeBaseUtils.log("æ­£å¸¸æ¨¡å¼ï¼šå®Œæˆ focusInMindMap", "makeNote", {
        //   noteId: processedNote.noteId
        // })
      })

      // KnowledgeBaseUtils.log("æ­£å¸¸æ¨¡å¼æ‰§è¡Œå®Œæˆ", "makeNote", {
      //   noteId: note.noteId,
      //   totalDurationMs: Date.now() - startTime
      // })
    } catch (error) {
      MNUtil.showHUD(`âŒ åˆ¶å¡å¤±è´¥: ${error.message}`);
      KnowledgeBaseUtils.addErrorLog(error, "makeNote")
    }
  }

  /**
   * åªä¿ç•™å¡ç‰‡çš„æ‘˜å½•ï¼Œåˆ é™¤æ‰€æœ‰æ–‡æœ¬å’Œæ‰‹å†™è¯„è®º
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   * @returns {number} è¿”å›åˆ é™¤çš„è¯„è®ºæ•°é‡
   */
  static keepOnlyExcerpt(note) {
    if (note) {
      this.keepOnlyExcerptAndTitle(note); // å…ˆä¿ç•™æ ‡é¢˜
      note.noteTitle = "";
    }
  }

  static keepOnlyExcerptAndTitle(note) {
    if (note) {
      // è·å–æ‰€æœ‰è¯„è®ºçš„è¯¦ç»†ç±»å‹
      const comments = note.MNComments;
      const indicesToRemove = [];
      
      // è¯†åˆ«éœ€è¦åˆ é™¤çš„è¯„è®ºï¼ˆæ‰‹å†™å’Œæ–‡æœ¬ç±»å‹ï¼‰
      for (let i = 0; i < comments.length; i++) {
        const commentType = comments[i].type;
        // æ‰‹å†™ç›¸å…³ç±»å‹
        if (commentType === "drawingComment" || 
            commentType === "imageCommentWithDrawing" || 
            commentType === "mergedImageCommentWithDrawing") {
          indicesToRemove.push(i);
          continue;
        }
        
        // æ–‡æœ¬ç›¸å…³ç±»å‹ï¼ˆåŒ…æ‹¬ HTMLã€é“¾æ¥ç­‰ï¼‰
        if (commentType === "textComment" || 
            commentType === "markdownComment" || 
            commentType === "tagComment" ||
            commentType === "HtmlComment" ||
            commentType === "linkComment" ||
            commentType === "summaryComment" ||
            commentType === "mergedTextComment" ||
            commentType === "blankTextComment") {
          indicesToRemove.push(i);
        }
      }
      
      // ä»åå¾€å‰åˆ é™¤è¯„è®ºï¼ˆé¿å…ç´¢å¼•å˜åŒ–é—®é¢˜ï¼‰
      indicesToRemove.sort((a, b) => b - a);
      for (const index of indicesToRemove) {
        note.removeCommentByIndex(index);
      }

      // åˆ·æ–°å¡ç‰‡æ˜¾ç¤º
      note.refresh();

      this.removeTitlePrefix(note)
    }
  }

  // å»æ‰å¡ç‰‡çš„ ã€ã€‘ å‰ç¼€
  static removeTitlePrefix(note) {
    if (typeof note === "string") {
      return note.replace(/^ã€.*?ã€‘/, "");
    } else {
      if (note && note.noteTitle && note.noteTitle.trim()) {
        note.noteTitle = note.noteTitle.replace(/^ã€.*?ã€‘/, "");
        return note.noteTitle;
      }
    }
    return "";
  }

  static removePrefix(note){
    this.removeTitlePrefix(note)
  }

  /**
   * å¼ºåˆ¶é‡æ–°å¼„æ ‡é¢˜å‰ç¼€
   */

  /**
   * ç”¨é€‰ä¸­å¡ç‰‡çš„æ‘˜å½•æ›´æ–°çˆ¶å¡ç‰‡çš„æ‘˜å½•
   * 
   * åŠŸèƒ½è¯´æ˜ï¼š
   * 1. é€‰ä¸­å¡ç‰‡ï¼ˆBï¼‰åªä¿ç•™æ‘˜å½•éƒ¨åˆ†ï¼Œåˆ é™¤æ‰€æœ‰æ–‡æœ¬å’Œæ‰‹å†™è¯„è®º
   * 2. çˆ¶å¡ç‰‡ï¼ˆAï¼‰åˆ é™¤æ‘˜å½•åŒºçš„æ‰€æœ‰è¯„è®º
   * 3. å°† B åˆå¹¶åˆ° A ä¸­
   * 4. å°†åˆå¹¶åçš„è¯„è®ºç§»åŠ¨åˆ°æ‘˜å½•åŒº
   * 
   * @param {MNNote} focusNote - é€‰ä¸­çš„å¡ç‰‡ï¼ˆå°†è¢«å¤„ç†å¹¶åˆå¹¶åˆ°çˆ¶å¡ç‰‡ï¼‰
   */
  static renewExcerptInParentNoteByFocusNote(focusNote) {
    try {
      // 1. å‚æ•°æ£€æŸ¥
      if (!focusNote) {
        MNUtil.showHUD("âŒ æœªé€‰æ‹©å¡ç‰‡");
        return;
      }

      // 2. æ£€æŸ¥æ˜¯å¦æœ‰çˆ¶å¡ç‰‡
      if (!focusNote.parentNote) {
        MNUtil.showHUD("âŒ å½“å‰å¡ç‰‡æ²¡æœ‰çˆ¶å¡ç‰‡");
        return;
      }

      const parentNote = focusNote.parentNote;

      MNUtil.undoGrouping(() => {
        let newNote = focusNote.clone();

        parentNote.addChild(newNote)

        // 4. åˆ é™¤çˆ¶å¡ç‰‡Açš„æ‘˜å½•åŒºè¯„è®º
        const excerptBlockIndexArr = this.getExcerptBlockIndexArr(parentNote);
        if (excerptBlockIndexArr.length > 0) {
          parentNote.removeCommentsByIndexArr(excerptBlockIndexArr);
        }

        this.keepOnlyExcerpt(newNote)

        // 5. åˆå¹¶å­å¡ç‰‡Båˆ°çˆ¶å¡ç‰‡A
        newNote.mergeInto(parentNote);

        // 6. å»¶è¿Ÿå¤„ç†ï¼Œç¡®ä¿åˆå¹¶å®Œæˆ
        MNUtil.delay(0.1).then(() => {
          // å°†çˆ¶å¡ç‰‡çš„æ–°å†…å®¹ç§»åŠ¨åˆ°æ‘˜å½•åŒº
          this.autoMoveNewContentToField(parentNote, "æ‘˜å½•åŒº", true, false);
          
          // åˆ·æ–°çˆ¶å¡ç‰‡æ˜¾ç¤º
          this.refreshNotes(parentNote);

          focusNote.delete()
          
          MNUtil.showHUD(`âœ… å·²ç”¨é€‰ä¸­å¡ç‰‡çš„æ‘˜å½•æ›´æ–°çˆ¶å¡ç‰‡çš„æ‘˜å½•ï¼ˆæ¸…é™¤äº† ${removedCount} æ¡è¯„è®ºï¼‰`);
        });
      });
      
    } catch (error) {
      MNUtil.showHUD(`âŒ æ›´æ–°æ‘˜å½•å¤±è´¥: ${error.message}`);
      MNUtil.addErrorLog(error, "renewExcerptInParentNoteByFocusNote", {
        focusNoteId: focusNote?.noteId,
        parentNoteId: focusNote?.parentNote?.noteId
      });
    }
  }

  /**
   * å°†é€‰ä¸­çš„å¡ç‰‡ä½œä¸ºæ€è€ƒå†…å®¹åˆå¹¶åˆ°çˆ¶å¡ç‰‡çš„æ€è€ƒå­—æ®µ
   * 
   * åŠŸèƒ½è¯´æ˜ï¼š
   * 1. å¦‚æœå¡ç‰‡æœ‰æ ‡é¢˜ï¼Œæå–æ ‡é¢˜ä½œä¸ºæ€è€ƒå†…å®¹
   * 2. å¦‚æœæ²¡æœ‰æ ‡é¢˜ï¼Œå¼¹çª—è®©ç”¨æˆ·è¾“å…¥ï¼ˆé€šè¿‡å›è°ƒå‡½æ•°ï¼‰
   * 3. åœ¨çˆ¶å¡ç‰‡æ·»åŠ  "- " + å†…å®¹ çš„ Markdown æ–‡æœ¬
   * 4. æ¸…é™¤å­å¡ç‰‡æ ‡é¢˜
   * 5. å°†å­å¡ç‰‡åˆå¹¶åˆ°çˆ¶å¡ç‰‡
   * 6. ç§»åŠ¨çˆ¶å¡ç‰‡çš„æ–°å†…å®¹åˆ°"ç›¸å…³æ€è€ƒ"å­—æ®µ
   * 
   * @param {MNNote} focusNote - é€‰ä¸­çš„å¡ç‰‡
   * @param {Function} inputCallback - ç”¨äºè·å–ç”¨æˆ·è¾“å…¥çš„å›è°ƒå‡½æ•°ï¼ˆå¯é€‰ï¼‰
   * @returns {boolean} æ“ä½œæ˜¯å¦æˆåŠŸ
   */
  static mergeToParentThoughtField(focusNote, inputCallback) {
    try {
      // 1. å‚æ•°æ£€æŸ¥
      if (!focusNote) {
        MNUtil.showHUD("âŒ æœªé€‰æ‹©å¡ç‰‡");
        return false;
      }

      // 2. æ£€æŸ¥æ˜¯å¦æœ‰çˆ¶å¡ç‰‡
      if (!focusNote.parentNote) {
        MNUtil.showHUD("âŒ å½“å‰å¡ç‰‡æ²¡æœ‰çˆ¶å¡ç‰‡");
        return false;
      }

      const parentNote = focusNote.parentNote;

      // 3. è·å–æˆ–è¾“å…¥æ ‡é¢˜å†…å®¹
      let thoughtContent = focusNote.noteTitle ? focusNote.noteTitle.trim() : "";

      // 4. å¦‚æœæ²¡æœ‰æ ‡é¢˜ä¸”æä¾›äº†å›è°ƒå‡½æ•°ï¼Œè°ƒç”¨å›è°ƒè·å–ç”¨æˆ·è¾“å…¥
      if (!thoughtContent && inputCallback) {
        inputCallback((inputText) => {
          if (inputText && inputText.trim()) {
            // ç”¨æˆ·è¾“å…¥äº†å†…å®¹ï¼Œç»§ç»­å¤„ç†
            this.performMergeToParentThought(focusNote, parentNote, inputText.trim());
          } else {
            MNUtil.showHUD("âŒ æœªè¾“å…¥å†…å®¹ï¼Œæ“ä½œå–æ¶ˆ");
          }
        });
        return true; // å¼‚æ­¥æ“ä½œï¼Œè¿”å› true è¡¨ç¤ºå·²å¤„ç†
      }

      // 5. å¦‚æœæ²¡æœ‰æ ‡é¢˜ä¹Ÿæ²¡æœ‰å›è°ƒï¼Œæç¤ºç”¨æˆ·
      if (!thoughtContent) {
        MNUtil.showHUD("âŒ å¡ç‰‡æ²¡æœ‰æ ‡é¢˜ï¼Œè¯·è¾“å…¥æ€è€ƒå†…å®¹");
        return false;
      }

      // 6. æ‰§è¡Œåˆå¹¶æ“ä½œ
      this.performMergeToParentThought(focusNote, parentNote, thoughtContent);
      return true;
      
    } catch (error) {
      MNUtil.showHUD(`âŒ åˆå¹¶å¤±è´¥: ${error.message}`);
      MNUtil.addErrorLog(error, "mergeToParentThoughtField", {
        focusNoteId: focusNote?.noteId,
        parentNoteId: focusNote?.parentNote?.noteId
      });
      return false;
    }
  }

  /**
   * æ‰§è¡Œåˆå¹¶åˆ°çˆ¶å¡ç‰‡æ€è€ƒå­—æ®µçš„å®é™…æ“ä½œ
   * 
   * @private
   * @param {MNNote} focusNote - å­å¡ç‰‡
   * @param {MNNote} parentNote - çˆ¶å¡ç‰‡
   * @param {string} thoughtContent - æ€è€ƒå†…å®¹
   */
  static performMergeToParentThought(focusNote, parentNote, thoughtContent) {
    MNUtil.undoGrouping(() => {
      try {
        // 1. åœ¨çˆ¶å¡ç‰‡æ·»åŠ  "- " + å†…å®¹ çš„ Markdown æ–‡æœ¬
        parentNote.appendMarkdownComment(`- ${thoughtContent}`);
        
        // 2. æ¸…é™¤å­å¡ç‰‡çš„æ ‡é¢˜
        focusNote.noteTitle = "";
        
        // 3. å°†å­å¡ç‰‡åˆå¹¶åˆ°çˆ¶å¡ç‰‡
        focusNote.mergeInto(parentNote);
        
        // 4. å»¶è¿Ÿå¤„ç†ï¼Œç¡®ä¿åˆå¹¶å®Œæˆ
        MNUtil.delay(0.1).then(() => {
          // å°†çˆ¶å¡ç‰‡çš„æ–°å†…å®¹ç§»åŠ¨åˆ°"ç›¸å…³æ€è€ƒ"å­—æ®µ
          this.autoMoveNewContentToField(parentNote, "ç›¸å…³æ€è€ƒ", true, false);
          
          // åˆ·æ–°çˆ¶å¡ç‰‡æ˜¾ç¤º
          this.refreshNotes(parentNote);
          
          // MNUtil.showHUD(`âœ… å·²å°†"${thoughtContent}"åˆå¹¶åˆ°çˆ¶å¡ç‰‡çš„æ€è€ƒå­—æ®µ`);
        });
        
      } catch (error) {
        MNUtil.showHUD(`âŒ æ‰§è¡Œåˆå¹¶æ—¶å‡ºé”™: ${error.message}`);
        MNUtil.addErrorLog(error, "performMergeToParentThought");
      }
    });
  }

  static autoMoveNewContent(note) {
    // è·å–å¡ç‰‡ç±»å‹
    let noteType = this.getNoteType(note);
    // è·å–é»˜è®¤å­—æ®µ
    let defaultField = this.getDefaultFieldForType(noteType);
    
    // å¦‚æœæ²¡æœ‰é»˜è®¤å­—æ®µï¼Œåˆ™ä¸è¿›è¡Œç§»åŠ¨
    if (!defaultField) {
      MNUtil.showHUD(`æœªå®šä¹‰ ${noteType} ç±»å‹çš„é»˜è®¤å­—æ®µï¼Œæ— æ³•è‡ªåŠ¨ç§»åŠ¨æ–°å†…å®¹ï¼`);
      return;
    }

    // è·å–è¦ç§»åŠ¨çš„å†…å®¹ç´¢å¼•
    let moveIndexArr = this.autoGetNewContentToMoveIndexArr(note);

    // å¦‚æœæ²¡æœ‰è¦ç§»åŠ¨çš„å†…å®¹ï¼Œåˆ™ä¸è¿›è¡Œç§»åŠ¨
    if (moveIndexArr.length === 0) {
      // MNUtil.showHUD(`æ²¡æœ‰æ–°å†…å®¹éœ€è¦ç§»åŠ¨åˆ° ${defaultField} å­—æ®µï¼`);
      return;
    }

    // åœ¨ç§»åŠ¨ä¹‹å‰å…ˆæå– markdown é“¾æ¥
    let marginNoteLinks = this.extractMarginNoteLinksFromComments(note, moveIndexArr);
    
    // ç§»åŠ¨å†…å®¹åˆ°é»˜è®¤å­—æ®µ
    this.moveCommentsArrToField(note, moveIndexArr, defaultField);
    
    if (!["è¯æ˜", "åä¾‹", "åŸç†"].includes(this.normalizeFieldName(defaultField))) {
      return
    }
    // å¤„ç†ä¹‹å‰æå–çš„ MarginNote é“¾æ¥
    if (marginNoteLinks.length > 0) {
      this.processExtractedMarginNoteLinks(note, marginNoteLinks);
    }
  }
  
  /**
   * ä»è¯„è®ºä¸­æå– MarginNote é“¾æ¥
   * 
   * @param {MNNote} note - å½“å‰å¡ç‰‡
   * @param {number[]} indexArr - è¦æ£€æŸ¥çš„è¯„è®ºç´¢å¼•æ•°ç»„
   * @returns {Array<{text: string, url: string}>} - æ‰¾åˆ°çš„ MarginNote é“¾æ¥æ•°ç»„
   */
  static extractMarginNoteLinksFromComments(note, indexArr) {
    let marginNoteLinks = [];
    
    indexArr.forEach(index => {
      let comment = note.MNComments[index];
      if (!comment || comment.type !== "markdownComment") {
        return;
      }
      
      // æå–æ‰€æœ‰ Markdown æ ¼å¼çš„é“¾æ¥ [æ–‡æœ¬](URL)
      let markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
      let matches;
      
      while ((matches = markdownLinkRegex.exec(comment.text)) !== null) {
        let linkText = matches[1];
        let linkUrl = matches[2];
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ MarginNote é“¾æ¥
        if (this.isMarginNoteLink(linkUrl)) {
          marginNoteLinks.push({
            text: linkText,
            url: linkUrl
          });
        }
      }
    });
    
    return marginNoteLinks;
  }
  
  /**
   * åˆ¤æ–­æ˜¯å¦æ˜¯ MarginNote é“¾æ¥
   * 
   * @param {string} url - è¦æ£€æŸ¥çš„ URL
   * @returns {boolean} - æ˜¯å¦æ˜¯ MarginNote é“¾æ¥
   */
  static isMarginNoteLink(url) {
    return /^marginnote[34]app:\/\/note\//.test(url);
  }
  
  /**
   * è·å–å¡ç‰‡çš„æœ€åä¸€ä¸ªå­—æ®µå
   * 
   * @param {MNNote} note - ç›®æ ‡å¡ç‰‡
   * @returns {string|null} - æœ€åä¸€ä¸ªå­—æ®µåï¼Œå¦‚æœæ²¡æœ‰å­—æ®µåˆ™è¿”å› null
   */
  static getLastFieldOfNote(note) {
    let commentsObj = this.parseNoteComments(note);
    let htmlComments = commentsObj.htmlCommentsObjArr;
    
    if (htmlComments.length === 0) {
      return null;
    }
    
    // è¿”å›æœ€åä¸€ä¸ª HTML å­—æ®µçš„æ–‡æœ¬
    return htmlComments[htmlComments.length - 1].text;
  }
  
  /**
   * ç§»é™¤å¡ç‰‡æœ€åä¸€ä¸ªå­—æ®µä¸­çš„é‡å¤é“¾æ¥
   * å¦‚æœç›¸åŒçš„é“¾æ¥åœ¨æœ€åä¸€ä¸ªå­—æ®µä¸­å‡ºç°å¤šæ¬¡ï¼Œåªä¿ç•™ç¬¬ä¸€ä¸ª
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   */
  /**
   * å¤„ç†å·²æå–çš„ MarginNote é“¾æ¥
   * 
   * @param {MNNote} note - å½“å‰å¡ç‰‡
   * @param {Array<{text: string, url: string}>} marginNoteLinks - å·²æå–çš„é“¾æ¥æ•°ç»„
   */
  static processExtractedMarginNoteLinks(note, marginNoteLinks) {
    // å®šä¹‰å…è®¸é“¾æ¥çš„ç›®æ ‡å­—æ®µï¼ˆæ ‡å‡†åŒ–åçš„åç§°ï¼Œæ— å†’å·ï¼‰
    const normalizedAllowedFields = [
      "ç›¸å…³é“¾æ¥",
      "åº”ç”¨"
    ];
    
    let successCount = 0;
    let skippedCount = 0;
    
    // å¤„ç†æ¯ä¸ªæ‰¾åˆ°çš„ MarginNote é“¾æ¥
    marginNoteLinks.forEach(linkInfo => {
      try {
        // ä»é“¾æ¥ä¸­æå– noteId
        let targetNoteId = linkInfo.url.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
        if (!targetNoteId) {
          return;
        }
        
        // è·å–ç›®æ ‡å¡ç‰‡
        let targetNote = MNNote.new(targetNoteId, false);
        if (!targetNote) {
          return;
        }
        
        // è·å–ç›®æ ‡å¡ç‰‡çš„æ‰€æœ‰ HTML è¯„è®ºå­—æ®µ
        let htmlCommentsTextArr = this.parseNoteComments(targetNote).htmlCommentsTextArr;
        
        // æ£€æŸ¥ç›®æ ‡å¡ç‰‡ä¸­æ˜¯å¦å­˜åœ¨ä»»ä½•å…è®¸çš„å­—æ®µï¼ˆä½¿ç”¨æ ‡å‡†åŒ–åçš„å­—æ®µåæ¯”è¾ƒï¼‰
        let hasAllowedField = htmlCommentsTextArr.some(fieldText => {
          let normalizedFieldText = this.normalizeFieldName(fieldText);
          return normalizedAllowedFields.some(allowedField => 
            normalizedFieldText.includes(allowedField)
          );
        });
        
        if (!hasAllowedField) {
          skippedCount++;
          return;
        }
        
        // æ·»åŠ å•å‘é“¾æ¥ï¼ˆä» note åˆ° targetNoteï¼‰
        targetNote.appendNoteLink(note, "To");
        
        // å¯¹ç›®æ ‡å¡ç‰‡çš„æœ€åä¸€ä¸ªå­—æ®µè¿›è¡Œé“¾æ¥å»é‡
        this.removeDuplicateLinksInLastField(targetNote);
        
        successCount++;
        
      } catch (error) {
        // è®°å½•é”™è¯¯å¹¶ç»§ç»­å¤„ç†å…¶ä»–é“¾æ¥
        KnowledgeBaseUtils.addErrorLog(
          `å¤„ç†åå‘é“¾æ¥æ—¶å‘ç”Ÿé”™è¯¯ï¼š${error.message}`, 
          "processExtractedMarginNoteLinks",
          { error: error.stack }
        );
      }
    });
    
    // å¦‚æœæœ‰è·³è¿‡çš„é“¾æ¥ï¼Œæ˜¾ç¤ºæç¤º
    if (skippedCount > 0 && successCount === 0) {
      // MNUtil.showHUD(`âš ï¸ ${skippedCount} ä¸ªé“¾æ¥å› ç›®æ ‡å¡ç‰‡ç¼ºå°‘"ç›¸å…³é“¾æ¥"æˆ–"åº”ç”¨"å­—æ®µè€Œæœªå»ºç«‹åå‘é“¾æ¥`);
    }
  }

  /**
   * åˆ¤æ–­ä¸€ä¸ªé“¾æ¥æ˜¯å¦æŒ‡å‘ä»»åŠ¡å¡ç‰‡
   * 
   * @param {string} linkUrl - MarginNote é“¾æ¥ URL
   * @returns {boolean} æ˜¯å¦æ˜¯ä»»åŠ¡å¡ç‰‡é“¾æ¥
   */
  static isTaskCardLink(linkUrl) {
    try {
      // ä» URL æå– noteId
      const noteIdMatch = linkUrl.match(/marginnote[34]app:\/\/note\/([A-Z0-9-]+)/i);
      if (!noteIdMatch || !noteIdMatch[1]) {
        return false;
      }
      
      const noteId = noteIdMatch[1];
      
      // è·å–å¯¹åº”çš„ MNNote å¯¹è±¡
      const targetNote = MNNote.new(noteId, false);
      if (!targetNote) {
        return false;
      }
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦åŠ è½½ MNTaskManager
      if (typeof MNTaskManager === 'undefined') {
        // å°è¯•åŠ¨æ€åŠ è½½ MNTaskManager
        try {
          JSB.require('mntask/xdyy_utils_extensions');
        } catch (e) {
          // å¦‚æœæ— æ³•åŠ è½½ï¼Œä½¿ç”¨å†…ç½®çš„ç®€å•åˆ¤æ–­
          const title = targetNote.noteTitle || "";
          if (!title.startsWith("ã€") || !title.includes("ï½œ") || !title.includes("ã€‘")) {
            return false;
          }
          
          // ç®€å•æå–ç±»å‹
          const typeMatch = title.match(/ã€([^>ï½œ]+)/);
          if (!typeMatch) return false;
          
          const type = typeMatch[1].trim();
          const validTypes = ["ç›®æ ‡", "å…³é”®ç»“æœ", "é¡¹ç›®", "åŠ¨ä½œ"];
          return validTypes.includes(type);
        }
      }
      
      // ä½¿ç”¨ MNTaskManager.isTaskCard åˆ¤æ–­
      return MNTaskManager.isTaskCard(targetNote);
      
    } catch (error) {
      // å‡ºé”™æ—¶è¿”å› false
      return false;
    }
  }

  /**
   * åŠ å…¥å¤ä¹ 
   */
  static addToReview(note, reviewEverytime = true) {
    let includingTypes = ["å®šä¹‰", "å‘½é¢˜", "ä¾‹å­", "åä¾‹", "æ€æƒ³æ–¹æ³•", "é—®é¢˜", "æ€è·¯"];
    if (this.getNoteType(note) && includingTypes.includes(this.getNoteType(note))) {
      if (reviewEverytime) {
        // æ‰§è¡Œä¸€æ¬¡åŠ å…¥åˆ°å¤ä¹ ä¸€æ¬¡
        MNUtil.excuteCommand("AddToReview")
      } else {
        // æ‰§è¡Œçš„æ—¶å€™å¦‚æœå·²ç»åŠ å…¥åˆ°å¤ä¹ äº†ï¼Œå°±ä¸åŠ å…¥
        if (!MNUtil.isNoteInReview(note.noteId)) {  // 2024-09-26 æ–°å¢çš„ API
          MNUtil.excuteCommand("AddToReview")
        }
      }
    }
  }

  /**
   * è½¬åŒ–ä¸ºéæ‘˜å½•ç‰ˆæœ¬
   */
  static toNoExcerptVersion(note, inputParentNote){
    let parentNote = inputParentNote || note.parentNote
    if (parentNote) {
      if (note.excerptText) { // æŠŠæ‘˜å½•å†…å®¹çš„æ£€æµ‹æ”¾åˆ° toNoExcerptVersion çš„å†…éƒ¨
        let config = {
          title: note.noteTitle,
          content: "",
          markdown: true,
          color: note.colorIndex
        }
        // åˆ›å»ºæ–°å…„å¼Ÿå¡ç‰‡ï¼Œæ ‡é¢˜ä¸ºæ—§å¡ç‰‡çš„æ ‡é¢˜
        let newNote = parentNote.createChildNote(config)
        
        note.noteTitle = ""

        let index = note.indexInBrotherNotes
        
        // å°†æ—§å¡ç‰‡åˆå¹¶åˆ°æ–°å¡ç‰‡ä¸­
        note.mergeInto(newNote)

        newNote.moveTo(index)
      
        return newNote; // è¿”å›æ–°å¡ç‰‡
      } else {
        return note;
      }
    } else {
      MNUtil.showHUD("æ²¡æœ‰çˆ¶å¡ç‰‡ï¼Œæ— æ³•è¿›è¡Œéæ‘˜å½•ç‰ˆæœ¬çš„è½¬æ¢ï¼")
      return note
    }
  }

  // ============================================
  // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šä¸´æ—¶ç¼“å­˜è¾…åŠ©å‡½æ•°
  // ============================================

  /**
   * è·å–ç¼“å­˜çš„å¡ç‰‡ç±»å‹
   *
   * @param {MNNote} note - å¡ç‰‡å¯¹è±¡
   * @param {Object} cache - ç¼“å­˜å¯¹è±¡
   * @returns {string|undefined} å¡ç‰‡ç±»å‹
   */
  static getCachedNoteType(note, cache) {
    if (!cache || !cache.noteTypes) {
      // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œç›´æ¥è°ƒç”¨åŸå‡½æ•°
      return this.getNoteType(note, true);
    }

    const cacheKey = note.noteId;
    if (cache.noteTypes.has(cacheKey)) {
      return cache.noteTypes.get(cacheKey);
    }

    // ä½¿ç”¨ directly=true é¿å…é€’å½’è°ƒç”¨ getFirstClassificationParentNote
    const type = this.getNoteType(note, true);
    cache.noteTypes.set(cacheKey, type);
    return type;
  }

  /**
   * è·å–ç¼“å­˜çš„å½’ç±»çˆ¶å¡ç‰‡
   *
   * @param {MNNote} note - å¡ç‰‡å¯¹è±¡
   * @param {Object} cache - ç¼“å­˜å¯¹è±¡
   * @returns {MNNote|null} å½’ç±»çˆ¶å¡ç‰‡
   */
  static getCachedClassificationParent(note, cache) {
    if (!cache || !cache.classificationParent) {
      // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œè°ƒç”¨åŸå‡½æ•°
      return this.getFirstClassificationParentNote(note);
    }

    const cacheKey = note.noteId;
    if (cache.classificationParent.has(cacheKey)) {
      return cache.classificationParent.get(cacheKey);
    }

    const parent = this.getFirstClassificationParentNoteOptimized(note, cache);
    cache.classificationParent.set(cacheKey, parent);
    return parent;
  }

  /**
   * è·å–ç¼“å­˜çš„è§£æè¯„è®ºå¯¹è±¡
   *
   * @param {MNNote} note - å¡ç‰‡å¯¹è±¡
   * @param {Object} cache - ç¼“å­˜å¯¹è±¡
   * @returns {Object} è§£æåçš„è¯„è®ºå¯¹è±¡
   */
  static getCachedParsedComments(note, cache) {
    if (!cache || !cache.parsedComments) {
      // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œç›´æ¥è°ƒç”¨åŸå‡½æ•°
      return this.parseNoteComments(note);
    }

    const cacheKey = note.noteId;
    if (cache.parsedComments.has(cacheKey)) {
      return cache.parsedComments.get(cacheKey);
    }

    const parsed = this.parseNoteComments(note);
    cache.parsedComments.set(cacheKey, parsed);
    return parsed;
  }

  /**
   * ä¼˜åŒ–ç‰ˆçš„å½’ç±»çˆ¶å¡ç‰‡æŸ¥æ‰¾ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
   *
   * @param {MNNote} note - å½“å‰å¡ç‰‡
   * @param {Object} cache - ç¼“å­˜å¯¹è±¡
   * @returns {MNNote|null} æ‰¾åˆ°çš„å½’ç±»çˆ¶å¡ç‰‡ï¼Œæœªæ‰¾åˆ°è¿”å› null
   */
  static getFirstClassificationParentNoteOptimized(note, cache) {
    let parentNote = note.parentNote;
    let depth = 0;

    while (parentNote) {
      depth++;
      // ä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬è·å–ç±»å‹ï¼Œé¿å…é‡å¤è®¡ç®—
      const parentType = this.getCachedNoteType(parentNote, cache);
      if (parentType === "å½’ç±»") {
        // KnowledgeBaseUtils.log("æ‰¾åˆ°å½’ç±»çˆ¶å¡ç‰‡ï¼ˆä¼˜åŒ–ç‰ˆï¼‰", "getFirstClassificationParentNoteOptimized", {
        //   noteId: note.noteId,
        //   classificationParentNoteId: parentNote.noteId,
        //   classificationParentNoteTitle: parentNote.noteTitle,
        //   traversalDepth: depth
        // });
        return parentNote;
      }
      parentNote = parentNote.parentNote;
    }

    // KnowledgeBaseUtils.log("æœªæ‰¾åˆ°å½’ç±»çˆ¶å¡ç‰‡ï¼ˆä¼˜åŒ–ç‰ˆï¼‰", "getFirstClassificationParentNoteOptimized", {
    //   noteId: note.noteId,
    //   traversalDepth: depth
    // });

    return null;
  }

  /**
   * ä»è§£æçš„è¯„è®ºå¯¹è±¡ä¸­è·å–æŒ‡å®šå­—æ®µä¸‹çš„æ‰€æœ‰é“¾æ¥
   *
   * @param {Object} commentsObj - parseNoteComments è¿”å›çš„å¯¹è±¡
   * @param {string[]} fieldNames - å­—æ®µåç§°æ•°ç»„ï¼Œå¦‚ ["æ‰€å±", "åŒ…å«", "ç›¸å…³é“¾æ¥"]
   * @returns {Array} å­—æ®µä¸‹çš„é“¾æ¥å¯¹è±¡æ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å« {index, link, text}
   */
  static getLinksInFields(commentsObj, fieldNames) {
    const linksInFields = [];

    if (!commentsObj || !commentsObj.htmlCommentsObjArr || !commentsObj.linksObjArr) {
      return linksInFields;
    }

    // éå†æ‰€æœ‰ HTML å­—æ®µ
    for (let htmlObj of commentsObj.htmlCommentsObjArr) {
      // æ£€æŸ¥å­—æ®µåç§°æ˜¯å¦åœ¨ç›®æ ‡å­—æ®µåˆ—è¡¨ä¸­
      const isTargetField = fieldNames.some(field => htmlObj.text.includes(field));

      if (isTargetField && htmlObj.excludingFieldBlockIndexArr) {
        // æ‰¾å‡ºè¿™ä¸ªå­—æ®µä¸‹çš„æ‰€æœ‰é“¾æ¥
        for (let linkObj of commentsObj.linksObjArr) {
          if (htmlObj.excludingFieldBlockIndexArr.includes(linkObj.index)) {
            linksInFields.push(linkObj);
          }
        }
      }
    }

    return linksInFields;
  }

  /**
   * é“¾æ¥å¹¿ä¹‰çš„çˆ¶å¡ç‰‡ï¼ˆå¯èƒ½æ˜¯é“¾æ¥å½’ç±»å¡ç‰‡ï¼‰
   *
   * æ”¯æŒæ¸…ç†æ—§é“¾æ¥ï¼šå½“å¡ç‰‡ç§»åŠ¨ä½ç½®å¯¼è‡´çˆ¶å¡ç‰‡æ”¹å˜æ—¶ï¼Œä¼šè‡ªåŠ¨åˆ é™¤ä¸æ—§çˆ¶å¡ç‰‡çš„é“¾æ¥
   * æ”¯æŒç´¯æ¬¡å åŠ ï¼šé€šè¿‡ accumulate å‚æ•°æ§åˆ¶æ˜¯å¦ä¿ç•™æ—§çš„çˆ¶å¡ç‰‡é“¾æ¥
   *
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   * @param {boolean} force - æ˜¯å¦å¼ºåˆ¶æ¸…ç†æ—§é“¾æ¥ï¼ˆé»˜è®¤ trueï¼‰
   * @param {boolean} accumulate - æ˜¯å¦ç´¯æ¬¡å åŠ æ¨¡å¼ï¼ˆä¸åˆ é™¤æ—§é“¾æ¥ï¼Œé»˜è®¤ falseï¼‰
   */
  static linkParentNote(note, force = true, accumulate = false) {
    // ============================================
    // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šåˆ›å»ºä¸´æ—¶ç¼“å­˜å¯¹è±¡
    // ============================================
    const cache = {
      noteTypes: new Map(),
      parsedComments: new Map(),
      classificationParent: new Map()
    };

    // ä¸€æ¬¡æ€§è·å–å¹¶ç¼“å­˜å½“å‰å¡ç‰‡ç±»å‹
    const noteType = this.getCachedNoteType(note, cache);

    // KnowledgeBaseUtils.log("å¼€å§‹æ‰§è¡Œ linkParentNoteï¼ˆä¼˜åŒ–ç‰ˆï¼‰", "linkParentNote", {
    //   noteId: note.noteId,
    //   noteType: noteType,
    //   force: force,
    //   accumulate: accumulate
    // })

    /**
     * ä¸å¤„ç†çš„ç±»å‹
     */
    const excludingTypes = ["æ€è·¯", "æ€»ç»“", "ç ”ç©¶è¿›å±•"];
    if (excludingTypes.includes(noteType)) {
      // KnowledgeBaseUtils.log("è·³è¿‡ä¸å¤„ç†çš„ç±»å‹", "linkParentNote", {
      //   noteType: noteType
      // })
      return; // ä¸å¤„ç†
    }

    const parentNote = note.parentNote;
    if (parentNote) {
      // è·å–å¹¶ç¼“å­˜çˆ¶å¡ç‰‡ç±»å‹
      const parentNoteType = this.getCachedNoteType(parentNote, cache);

      // è·å–å¡ç‰‡ç±»å‹ï¼Œç¡®å®šé“¾æ¥ç§»åŠ¨çš„ç›®æ ‡å­—æ®µ
      let parentNoteInNoteTargetField;  // çˆ¶å¡ç‰‡åœ¨ note ä¸­çš„é“¾æ¥æœ€ç»ˆè¦åˆ°çš„å­—æ®µ
      let ifParentNoteInNoteTargetFieldToBottom = false; // çˆ¶å¡ç‰‡åœ¨ note ä¸­çš„é“¾æ¥æœ€ç»ˆè¦åˆ°çš„æ˜¯å¦æ˜¯å­—æ®µçš„åº•éƒ¨
      let noteInParentNoteTargetField; // note åœ¨çˆ¶å¡ç‰‡ä¸­çš„é“¾æ¥æœ€ç»ˆè¦åˆ°çš„å­—æ®µ
      let ifNoteInParentNoteTargetFieldToBottom = false; // note åœ¨çˆ¶å¡ç‰‡ä¸­çš„é“¾æ¥æœ€ç»ˆè¦åˆ°çš„æ˜¯å¦æ˜¯å­—æ®µçš„åº•éƒ¨

      // ç”¨äºå®é™…é“¾æ¥æ“ä½œçš„çˆ¶å¡ç‰‡å˜é‡
      let actualParentNote = parentNote;

      switch (noteType) {
        case "å½’ç±»":
          if (parentNoteType !== "å½’ç±»") {
            switch (parentNoteType) {
              case "å®šä¹‰":
                parentNoteInNoteTargetField = "æ‰€å±";
                ifParentNoteInNoteTargetFieldToBottom = false;
                noteInParentNoteTargetField = "ç›¸å…³é“¾æ¥";
                ifNoteInParentNoteTargetFieldToBottom = true;
                break;
              default:
                parentNoteInNoteTargetField = "æ‰€å±";
                ifParentNoteInNoteTargetFieldToBottom = false;
                noteInParentNoteTargetField = "ç›¸å…³é“¾æ¥";
                ifNoteInParentNoteTargetFieldToBottom = true;
                break;
            }
          } else {
            // çˆ¶å¡ç‰‡ä¸ºå½’ç±»å¡ç‰‡
            parentNoteInNoteTargetField = "æ‰€å±";
            ifParentNoteInNoteTargetFieldToBottom = false;
            noteInParentNoteTargetField = "åŒ…å«";
            ifNoteInParentNoteTargetFieldToBottom = true;
          }
          break;
        default:
          // å¯¹äºéå½’ç±»å¡ç‰‡ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå½’ç±»çˆ¶å¡ç‰‡ï¼ˆä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬ï¼‰
          // KnowledgeBaseUtils.log("å¼€å§‹æŸ¥æ‰¾å½’ç±»çˆ¶å¡ç‰‡ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰", "linkParentNote", {
          //   noteId: note.noteId
          // })

          const classificationParentNote = this.getCachedClassificationParent(note, cache);

          // KnowledgeBaseUtils.log("å®ŒæˆæŸ¥æ‰¾å½’ç±»çˆ¶å¡ç‰‡", "linkParentNote", {
          //   noteId: note.noteId,
          //   found: !!classificationParentNote,
          //   classificationParentNoteId: classificationParentNote?.noteId
          // })

          if (classificationParentNote) {
            actualParentNote = classificationParentNote;
            parentNoteInNoteTargetField = "ç›¸å…³é“¾æ¥";
            ifParentNoteInNoteTargetFieldToBottom = false;
            noteInParentNoteTargetField = "åŒ…å«";
            ifNoteInParentNoteTargetFieldToBottom = true;
          } else {
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å½’ç±»çˆ¶å¡ç‰‡ï¼Œç›´æ¥è¿”å›ï¼Œä¸å¤„ç†
            return;
          }
          break;
      }

      // æ¸…ç†æ—§é“¾æ¥ï¼ˆå¦‚æœéœ€è¦ä¸”ä¸æ˜¯ç´¯æ¬¡å åŠ æ¨¡å¼ï¼‰
      if (force && !accumulate) {
        /**
         * æ¸…ç†æ—§é“¾æ¥ï¼šåˆ é™¤ä¸å…¶ä»–çˆ¶å¡ç‰‡çš„é“¾æ¥
         */
        // KnowledgeBaseUtils.log("å¼€å§‹ cleanupOldParentLinksï¼ˆéç´¯æ¬¡å åŠ ï¼‰", "linkParentNote", {
        //   noteId: note.noteId,
        //   actualParentNoteId: actualParentNote.noteId
        // })

        this.cleanupOldParentLinks(note, actualParentNote, cache);

        // KnowledgeBaseUtils.log("å®Œæˆ cleanupOldParentLinks", "linkParentNote", {
        //   noteId: note.noteId
        // })
      } else if (accumulate) {
        // KnowledgeBaseUtils.log("ç´¯æ¬¡å åŠ æ¨¡å¼ï¼šè·³è¿‡æ¸…ç†æ—§é“¾æ¥", "linkParentNote", {
        //   noteId: note.noteId
        // })
      }

      /**
       * å…ˆä¿è¯æœ‰é“¾æ¥ï¼ˆåœ¨ç¡®å®šç›®æ ‡å­—æ®µåå†æ·»åŠ é“¾æ¥ï¼‰
       */
      let parentNoteInNoteIndex = this.getNoteIndexInAnotherNote(actualParentNote, note)
      let noteInParentNoteIndex = this.getNoteIndexInAnotherNote(note, actualParentNote)

      // KnowledgeBaseUtils.log("æŸ¥æ‰¾é“¾æ¥ç´¢å¼•å®Œæˆ", "linkParentNote", {
      //   noteId: note.noteId,
      //   parentNoteInNoteIndex: parentNoteInNoteIndex,
      //   noteInParentNoteIndex: noteInParentNoteIndex
      // })

      // å¦‚æœæ²¡æœ‰é“¾æ¥ï¼Œå…ˆæ·»åŠ é“¾æ¥
      if (parentNoteInNoteIndex == -1) {
        note.appendNoteLink(actualParentNote, "To")
        // é‡æ–°è·å–ç´¢å¼•ï¼ˆå› ä¸ºæ·»åŠ äº†é“¾æ¥ï¼‰
        parentNoteInNoteIndex = this.getNoteIndexInAnotherNote(actualParentNote, note)

        // KnowledgeBaseUtils.log("æ·»åŠ çˆ¶å¡ç‰‡é“¾æ¥åˆ° note", "linkParentNote", {
        //   noteId: note.noteId,
        //   newIndex: parentNoteInNoteIndex
        // })
      }
      if (noteInParentNoteIndex == -1) {
        actualParentNote.appendNoteLink(note, "To")
        // é‡æ–°è·å–ç´¢å¼•ï¼ˆå› ä¸ºæ·»åŠ äº†é“¾æ¥ï¼‰
        noteInParentNoteIndex = this.getNoteIndexInAnotherNote(note, actualParentNote)

        // KnowledgeBaseUtils.log("æ·»åŠ  note é“¾æ¥åˆ°çˆ¶å¡ç‰‡", "linkParentNote", {
        //   noteId: note.noteId,
        //   newIndex: noteInParentNoteIndex
        // })
      }

      // KnowledgeBaseUtils.log(`linkParentNote: parentNoteInNoteIndex=${parentNoteInNoteIndex}, noteInParentNoteIndex=${noteInParentNoteIndex}`, "linkParentNote", {linkParentNote:this.ifLinkParentNote(note)})

      // æœ€åè¿›è¡Œç§»åŠ¨ï¼ˆç¡®ä¿ç´¢å¼•æ˜¯æœ€æ–°çš„ï¼‰
      if (parentNoteInNoteIndex !== -1 && parentNoteInNoteTargetField) {
        // KnowledgeBaseUtils.log("å¼€å§‹ç§»åŠ¨çˆ¶å¡ç‰‡é“¾æ¥åˆ°ç›®æ ‡å­—æ®µ", "linkParentNote", {
        //   noteId: note.noteId,
        //   targetField: parentNoteInNoteTargetField,
        //   index: parentNoteInNoteIndex
        // })

        this.moveCommentsArrToField(note, [parentNoteInNoteIndex], parentNoteInNoteTargetField, ifParentNoteInNoteTargetFieldToBottom)

        // KnowledgeBaseUtils.log("å®Œæˆç§»åŠ¨çˆ¶å¡ç‰‡é“¾æ¥", "linkParentNote", {
        //   noteId: note.noteId
        // })
      }
      if (noteInParentNoteIndex !== -1 && noteInParentNoteTargetField) {
        // KnowledgeBaseUtils.log("å¼€å§‹ç§»åŠ¨ note é“¾æ¥åˆ°çˆ¶å¡ç‰‡ç›®æ ‡å­—æ®µ", "linkParentNote", {
        //   noteId: note.noteId,
        //   targetField: noteInParentNoteTargetField,
        //   index: noteInParentNoteIndex
        // })

        this.moveCommentsArrToField(actualParentNote, [noteInParentNoteIndex], noteInParentNoteTargetField, ifNoteInParentNoteTargetFieldToBottom)

        // KnowledgeBaseUtils.log("å®Œæˆç§»åŠ¨ note é“¾æ¥åˆ°çˆ¶å¡ç‰‡", "linkParentNote", {
        //   noteId: note.noteId
        // })
      }

      // KnowledgeBaseUtils.log("linkParentNote æ‰§è¡Œå®Œæˆ", "linkParentNote", {
      //   noteId: note.noteId
      // })
    }
  }

  /**
   * æ¸…ç†æ—§çš„çˆ¶å¡ç‰‡é“¾æ¥ï¼ˆç®€åŒ–ä¼˜åŒ–ç‰ˆï¼‰
   *
   * ç­–ç•¥ï¼šåªæ¸…ç†ç‰¹å®šå­—æ®µä¸‹æŒ‡å‘å…¶ä»–å½’ç±»å¡ç‰‡çš„é“¾æ¥
   *
   * @param {MNNote} note - å½“å‰å¡ç‰‡
   * @param {MNNote} currentParentNote - å½“å‰çš„çˆ¶å¡ç‰‡ï¼Œä¸ä¼šè¢«åˆ é™¤
   * @param {Object} cache - ç¼“å­˜å¯¹è±¡ï¼ˆå¯é€‰ï¼‰
   */
  static cleanupOldParentLinks(note, currentParentNote, cache = null) {
    // KnowledgeBaseUtils.log("å¼€å§‹æ‰§è¡Œ cleanupOldParentLinksï¼ˆç®€åŒ–ä¼˜åŒ–ç‰ˆï¼‰", "cleanupOldParentLinks", {
    //   noteId: note.noteId,
    //   currentParentNoteId: currentParentNote?.noteId,
    //   hasCache: !!cache
    // });

    // 1. è·å–å¡ç‰‡ç±»å‹
    const noteType = cache ?
      this.getCachedNoteType(note, cache) :
      this.getNoteType(note, true);

    // 2. æ ¹æ®å¡ç‰‡ç±»å‹åŠ¨æ€å†³å®šè¦æ¸…ç†çš„å­—æ®µ
    // å½’ç±»å¡ç‰‡ï¼š"æ‰€å±"å­˜æ”¾ä¸Šçº§å½’ç±»ï¼Œ"åŒ…å«"å­˜æ”¾å­å¡ç‰‡ï¼Œ"ç›¸å…³é“¾æ¥"å­˜æ”¾ç›¸å…³é“¾æ¥
    // å…¶ä»–å¡ç‰‡ï¼šåªæœ‰"ç›¸å…³é“¾æ¥"å­—æ®µå¯èƒ½æœ‰çˆ¶å½’ç±»é“¾æ¥
    const targetFields = noteType === "å½’ç±»"
      ? ["æ‰€å±", "ç›¸å…³é“¾æ¥"]      // å½’ç±»å¡ç‰‡ï¼šä¿æŠ¤"åŒ…å«"å­—æ®µ
      : ["ç›¸å…³é“¾æ¥"];             // å…¶ä»–å¡ç‰‡ï¼šåªæ¸…ç†"ç›¸å…³é“¾æ¥"

    // KnowledgeBaseUtils.log("ç¡®å®šè¦æ¸…ç†çš„å­—æ®µ", "cleanupOldParentLinks", {
    //   noteId: note.noteId,
    //   noteType: noteType,
    //   targetFields: targetFields
    // });

    // 1. ä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬è§£æè¯„è®º
    const commentsObj = cache ?
      this.getCachedParsedComments(note, cache) :
      this.parseNoteComments(note);

    // KnowledgeBaseUtils.log("å®Œæˆè§£æè¯„è®º", "cleanupOldParentLinks", {
    //   noteId: note.noteId,
    //   totalLinks: commentsObj.linksObjArr.length
    // });

    // 2. è·å–ç›®æ ‡å­—æ®µä¸‹çš„æ‰€æœ‰é“¾æ¥
    const linksInTargetFields = this.getLinksInFields(commentsObj, targetFields);

    if (linksInTargetFields.length === 0) {
      // KnowledgeBaseUtils.log("ç›®æ ‡å­—æ®µä¸‹æ²¡æœ‰é“¾æ¥ï¼Œæå‰è¿”å›", "cleanupOldParentLinks", {
      //   noteId: note.noteId
      // });
      return;
    }

    // KnowledgeBaseUtils.log("æ‰¾åˆ°ç›®æ ‡å­—æ®µä¸‹çš„é“¾æ¥", "cleanupOldParentLinks", {
    //   noteId: note.noteId,
    //   linkCount: linksInTargetFields.length
    // });

    // 3. æ”¶é›†éœ€è¦åˆ é™¤çš„æ—§çˆ¶å¡ç‰‡é“¾æ¥
    const linksToRemove = [];

    for (let linkObj of linksInTargetFields) {
      try {
        // æå–é“¾æ¥çš„ç›®æ ‡ noteId
        const targetNoteId = linkObj.link.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
        if (!targetNoteId) continue;

        // ä¿æŠ¤å½“å‰çˆ¶å¡ç‰‡
        if (currentParentNote && targetNoteId === currentParentNote.noteId) {
          continue;
        }

        // è·å–ç›®æ ‡å¡ç‰‡
        const targetNote = MNNote.new(targetNoteId, false);
        if (!targetNote) continue;

        // ä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬è·å–ç›®æ ‡å¡ç‰‡ç±»å‹
        const targetType = cache ?
          this.getCachedNoteType(targetNote, cache) :
          this.getNoteType(targetNote, true);

        // åªæ¸…ç†æŒ‡å‘å½’ç±»å¡ç‰‡çš„é“¾æ¥
        if (targetType === "å½’ç±»") {
          // æ£€æŸ¥ç›®æ ‡å¡ç‰‡æ˜¯å¦æ˜¯å½“å‰å¡ç‰‡çš„å­å¡ç‰‡
          // å¦‚æœæ˜¯å­å¡ç‰‡ï¼Œä¸åº”è¯¥æ¸…ç†è¿™ä¸ªé“¾æ¥ï¼ˆä¾‹å¦‚ï¼šå®šä¹‰å¡ç‰‡ A æœ‰å½’ç±»å­å¡ç‰‡ Bï¼‰
          if (targetNote.parentNote && targetNote.parentNote.noteId === note.noteId) {
            // KnowledgeBaseUtils.log("è·³è¿‡æ¸…ç†å­å¡ç‰‡é“¾æ¥", "cleanupOldParentLinks", {
            //   noteId: note.noteId,
            //   childNoteId: targetNoteId
            // });
            continue;
          }

          linksToRemove.push({
            targetNote: targetNote,
            linkText: linkObj.link
          });

          // KnowledgeBaseUtils.log("æ ‡è®°å¾…åˆ é™¤é“¾æ¥", "cleanupOldParentLinks", {
          //   noteId: note.noteId,
          //   targetNoteId: targetNoteId,
          //   targetType: targetType
          // });
        }
      } catch (error) {
        // å¿½ç•¥è§£æé”™è¯¯ï¼Œç»§ç»­å¤„ç†å…¶ä»–é“¾æ¥
        // KnowledgeBaseUtils.log("è§£æé“¾æ¥æ—¶å‡ºé”™", "cleanupOldParentLinks", {
        //   error: error.message
        // });
      }
    }

    // KnowledgeBaseUtils.log("å®Œæˆæ”¶é›†å¾…æ¸…ç†é“¾æ¥", "cleanupOldParentLinks", {
    //   noteId: note.noteId,
    //   totalToRemove: linksToRemove.length
    // });

    // 4. æ‰§è¡Œæ¸…ç†ï¼šåˆ é™¤åŒå‘é“¾æ¥
    if (linksToRemove.length > 0) {
      for (let removal of linksToRemove) {
        try {
          // åˆ é™¤å½“å‰å¡ç‰‡ä¸­æŒ‡å‘æ—§çˆ¶å¡ç‰‡çš„é“¾æ¥
          this.removeCommentsByText(note, removal.linkText);

          // åˆ é™¤æ—§çˆ¶å¡ç‰‡ä¸­æŒ‡å‘å½“å‰å¡ç‰‡çš„é“¾æ¥
          this.removeLinkToNote(removal.targetNote, note.noteId);

          // KnowledgeBaseUtils.log("æˆåŠŸåˆ é™¤åŒå‘é“¾æ¥", "cleanupOldParentLinks", {
          //   noteId: note.noteId,
          //   removedTargetId: removal.targetNote.noteId
          // });
        } catch (error) {
          // å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ª
          // KnowledgeBaseUtils.log("åˆ é™¤é“¾æ¥æ—¶å‡ºé”™", "cleanupOldParentLinks", {
          //   error: error.message
          // });
        }
      }

      // KnowledgeBaseUtils.log("å®Œæˆæ‰§è¡Œæ¸…ç†", "cleanupOldParentLinks", {
      //   noteId: note.noteId,
      //   cleanedCount: linksToRemove.length
      // });
    } else {
      // KnowledgeBaseUtils.log("æ²¡æœ‰éœ€è¦æ¸…ç†çš„é“¾æ¥", "cleanupOldParentLinks", {
      //   noteId: note.noteId
      // });
    }

    // KnowledgeBaseUtils.log("cleanupOldParentLinks æ‰§è¡Œå®Œæˆ", "cleanupOldParentLinks", {
    //   noteId: note.noteId
    // });
  }

  /**
   * åˆ¤æ–­ä¸€ä¸ªå¡ç‰‡æ˜¯å¦å¯èƒ½æ˜¯å¦ä¸€ä¸ªå¡ç‰‡çš„çˆ¶å¡ç‰‡
   *
   * @param {MNNote} potentialParent - å¯èƒ½çš„çˆ¶å¡ç‰‡
   * @param {MNNote} childNote - å­å¡ç‰‡
   * @returns {boolean} - æ˜¯å¦æ˜¯æ½œåœ¨çš„çˆ¶å¡ç‰‡
   */
  static isPotentialParentNote(potentialParent, childNote) {
    if (!potentialParent || !childNote) return false;

    // é¦–å…ˆæ£€æŸ¥æ˜¯å¦çœŸçš„åœ¨ç¥–å…ˆé“¾ä¸­ï¼ˆå®é™…çš„çˆ¶å­å…³ç³»ï¼‰
    let current = childNote.parentNote;
    while (current) {
      if (current.noteId === potentialParent.noteId) {
        return true // æ‰¾åˆ°äº†çœŸå®çš„çˆ¶å¡ç‰‡å…³ç³»
      }
      current = current.parentNote
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯å­å¡ç‰‡ï¼ˆå¦‚æœpotentialParentæ˜¯childNoteçš„å­å¡ç‰‡ï¼Œåˆ™ç»å¯¹ä¸æ˜¯çˆ¶å¡ç‰‡ï¼‰
    let currentChild = potentialParent.parentNote
    while (currentChild) {
      if (currentChild.noteId === childNote.noteId) {
        return false // potentialParentæ˜¯childNoteçš„åä»£ï¼Œä¸å¯èƒ½æ˜¯çˆ¶å¡ç‰‡
      }
      currentChild = currentChild.parentNote
    }
    
    let potentialParentType = this.getNoteType(potentialParent)
    let childType = this.getNoteType(childNote)
    
    // åªæœ‰åœ¨ä¸æ˜¯å®é™…çˆ¶å­å…³ç³»çš„æƒ…å†µä¸‹ï¼Œæ‰æ ¹æ®ç±»å‹æ¥åˆ¤æ–­é€»è¾‘çˆ¶å­å…³ç³»
    // ç®€åŒ–åˆ¤æ–­é€»è¾‘ï¼šåŸºäºç±»å‹çš„ç»„åˆæ¥å†³å®š
    
    // 1. å½’ç±»å¡ç‰‡å¯èƒ½æ˜¯å…¶ä»–éå½’ç±»å¡ç‰‡çš„é€»è¾‘çˆ¶å¡ç‰‡
    if (potentialParentType === "å½’ç±»" && childType !== "å½’ç±»") {
      // å½’ç±»å¡ç‰‡å¯¹äºå‘½é¢˜ã€ä¾‹å­ã€å®šä¹‰ç­‰å¡ç‰‡éƒ½å¯èƒ½æ˜¯é€»è¾‘çˆ¶å¡ç‰‡
      return true
    }
    
    // 2. å®šä¹‰å¡ç‰‡å¯èƒ½æ˜¯å½’ç±»å¡ç‰‡çš„é€»è¾‘çˆ¶å¡ç‰‡
    if (potentialParentType === "å®šä¹‰" && childType === "å½’ç±»") {
      return true
    }
    
    // 3. å…¶ä»–ç±»å‹çš„çˆ¶å­å…³ç³»
    // é—®é¢˜ -> æ€è·¯
    if (potentialParentType === "é—®é¢˜" && childType === "æ€è·¯") {
      return true
    }
    
    // å‘½é¢˜ -> ä¾‹å­
    if (potentialParentType === "å‘½é¢˜" && childType === "ä¾‹å­") {
      return true
    }
    
    // å‘½é¢˜ -> åä¾‹
    if (potentialParentType === "å‘½é¢˜" && childType === "åä¾‹") {
      return true
    }
    
    // å¦‚æœæ²¡æœ‰åŒ¹é…çš„ç±»å‹ç»„åˆï¼Œä¸è®¤ä¸ºæ˜¯æ½œåœ¨çš„çˆ¶å¡ç‰‡
    return false
  }

  /**
   * è·å–ä¸€ä¸ªå¡ç‰‡åœ¨å¦ä¸€ä¸ªå¡ç‰‡ä¸­çš„ index
   */
  static getNoteIndexInAnotherNote(note, anotherNote) {
    return anotherNote.MNComments.findIndex(comment => comment && comment.type === "linkComment" && comment.text === note.noteURL);
  }

  /**
   * åˆ¤æ–­é“¾æ¥æ˜¯å¦åœ¨ linkParentNote ä½¿ç”¨çš„ç‰¹å®šå­—æ®µä¸‹
   * 
   * @param {number} linkIndex - é“¾æ¥åœ¨è¯„è®ºæ•°ç»„ä¸­çš„ç´¢å¼•
   * @param {Object} noteCommentsObj - parseNoteComments çš„è¿”å›ç»“æœ
   * @returns {boolean} - å¦‚æœé“¾æ¥åœ¨"æ‰€å±"ã€"åŒ…å«"æˆ–"ç›¸å…³é“¾æ¥"å­—æ®µä¸‹è¿”å› true
   */
  static isLinkInParentNoteFields(linkIndex, noteCommentsObj) {
    const parentNoteFields = ["æ‰€å±", "åŒ…å«", "ç›¸å…³é“¾æ¥"];
    
    // éå†æ‰€æœ‰ HTML å­—æ®µ
    for (let htmlObj of noteCommentsObj.htmlCommentsObjArr) {
      // æ£€æŸ¥å­—æ®µåç§°æ˜¯å¦åŒ…å« linkParentNote ä½¿ç”¨çš„å­—æ®µ
      let isParentNoteField = parentNoteFields.some(field => htmlObj.text.includes(field));
      
      if (isParentNoteField) {
        // æ£€æŸ¥é“¾æ¥æ˜¯å¦åœ¨è¿™ä¸ªå­—æ®µä¸‹ï¼ˆä½¿ç”¨ excludingFieldBlockIndexArrï¼‰
        if (htmlObj.excludingFieldBlockIndexArr.includes(linkIndex)) {
          return true;
        }
      }
    }
    
    return false;
  }

  /**
   * æ£€æŸ¥ä¸¤å¼ å¡ç‰‡æ˜¯å¦äº’ä¸ºæœ€åä¸€æ¡è¯„è®ºé“¾æ¥
   * @param {MNNote} noteA - ç¬¬ä¸€å¼ å¡ç‰‡
   * @param {MNNote} noteB - ç¬¬äºŒå¼ å¡ç‰‡
   * @returns {boolean} - æ˜¯å¦äº’ä¸ºæœ€åä¸€æ¡è¯„è®ºé“¾æ¥
   */
  static checkMutualLastCommentLinks(noteA, noteB) {
    try {
      // è·å–ä¸¤å¼ å¡ç‰‡çš„è¯„è®º
      let commentsA = noteA.MNComments;
      let commentsB = noteB.MNComments;
      
      // æ£€æŸ¥ä¸¤å¼ å¡ç‰‡æ˜¯å¦éƒ½æœ‰è¯„è®º
      if (commentsA.length === 0 || commentsB.length === 0) {
        return false;
      }
      
      // è·å–æœ€åä¸€æ¡è¯„è®º
      let lastCommentA = commentsA[commentsA.length - 1];
      let lastCommentB = commentsB[commentsB.length - 1];
      
      // æ£€æŸ¥æœ€åä¸€æ¡è¯„è®ºæ˜¯å¦éƒ½æ˜¯é“¾æ¥ç±»å‹
      if (lastCommentA.type !== "linkComment" || lastCommentB.type !== "linkComment") {
        return false;
      }
      
      // æå–é“¾æ¥çš„ç›®æ ‡ID
      let linkIdFromA = lastCommentA.text.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
      let linkIdFromB = lastCommentB.text.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
      
      // æ£€æŸ¥æ˜¯å¦äº’ç›¸é“¾æ¥
      return linkIdFromA === noteB.noteId && linkIdFromB === noteA.noteId;
      
    } catch (error) {
      MNUtil.log(`checkMutualLastCommentLinks error: ${error}`);
      return false;
    }
  }

  /**
   * æ™ºèƒ½é“¾æ¥æ’åˆ—
   * 
   * è‡ªåŠ¨è¯†åˆ«æ‰‹åŠ¨åˆ›å»ºçš„åŒå‘é“¾æ¥å¹¶æ ¹æ®å¡ç‰‡ç±»å‹ç§»åŠ¨åˆ°ç›¸åº”å­—æ®µ
   * 
   * æ”¯æŒä¸¤ç§åœºæ™¯ï¼š
   * 1. å½’ç±»å¡ç‰‡ä¸çŸ¥è¯†ç‚¹å¡ç‰‡ï¼šå°†é“¾æ¥ç§»åŠ¨åˆ°"ç›¸å…³é“¾æ¥"ï¼ˆçŸ¥è¯†ç‚¹å¡ç‰‡ï¼‰å’Œ"æ‰€å±"ï¼ˆå½’ç±»å¡ç‰‡ï¼‰
   * 2. å®šä¹‰å¡ç‰‡ä¹‹é—´ï¼šåœ¨"ç›¸å…³æ€è€ƒ"å­—æ®µä¸‹å…ˆæ·»åŠ  "- " å†ç§»åŠ¨é“¾æ¥
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   * @returns {boolean} - æ˜¯å¦æˆåŠŸå¤„ç†
   */
  static smartLinkArrangement(note) {
    try {
      // è·å–å¡ç‰‡è¯„è®º
      let comments = note.MNComments;
      
      // æ£€æŸ¥æœ€åä¸€æ¡è¯„è®ºæ˜¯å¦æ˜¯é“¾æ¥
      if (comments.length === 0) {
        MNUtil.showHUD("å¡ç‰‡æ²¡æœ‰è¯„è®º");
        return false;
      }
      
      let lastComment = comments[comments.length - 1];
      if (lastComment.type !== "linkComment") {
        MNUtil.showHUD("æœ€åä¸€æ¡è¯„è®ºä¸æ˜¯é“¾æ¥");
        return false;
      }
      
      // è·å–é“¾æ¥çš„ç›®æ ‡å¡ç‰‡
      let targetNoteId = lastComment.text.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
      if (!targetNoteId) {
        MNUtil.showHUD("æ— æ³•è§£æé“¾æ¥ ID");
        return false;
      }
      
      let targetNote = MNNote.new(targetNoteId, false);
      if (!targetNote) {
        MNUtil.showHUD("æ‰¾ä¸åˆ°é“¾æ¥çš„ç›®æ ‡å¡ç‰‡");
        return false;
      }
      
      // åˆ¤æ–­æ˜¯å¦æ˜¯åŒå‘é“¾æ¥
      let isBidirectional = false;
      if (note.LinkIfDouble) {
        // å¦‚æœæœ‰ LinkIfDouble æ–¹æ³•ï¼Œç›´æ¥ä½¿ç”¨
        isBidirectional = note.LinkIfDouble(lastComment.text);
      } else {
        // å¦åˆ™æ‰‹åŠ¨æ£€æŸ¥
        let targetHasLinkBack = targetNote.MNComments.some(comment => {
          if (comment && comment.type === "linkComment") {
            let linkId = comment.text.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
            return linkId === note.noteId;
          }
          return false;
        });
        isBidirectional = targetHasLinkBack;
      }
      
      if (!isBidirectional) {
        MNUtil.showHUD("è¿™ä¸æ˜¯åŒå‘é“¾æ¥");
        return false;
      }
      
      // è·å–ä¸¤ä¸ªå¡ç‰‡çš„ç±»å‹
      let noteType = this.getNoteType(note);
      let targetNoteType = this.getNoteType(targetNote);
      
      // MNUtil.log(`æ™ºèƒ½é“¾æ¥æ’åˆ—ï¼š${noteType} <-> ${targetNoteType}`);
      
      // åœºæ™¯1ï¼šå½’ç±»å¡ç‰‡ä¸çŸ¥è¯†ç‚¹å¡ç‰‡ï¼ˆä¸åŒ…æ‹¬å®šä¹‰å¡ç‰‡ï¼‰
      if (noteType === "å½’ç±»" && !["å½’ç±»"].includes(targetNoteType) && targetNoteType !== "å®šä¹‰") {
        // note æ˜¯å½’ç±»å¡ç‰‡ï¼ŒtargetNote æ˜¯çŸ¥è¯†ç‚¹å¡ç‰‡
        // çŸ¥è¯†ç‚¹å¡ç‰‡çš„é“¾æ¥ç§»åŠ¨åˆ°"ç›¸å…³é“¾æ¥"
        let targetLinkIndex = targetNote.MNComments.findIndex(comment => {
          if (comment && comment.type === "linkComment") {
            let linkId = comment.text.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
            return linkId === note.noteId;
          }
          return false;
        });
        
        if (targetLinkIndex !== -1) {
          this.moveCommentsArrToField(targetNote, [targetLinkIndex], "ç›¸å…³é“¾æ¥", true);
        }
        
        // å½’ç±»å¡ç‰‡çš„é“¾æ¥å·²ç»åœ¨æœ€åï¼Œé»˜è®¤å°±åœ¨"æ‰€å±"å­—æ®µä¸‹ï¼Œä¸éœ€è¦ç§»åŠ¨
        // MNUtil.showHUD("å·²å°†çŸ¥è¯†ç‚¹å¡ç‰‡ä¸­çš„é“¾æ¥ç§»åŠ¨åˆ°\"ç›¸å…³é“¾æ¥\"å­—æ®µ");
        MNUtil.undoGrouping(() => {
          targetNote.refresh();
        });
        return true;
        
      } else if (!["å½’ç±»"].includes(noteType) && noteType !== "å®šä¹‰" && targetNoteType === "å½’ç±»") {
        // note æ˜¯çŸ¥è¯†ç‚¹å¡ç‰‡ï¼ŒtargetNote æ˜¯å½’ç±»å¡ç‰‡
        // çŸ¥è¯†ç‚¹å¡ç‰‡çš„é“¾æ¥ç§»åŠ¨åˆ°"ç›¸å…³é“¾æ¥"
        let linkIndex = comments.length - 1;
        this.moveCommentsArrToField(note, [linkIndex], "ç›¸å…³é“¾æ¥", true);
        
        // å½’ç±»å¡ç‰‡çš„é“¾æ¥ä¿æŒåœ¨æœ€åï¼ˆ"æ‰€å±"å­—æ®µä¸‹ï¼‰
        // MNUtil.showHUD("å·²å°†é“¾æ¥ç§»åŠ¨åˆ°\"ç›¸å…³é“¾æ¥\"å­—æ®µ");
        MNUtil.undoGrouping(() => {
          note.refresh();
        });
        return true;
        
      } else if (noteType === "å®šä¹‰" && targetNoteType === "å®šä¹‰") {
        // åœºæ™¯2ï¼šå®šä¹‰å¡ç‰‡ä¹‹é—´çš„é“¾æ¥
        // æ£€æŸ¥æ˜¯å¦äº’ä¸ºæœ€åä¸€æ¡è¯„è®ºé“¾æ¥
        if (!this.checkMutualLastCommentLinks(note, targetNote)) {
          MNUtil.showHUD("ä¸æ»¡è¶³äº’ä¸ºæœ€åä¸€æ¡è¯„è®ºé“¾æ¥çš„æ¡ä»¶");
          return false;
        }
        
        // ä¸¤ä¸ªå®šä¹‰å¡ç‰‡éƒ½éœ€è¦å¤„ç†
        
        // å¤„ç†å½“å‰å¡ç‰‡
        note.appendMarkdownComment("- ");
        this.moveCommentsArrToField(note, [note.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
        this.moveCommentsArrToField(note, [note.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
        
        // å¤„ç†ç›®æ ‡å¡ç‰‡
        let targetLinkIndex = targetNote.MNComments.findIndex(comment => {
          if (comment && comment.type === "linkComment") {
            let linkId = comment.text.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
            return linkId === note.noteId;
          }
          return false;
        });
        
        if (targetLinkIndex !== -1) {
          targetNote.appendMarkdownComment("- ");
          this.moveCommentsArrToField(targetNote, [targetNote.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
          this.moveCommentsArrToField(targetNote, [targetNote.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
        }
        
        // MNUtil.showHUD("å·²å°†ä¸¤ä¸ªå®šä¹‰å¡ç‰‡çš„é“¾æ¥ç§»åŠ¨åˆ°\"ç›¸å…³æ€è€ƒ\"å­—æ®µ");
        MNUtil.undoGrouping(() => {
          note.refresh();
          targetNote.refresh();
        });
        return true;
        
      } else if ((noteType === "å®šä¹‰" && targetNoteType === "å½’ç±»") || (noteType === "å½’ç±»" && targetNoteType === "å®šä¹‰")) {
        // åœºæ™¯4ï¼šå®šä¹‰å¡ç‰‡ä¸å½’ç±»å¡ç‰‡çš„åŒå‘é“¾æ¥
        if (noteType === "å®šä¹‰") {
          // note æ˜¯å®šä¹‰å¡ç‰‡ï¼ŒtargetNote æ˜¯å½’ç±»å¡ç‰‡
          // å½’ç±»å¡ç‰‡ä¸­çš„é“¾æ¥ç§»åŠ¨åˆ°"æ‰€å±"å­—æ®µ
          let targetLinkIndex = targetNote.MNComments.findIndex(comment => {
            if (comment.type === "linkComment") {
              let linkId = comment.text.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
              return linkId === note.noteId;
            }
            return false;
          });
          
          if (targetLinkIndex !== -1) {
            this.moveCommentsArrToField(targetNote, [targetLinkIndex], "æ‰€å±", true);
          }
          
          // å®šä¹‰å¡ç‰‡çš„é“¾æ¥ä¿æŒåœ¨æœ€å
          
        } else {
          // note æ˜¯å½’ç±»å¡ç‰‡ï¼ŒtargetNote æ˜¯å®šä¹‰å¡ç‰‡
          // å½’ç±»å¡ç‰‡ä¸­çš„é“¾æ¥ç§»åŠ¨åˆ°"æ‰€å±"å­—æ®µ
          let linkIndex = comments.length - 1;
          this.moveCommentsArrToField(note, [linkIndex], "æ‰€å±", true);
          
          // å®šä¹‰å¡ç‰‡çš„é“¾æ¥ä¿æŒåœ¨æœ€å
        }
        
        MNUtil.undoGrouping(() => {
          note.refresh();
          targetNote.refresh();
        });
        return true;
        
      } else if (noteType === "å½’ç±»" && targetNoteType === "å½’ç±»") {
        // åœºæ™¯3ï¼šå½’ç±»å¡ç‰‡ä¹‹é—´çš„é“¾æ¥
        // ä¸¤ä¸ªå½’ç±»å¡ç‰‡éƒ½éœ€è¦å¤„ç†
        
        // å¤„ç†å½“å‰å¡ç‰‡
        note.appendMarkdownComment("- ");
        this.moveCommentsArrToField(note, [note.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
        this.moveCommentsArrToField(note, [note.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
        
        // å¤„ç†ç›®æ ‡å¡ç‰‡
        let targetLinkIndex = targetNote.MNComments.findIndex(comment => {
          if (comment && comment.type === "linkComment") {
            let linkId = comment.text.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
            return linkId === note.noteId;
          }
          return false;
        });
        
        if (targetLinkIndex !== -1) {
          targetNote.appendMarkdownComment("- ");
          this.moveCommentsArrToField(targetNote, [targetNote.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
          this.moveCommentsArrToField(targetNote, [targetNote.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
        }
        
        MNUtil.undoGrouping(()=>{
          note.refresh();
          targetNote.refresh();
        })
        return true;
        
      } else if (
        ["å‘½é¢˜", "ä¾‹å­", "åä¾‹"].includes(noteType) && 
        ["å‘½é¢˜", "ä¾‹å­", "åä¾‹"].includes(targetNoteType)
      ) {
        // åœºæ™¯5ï¼šå‘½é¢˜ã€ä¾‹å­ã€åä¾‹ä¹‹é—´çš„é“¾æ¥
        // æ£€æŸ¥æ˜¯å¦äº’ä¸ºæœ€åä¸€æ¡è¯„è®ºé“¾æ¥
        if (!this.checkMutualLastCommentLinks(note, targetNote)) {
          MNUtil.showHUD("ä¸æ»¡è¶³äº’ä¸ºæœ€åä¸€æ¡è¯„è®ºé“¾æ¥çš„æ¡ä»¶");
          return false;
        }
        
        // ä¸¤ä¸ªå¡ç‰‡éƒ½éœ€è¦å¤„ç†ï¼Œç±»ä¼¼å®šä¹‰å¡ç‰‡ä¹‹é—´çš„å¤„ç†
        
        // å¤„ç†å½“å‰å¡ç‰‡
        note.appendMarkdownComment("- ");
        this.moveCommentsArrToField(note, [note.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
        this.moveCommentsArrToField(note, [note.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
        
        // å¤„ç†ç›®æ ‡å¡ç‰‡
        let targetLinkIndex = targetNote.MNComments.findIndex(comment => {
          if (comment && comment.type === "linkComment") {
            let linkId = comment.text.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
            return linkId === note.noteId;
          }
          return false;
        });
        
        if (targetLinkIndex !== -1) {
          targetNote.appendMarkdownComment("- ");
          this.moveCommentsArrToField(targetNote, [targetNote.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
          this.moveCommentsArrToField(targetNote, [targetNote.MNComments.length - 1], "ç›¸å…³æ€è€ƒ");
        }
        
        MNUtil.undoGrouping(() => {
          note.refresh();
          targetNote.refresh();
        });
        return true;
        
      } else {
        MNUtil.showHUD(`ä¸æ”¯æŒçš„å¡ç‰‡ç±»å‹ç»„åˆï¼š${noteType} <-> ${targetNoteType}`);
        return false;
      }
      
    } catch (error) {
      MNUtil.addErrorLog(error, "smartLinkArrangement", {
        noteId: note?.noteId,
        noteTitle: note?.noteTitle
      });
      MNUtil.showHUD("å¤„ç†é“¾æ¥æ—¶å‡ºé”™ï¼š" + error.message);
      return false;
    }
  }

  /**
   * åˆ·æ–°å¡ç‰‡
   */
  static refreshNote(note) {
    note.note.appendMarkdownComment("")
    note.note.removeCommentByIndex(note.note.comments.length-1)
  }
  static refreshNotes(note) {
    // if (note.descendantNodes.descendant.length > 0) {
    //   note.descendantNodes.descendant.forEach(descendantNote => {
    //     this.refreshNote(descendantNote)
    //   })
    // }
    // if (note.ancestorNodes.length > 0) {
    //   note.ancestorNodes.forEach(ancestorNote => {
    //     this.refreshNote(ancestorNote)
    //   })
    // }
    if (note.parentNote) {
      this.refreshNote(note.parentNote)
    }

    this.refreshNote(note) // åˆ·æ–°å½“å‰å¡ç‰‡

    // åˆ·æ–°æ‰€æœ‰å­å¡ç‰‡ï¼Œä¸éœ€è¦å­™å¡ç‰‡
    if (note.childNotes.length > 0) {
      note.childNotes.forEach(childNote => {
        this.refreshNote(childNote)
      })
    }
    
    // åˆ·æ–°å½“å‰å¡ç‰‡é“¾æ¥åˆ°çš„å…¶ä»–å¡ç‰‡
    // è¿™æ ·å¯ä»¥ç¡®ä¿åŒå‘é“¾æ¥çš„å¡ç‰‡éƒ½èƒ½æ˜¾ç¤ºæ­£ç¡®çš„æ–°æ ‡é¢˜
    if (note.MNComments && note.MNComments.length > 0) {
      note.MNComments.forEach(comment => {
        if (comment && comment.type === "linkComment") {
          try {
            // ç›´æ¥ä½¿ç”¨ URL è·å–é“¾æ¥çš„å¡ç‰‡
            const linkedNote = MNNote.new(comment.text);
            if (linkedNote) {
              this.refreshNote(linkedNote);
            }
          } catch (error) {
            // å¿½ç•¥æ— æ³•åˆ·æ–°çš„é“¾æ¥å¡ç‰‡
          }
        }
      });
    }
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºæ—§æ¨¡æ¿å¡ç‰‡
   * åˆ¤æ–­æ ‡å‡†ï¼šå­˜åœ¨ "Remark" çš„ HtmlComment
   * 
   * @param {MNNote} note - è¦åˆ¤æ–­çš„å¡ç‰‡
   * @returns {boolean} æ˜¯å¦ä¸ºæ—§æ¨¡æ¿å¡ç‰‡
   */
  static isOldTemplateCard(note) {
    let commentsObj = this.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    let htmlCommentsTextArr = commentsObj.htmlCommentsTextArr;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ "Remark" å­—æ®µ
    if (htmlCommentsTextArr.some(text => text.includes("Remark"))) {
      return true;
    }

    // è‹¥åŒæ—¶å­˜åœ¨ â€œè¯æ˜â€ å’Œ â€œæ‰€å±â€ å­—æ®µ
    if (
      htmlCommentsTextArr.some(text => text.includes("è¯æ˜")) &&
      htmlCommentsTextArr.some(text => text.includes("æ‰€å±"))
    ) {
      return true;
    }

    
    // æ£€æŸ¥"åº”ç”¨"å­—æ®µæ˜¯å¦å­˜åœ¨ä¸”ä¸åœ¨æœ€å
    for (let i = 0; i < htmlCommentsObjArr.length; i++) {
      let fieldObj = htmlCommentsObjArr[i];
      if (fieldObj.text.includes("åº”ç”¨")) {
        // å¦‚æœæ‰¾åˆ°"åº”ç”¨"å­—æ®µä¸”ä¸æ˜¯æœ€åä¸€ä¸ªå­—æ®µï¼Œåˆ™è®¤ä¸ºæ˜¯æ—§å¡ç‰‡
        if (i < htmlCommentsObjArr.length - 1) {
          return true;
        }
        break;
      }
    }
    
    return false;
  }

  /**
   * å¤„ç†æ—§æ¨¡æ¿å¡ç‰‡
   * - ä½¿ç”¨ clone æŠ€å·§æå–æ‰‹å†™å’Œå›¾ç‰‡
   * - æ¯å¼ å›¾ç‰‡å•ç‹¬ä¸€å¼ å¡
   * - æ‰‹å†™å†…å®¹å•ç‹¬ä¸€å¼ å¡
   * - åº”ç”¨å­—æ®µå†…å®¹å•ç‹¬ä¸€å¼ å¡
   * - å…¶ä½™å†…å®¹ä¸€å¼ å¡
   * 
   * @param {MNNote} oldNote - è¦å¤„ç†çš„æ—§æ¨¡æ¿å¡ç‰‡
   */
  static processOldTemplateCard(oldNote) {
    let note = this.toNoExcerptVersion(oldNote) // å…ˆè½¬ä¸ºéæ‘˜å½•æ¨¡å¼
    this.removeUnnecessaryComments(note)
    note.convertLinksToNewVersion()
    note.cleanupBrokenLinks()
    note.fixMergeProblematicLinks()
    // ä½¿ç”¨ MNComments è·å–æ›´ç²¾å‡†çš„ç±»å‹
    let MNComments = note.MNComments;
    let excerptBlockIndexArr = this.getExcerptBlockIndexArr(note)
    let startIndex = 0
    if (excerptBlockIndexArr && excerptBlockIndexArr.length > 0) {
      startIndex = excerptBlockIndexArr[excerptBlockIndexArr.length-1]!==-1?excerptBlockIndexArr[excerptBlockIndexArr.length-1] + 1:0;
    }
    
    // åˆ†ç±»æ”¶é›†ä¸åŒç±»å‹å†…å®¹çš„ç´¢å¼•
    let handwritingIndices = [];  // æ‰‹å†™å†…å®¹ç´¢å¼•
    let imageIndices = [];  // å›¾ç‰‡ç´¢å¼•ï¼ˆæ¯ä¸ªå…ƒç´ ä»£è¡¨ä¸€å¼ å›¾ç‰‡ï¼‰
    let applicationFieldIndices = [];  // åº”ç”¨å­—æ®µç›¸å…³å†…å®¹ç´¢å¼•
    let otherContentIndices = [];  // å…¶ä»–æ–‡æœ¬å†…å®¹ç´¢å¼•
    let htmlFieldIndices = [];  // HTMLå­—æ®µæ ‡è®°ç´¢å¼•
    
    // å­—æ®µå†…å®¹æ˜ å°„
    let fieldContents = {};  // { fieldName: { indices: [], texts: [], links: [] } }
    let currentField = null;
    
    // éå†æ‰€æœ‰è¯„è®ºè¿›è¡Œåˆ†ç±»
    for (let i = startIndex; i < MNComments.length; i++) {
      let mnComment = MNComments[i];
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯ HtmlCommentï¼ˆå­—æ®µæ ‡è®°ï¼‰
      if (mnComment.type === "HtmlComment") {
        currentField = mnComment.text.trim();
        htmlFieldIndices.push(i);
        if (!fieldContents[currentField]) {
          fieldContents[currentField] = { indices: [], texts: [], links: [] };
        }
        continue;
      }
      
      // åˆ†ç±»å¤„ç†ä¸åŒç±»å‹çš„è¯„è®º
      if (mnComment.type === "drawingComment" || 
          mnComment.type === "imageCommentWithDrawing" || 
          mnComment.type === "mergedImageCommentWithDrawing") {
        // æ‰‹å†™å†…å®¹
        handwritingIndices.push(i);
      } else if (mnComment.type === "imageComment" || 
                 mnComment.type === "mergedImageComment") {
        // çº¯å›¾ç‰‡å†…å®¹ï¼ˆæ¯å¼ å›¾ç‰‡å•ç‹¬è®°å½•ï¼‰
        imageIndices.push(i);
      } else if (currentField && currentField.includes("åº”ç”¨")) {
        // åº”ç”¨å­—æ®µçš„å†…å®¹
        applicationFieldIndices.push(i);
        fieldContents[currentField].indices.push(i);
        
        // è®°å½•å†…å®¹
        if (mnComment.type === "linkComment" || mnComment.type === "summaryComment") {
          fieldContents[currentField].links.push(mnComment.text);
        } else if (mnComment.type === "textComment" || 
                   mnComment.type === "markdownComment" || 
                   mnComment.type === "mergedTextComment" ||
                   mnComment.type === "tagComment") {
          fieldContents[currentField].texts.push(mnComment.text);
        }
      } else if (currentField) {
        // å…¶ä»–å­—æ®µçš„å†…å®¹
        otherContentIndices.push(i);
        fieldContents[currentField].indices.push(i);
        
        // è®°å½•å†…å®¹
        if (mnComment.type === "linkComment" || mnComment.type === "summaryComment") {
          fieldContents[currentField].links.push(mnComment.text);
        } else if (mnComment.type === "textComment" || 
                   mnComment.type === "markdownComment" || 
                   mnComment.type === "mergedTextComment" ||
                   mnComment.type === "tagComment") {
          fieldContents[currentField].texts.push(mnComment.text);
        }
      }
    }
    
    // åˆ›å»ºçš„æ‰€æœ‰å­å¡ç‰‡
    let createdChildNotes = [];
    
    MNUtil.undoGrouping(() => {
      // 1. ä¸ºæ‰‹å†™å†…å®¹åˆ›å»ºç‹¬ç«‹å¡ç‰‡
      if (handwritingIndices.length > 0) {
        try {
          let clonedNote = note.clone();
          clonedNote.title = "";
          
          // åˆ é™¤å…‹éš†å¡ç‰‡çš„æ‰€æœ‰å­å¡ç‰‡
          if (clonedNote.childNotes && clonedNote.childNotes.length > 0) {
            for (let i = clonedNote.childNotes.length - 1; i >= 0; i--) {
              clonedNote.childNotes[i].removeFromParent();
            }
          }
          
          // è®¡ç®—éœ€è¦åˆ é™¤çš„ç´¢å¼•ï¼ˆä¿ç•™æ‰‹å†™å†…å®¹ï¼‰
          let allIndices = Array.from({length: clonedNote.comments.length}, (_, i) => i);
          let indicesToDelete = allIndices.filter(i => !handwritingIndices.includes(i));
          indicesToDelete.sort((a, b) => b - a);
          
          // åˆ é™¤éæ‰‹å†™å†…å®¹
          clonedNote.removeCommentsByIndexArr(indicesToDelete);
          
          // æ·»åŠ ä¸ºå­å¡ç‰‡
          note.addChild(clonedNote);
          createdChildNotes.push(clonedNote);
          clonedNote.refresh();
        } catch (error) {
          MNUtil.showHUD("åˆ›å»ºæ‰‹å†™å¡ç‰‡å¤±è´¥: " + error.message);
        }
      }
      
      // 2. ä¸ºæ¯å¼ å›¾ç‰‡åˆ›å»ºç‹¬ç«‹å¡ç‰‡
      imageIndices.forEach((imageIndex, idx) => {
        try {
          let clonedNote = note.clone();
          clonedNote.title = "";
          
          // åˆ é™¤å…‹éš†å¡ç‰‡çš„æ‰€æœ‰å­å¡ç‰‡
          if (clonedNote.childNotes && clonedNote.childNotes.length > 0) {
            for (let i = clonedNote.childNotes.length - 1; i >= 0; i--) {
              clonedNote.childNotes[i].removeFromParent();
            }
          }
          
          // è®¡ç®—éœ€è¦åˆ é™¤çš„ç´¢å¼•ï¼ˆåªä¿ç•™å½“å‰å›¾ç‰‡ï¼‰
          let allIndices = Array.from({length: clonedNote.comments.length}, (_, i) => i);
          let indicesToDelete = allIndices.filter(i => i !== imageIndex);
          indicesToDelete.sort((a, b) => b - a);
          
          // åˆ é™¤å…¶ä»–å†…å®¹
          clonedNote.removeCommentsByIndexArr(indicesToDelete);
          
          // æ·»åŠ ä¸ºå­å¡ç‰‡
          note.addChild(clonedNote);
          createdChildNotes.push(clonedNote);
          clonedNote.refresh();
        } catch (error) {
          MNUtil.showHUD(`åˆ›å»ºå›¾ç‰‡å¡ç‰‡ ${idx + 1} å¤±è´¥: ` + error.message);
        }
      });
      
      // 3. ä¸ºåº”ç”¨å­—æ®µå†…å®¹åˆ›å»ºç‹¬ç«‹å¡ç‰‡
      if (applicationFieldIndices.length > 0) {
        try {
          let clonedNote = note.clone();
          clonedNote.title = "";
          
          // åˆ é™¤å…‹éš†å¡ç‰‡çš„æ‰€æœ‰å­å¡ç‰‡
          if (clonedNote.childNotes && clonedNote.childNotes.length > 0) {
            for (let i = clonedNote.childNotes.length - 1; i >= 0; i--) {
              clonedNote.childNotes[i].removeFromParent();
            }
          }
          
          // è®¡ç®—éœ€è¦åˆ é™¤çš„ç´¢å¼•ï¼ˆä¿ç•™åº”ç”¨å­—æ®µå†…å®¹ï¼‰
          let allIndices = Array.from({length: clonedNote.comments.length}, (_, i) => i);
          let indicesToDelete = allIndices.filter(i => !applicationFieldIndices.includes(i));
          indicesToDelete.sort((a, b) => b - a);
          
          // åˆ é™¤å…¶ä»–å†…å®¹
          clonedNote.removeCommentsByIndexArr(indicesToDelete);
          
          // æ·»åŠ ä¸ºå­å¡ç‰‡
          note.addChild(clonedNote);
          createdChildNotes.push(clonedNote);
          clonedNote.refresh();
        } catch (error) {
          MNUtil.showHUD("åˆ›å»ºåº”ç”¨å­—æ®µå¡ç‰‡å¤±è´¥: " + error.message);
        }
      }
      
      // 4. ä¸ºå…¶ä»–æ–‡æœ¬å†…å®¹åˆ›å»ºå¡ç‰‡
      if (otherContentIndices.length > 0) {
        // æ£€æŸ¥æ˜¯å¦æœ‰å®é™…å†…å®¹ï¼ˆä¸åªæ˜¯HTMLå­—æ®µæ ‡è®°ï¼‰
        let hasActualContent = Object.keys(fieldContents).some(fieldName => {
          if (fieldName && fieldName.includes("åº”ç”¨")) return false;  // è·³è¿‡åº”ç”¨å­—æ®µ
          let field = fieldContents[fieldName];
          return field.texts.length > 0 || field.links.length > 0;
        });
        
        if (hasActualContent) {
          let config = {
            title: "",
            content: "",
            markdown: true,
            color: note.colorIndex
          };
          let textCard = note.createChildNote(config);
          
          // æŒ‰å­—æ®µæ·»åŠ å†…å®¹
          Object.keys(fieldContents).forEach(fieldName => {
            if (fieldName && fieldName.includes("åº”ç”¨")) return;  // è·³è¿‡åº”ç”¨å­—æ®µ
            
            let field = fieldContents[fieldName];
            if (field.texts.length > 0 || field.links.length > 0) {
              // æ·»åŠ å­—æ®µæ ‡é¢˜
              textCard.appendMarkdownComment(`- ${fieldName}`);
              
              // æ·»åŠ æ–‡æœ¬
              field.texts.forEach(text => {
                textCard.appendMarkdownComment(text);
              });
              
              // æ·»åŠ é“¾æ¥
              field.links.forEach(link => {
                textCard.appendTextComment(link);
              });
            }
          });
          
          createdChildNotes.push(textCard);
          textCard.refresh();
        }
      }
      
      // 5. æ¸…ç†åŸå¡ç‰‡ï¼šåˆ é™¤æ‰€æœ‰å·²å¤„ç†çš„è¯„è®º
      let allProcessedIndices = [
        ...handwritingIndices,
        ...imageIndices,
        ...applicationFieldIndices,
        ...otherContentIndices,
        ...htmlFieldIndices
      ];
      
      // å»é‡å¹¶æ’åº
      allProcessedIndices = [...new Set(allProcessedIndices)].sort((a, b) => b - a);
      
      // åˆ é™¤å·²å¤„ç†çš„è¯„è®º
      if (allProcessedIndices.length > 0) {
        note.removeCommentsByIndexArr(allProcessedIndices);
      }
      
      // åˆ·æ–°åŸå¡ç‰‡
      note.refresh();
    });
    
    // // æ˜¾ç¤ºå¤„ç†ç»“æœ
    // if (createdChildNotes.length > 0) {
    //   MNUtil.showHUD(`âœ… æˆåŠŸå¤„ç†æ—§æ¨¡æ¿å¡ç‰‡ï¼Œåˆ›å»ºäº† ${createdChildNotes.length} å¼ å­å¡ç‰‡`);
    // }

    return note
  }

  static renewLinks(note) {
    note.convertLinksToNewVersion()
    note.cleanupBrokenLinks()
    note.fixMergeProblematicLinks()
  }
  /**
   * å¤„ç†æ—§å¡ç‰‡
   */
  static renewNote(note) {
    // KnowledgeBaseUtils.log("å¼€å§‹æ‰§è¡Œ renewNote", "renewNote", {
    //   noteId: note.noteId,
    //   noteTitle: note.noteTitle,
    //   isOldTemplate: this.isOldTemplateCard(note)
    // })

    // é¦–å…ˆåˆ¤æ–­å¹¶å¤„ç†æ—§æ¨¡æ¿å¡ç‰‡
    if (this.isOldTemplateCard(note)) {
      let newNote = this.processOldTemplateCard(note);
      this.changeTitle(newNote)
      // KnowledgeBaseUtils.log("å®Œæˆå¤„ç†æ—§æ¨¡æ¿å¡ç‰‡", "renewNote", {
      //   step: "processOldTemplateCard",
      //   newNoteId: newNote.noteId
      // })
      return newNote
    }

    let newNote = this.toNoExcerptVersion(note)
    // KnowledgeBaseUtils.log("å®Œæˆ toNoExcerptVersion â­", "renewNote", {
    //   step: "toNoExcerptVersion",
    //   newNoteId: newNote.noteId,
    //   commentsCount: newNote.comments.length
    // })

    // å¤„ç†é“¾æ¥ç›¸å…³é—®é¢˜
    // this.convertLinksToNewVersion(note)
    // this.cleanupBrokenLinks(note)
    // this.fixMergeProblematicLinks(note)
    // note.convertLinksToNewVersion()
    // note.cleanupBrokenLinks()
    // note.fixMergeProblematicLinks()
    this.renewLinks(newNote)
    // KnowledgeBaseUtils.log("å®Œæˆ renewLinks â­", "renewNote", {
    //   step: "renewLinks",
    //   noteId: newNote.noteId
    // })

    // å¤„ç†ç©ºçš„"å…³é”®è¯ï¼š"å­—æ®µ
    this.processEmptyKeywordField(newNote)
    // KnowledgeBaseUtils.log("å®Œæˆ processEmptyKeywordField", "renewNote", {
    //   step: "processEmptyKeywordField",
    //   noteId: newNote.noteId
    // })

    // å¤„ç†ä¸åŒç±»å‹è½¬æ¢æ—¶çš„ç¬¬ä¸€ä¸ªå­—æ®µæ›¿æ¢
    this.replaceFirstFieldIfNeeded(newNote)
    // KnowledgeBaseUtils.log("å®Œæˆ replaceFirstFieldIfNeeded", "renewNote", {
    //   step: "replaceFirstFieldIfNeeded",
    //   noteId: newNote.noteId
    // })

    // å»æ‰ä¸€äº›è¯„è®ºï¼Œæ¯”å¦‚"- "
    this.removeUnnecessaryComments(newNote)
    // KnowledgeBaseUtils.log("å®Œæˆ removeUnnecessaryComments", "renewNote", {
    //   step: "removeUnnecessaryComments",
    //   noteId: newNote.noteId
    // })

    // æ£€æµ‹æ˜¯å¦åŒ…å«"åº”ç”¨"å­—æ®µï¼Œä½†"åº”ç”¨"å­—æ®µä¸æ˜¯æœ€åä¸€ä¸ªå­—æ®µï¼Œå¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªå­—æ®µï¼Œåˆ™å°†å…¶ç§»åŠ¨åˆ°æœ€å
    this.moveApplicationFieldToEnd(newNote)
    // KnowledgeBaseUtils.log("å®Œæˆ moveApplicationFieldToEnd", "renewNote", {
    //   step: "moveApplicationFieldToEnd",
    //   noteId: newNote.noteId
    // })

    switch (this.getNoteType(newNote)) {
      case "å½’ç±»":
        /**
         * å»æ‰å½’ç±»å¡ç‰‡çš„æ ‡é¢˜ä¸­çš„"xx"ï¼š"yy" é‡Œçš„ xx
         */
        let titleParts = this.parseNoteTitle(newNote);
        if (/^"[^"]*"ï¼š"[^"]*"\s*ç›¸å…³[^"]*$/.test(newNote.title)) {
          newNote.title = `"${titleParts.content}"ç›¸å…³${titleParts.type}`;
        }
        // KnowledgeBaseUtils.log("å®Œæˆå½’ç±»å¡ç‰‡æ ‡é¢˜å¤„ç†", "renewNote", {
        //   step: "classificationTitleProcessing",
        //   noteId: newNote.noteId,
        //   newTitle: newNote.title
        // })
        break;
      case "å®šä¹‰":
        this.moveRelatedConceptsToRelatedThoughts(newNote);
        // KnowledgeBaseUtils.log("å®Œæˆ moveRelatedConceptsToRelatedThoughts", "renewNote", {
        //   step: "moveRelatedConceptsToRelatedThoughts",
        //   noteId: newNote.noteId
        // })
        break;
    }

    // KnowledgeBaseUtils.log("renewNote æ‰§è¡Œå®Œæˆ", "renewNote", {
    //   noteId: newNote.noteId,
    //   finalCommentsCount: newNote.comments.length
    // })

    return newNote
  }

  static moveApplicationFieldToEnd(note) {
    let commentsObj = this.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    let applicationFieldObj = null;
    let applicationFieldIndex = -1;
    for (let i = 0; i < htmlCommentsObjArr.length; i++) {
      let fieldObj = htmlCommentsObjArr[i];
      if (fieldObj.text.includes("åº”ç”¨")) {
        applicationFieldObj = fieldObj;
        applicationFieldIndex = i;
        break;
      }
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°"åº”ç”¨"å­—æ®µï¼Œç›´æ¥è¿”å›
    if (!applicationFieldObj) {
      return;
    }

    // æ£€æŸ¥"åº”ç”¨"å­—æ®µæ˜¯å¦å·²ç»æ˜¯æœ€åä¸€ä¸ªå­—æ®µ
    if (applicationFieldIndex === htmlCommentsObjArr.length - 1) {
      return; // å·²ç»æ˜¯æœ€åä¸€ä¸ªå­—æ®µï¼Œæ— éœ€ç§»åŠ¨
    }

    // è·å–"åº”ç”¨"å­—æ®µä¸‹çš„å†…å®¹ç´¢å¼•ï¼ˆä¸åŒ…æ‹¬å­—æ®µæœ¬èº«ï¼‰
    let contentIndices = applicationFieldObj.excludingFieldBlockIndexArr;

    // å¦‚æœè¯¥å­—æ®µä¸‹æ²¡æœ‰å†…å®¹ï¼Œåªç§»åŠ¨å­—æ®µæœ¬èº«
    if (contentIndices.length === 0) {
      note.moveComment(applicationFieldObj.index, note.comments.length - 1);
      return;
    }

    // å°†å­—æ®µå’Œå†…å®¹ä¸€èµ·ç§»åŠ¨åˆ°æœ€åï¼ˆä½¿ç”¨åŒ…å«å­—æ®µçš„ç´¢å¼•ï¼‰
    let fullBlockIndices = applicationFieldObj.includingFieldBlockIndexArr;
    this.moveCommentsArrToField(note, fullBlockIndices, null, true);
  }

  static removeUnnecessaryComments(note) {
    let comments = note.MNComments;
    let unnecessaryPatterns = [
      /^\s*-\s*$/, // ä»…åŒ…å«â€œ- â€çš„è¯„è®º
    ]
    MNUtil.undoGrouping(() => {
      for (let i = comments.length - 1; i >= 0; i--){
        let comment = comments[i];
        if (comment && 
          (comment.type === "textComment" || comment.type === "markdownComment")
        ) {
          let isUnnecessary = unnecessaryPatterns.some(pattern => pattern.test(comment.text));
          if (isUnnecessary) {
            note.removeCommentByIndex(i);
          }
        }
      }
    })
  }

  /**
   * å¤„ç†å®šä¹‰ç±»å¡ç‰‡çš„"ç›¸å…³æ¦‚å¿µï¼š"å­—æ®µ
   * å°†"ç›¸å…³æ¦‚å¿µï¼š"å­—æ®µä¸‹çš„å†…å®¹ç§»åŠ¨åˆ°"ç›¸å…³æ€è€ƒ"å­—æ®µä¸‹æ–¹ï¼Œå¹¶åˆ é™¤"ç›¸å…³æ¦‚å¿µï¼š"å­—æ®µ
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   */
  static moveRelatedConceptsToRelatedThoughts(note) {
    let commentsObj = this.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    
    // æŸ¥æ‰¾"ç›¸å…³æ¦‚å¿µï¼š"å­—æ®µï¼ˆä½¿ç”¨ä¸­æ–‡å¼•å·ï¼‰
    let relatedConceptsFieldObj = null;
    let relatedConceptsFieldIndex = -1;
    
    for (let i = 0; i < htmlCommentsObjArr.length; i++) {
      let fieldObj = htmlCommentsObjArr[i];
      if (fieldObj.text.includes("ç›¸å…³æ¦‚å¿µ")) {
        relatedConceptsFieldObj = fieldObj;
        relatedConceptsFieldIndex = i;
        break;
      }
    }
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°"ç›¸å…³æ¦‚å¿µï¼š"å­—æ®µï¼Œç›´æ¥è¿”å›
    if (!relatedConceptsFieldObj) {
      return;
    }
    
    // è·å–"ç›¸å…³æ¦‚å¿µï¼š"å­—æ®µä¸‹çš„å†…å®¹ç´¢å¼•ï¼ˆä¸åŒ…æ‹¬å­—æ®µæœ¬èº«ï¼‰
    let contentIndices = relatedConceptsFieldObj.excludingFieldBlockIndexArr;
    
    // å¦‚æœè¯¥å­—æ®µä¸‹æ²¡æœ‰å†…å®¹ï¼Œåªåˆ é™¤å­—æ®µæœ¬èº«
    if (contentIndices.length === 0) {
      note.removeCommentByIndex(relatedConceptsFieldObj.index);
      return;
    }
    
    // å°†å†…å®¹ç§»åŠ¨åˆ°"ç›¸å…³æ€è€ƒ"å­—æ®µä¸‹æ–¹
    this.moveCommentsArrToField(note, contentIndices, "ç›¸å…³æ€è€ƒ", true);
    
    // åˆ é™¤"ç›¸å…³æ¦‚å¿µï¼š"å­—æ®µæœ¬èº«
    // æ³¨æ„ï¼šç§»åŠ¨å†…å®¹åï¼ŒåŸå­—æ®µçš„ç´¢å¼•å¯èƒ½å·²ç»æ”¹å˜ï¼Œéœ€è¦é‡æ–°è®¡ç®—
    let updatedCommentsObj = this.parseNoteComments(note);
    let updatedHtmlCommentsObjArr = updatedCommentsObj.htmlCommentsObjArr;
    
    for (let fieldObj of updatedHtmlCommentsObjArr) {
      if (fieldObj.text.includes("ç›¸å…³æ¦‚å¿µï¼š")) {
        note.removeCommentByIndex(fieldObj.index);
        break;
      }
    }
    
    // MNUtil.log(`âœ… å·²å°†"ç›¸å…³æ¦‚å¿µï¼š"å­—æ®µä¸‹çš„ ${contentIndices.length} æ¡å†…å®¹ç§»åŠ¨åˆ°"ç›¸å…³æ€è€ƒ"å­—æ®µä¸‹æ–¹`);
  }

  /**
   * å¤„ç†ç©ºçš„"å…³é”®è¯ï¼š"å­—æ®µ
   * è¯†åˆ«å¹¶å¤„ç†"å…³é”®è¯ï¼š"å­—æ®µæ˜¯å¦ä¸ºç©ºï¼ˆå†’å·åæ²¡æœ‰ç©ºæ ¼æˆ–æ²¡æœ‰å…¶ä»–éç©ºæ ¼å†…å®¹ï¼‰
   * å¦‚æœæ˜¯ç©ºçš„ï¼Œåˆ™åˆ é™¤è¯¥å­—æ®µå¹¶ç”¨æ¨¡æ¿å¡ç‰‡çš„å†…å®¹æ›¿æ¢
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   */
  static processEmptyKeywordField(note) {
    let commentsObj = this.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    
    // æŸ¥æ‰¾"å…³é”®è¯ï¼š"å­—æ®µ
    let keywordFieldObj = null;
    
    for (let i = 0; i < htmlCommentsObjArr.length; i++) {
      let fieldObj = htmlCommentsObjArr[i];
      // æ£€æŸ¥æ˜¯å¦æ˜¯"å…³é”®è¯ï¼š"å­—æ®µï¼ˆæ”¯æŒä¸­è‹±æ–‡å†’å·ï¼‰
      if (/^å…³é”®è¯[:ï¼š]\s*$/.test(fieldObj.text.trim())) {
        keywordFieldObj = fieldObj;
        break;
      }
    }
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç©ºçš„"å…³é”®è¯ï¼š"å­—æ®µï¼Œç›´æ¥è¿”å›
    if (!keywordFieldObj) {
      return;
    }
    
    try {
      // è®°å½•åŸå§‹å­—æ®µçš„ç´¢å¼•ä½ç½®
      let originalFieldIndex = keywordFieldObj.index;
      
      // åˆ é™¤ç©ºçš„"å…³é”®è¯ï¼š"å­—æ®µ
      note.removeCommentByIndex(originalFieldIndex);
      
      // è·å–æ¨¡æ¿å¡ç‰‡å¹¶å…‹éš†åˆå¹¶
      let templateNoteId = "13D040DD-A662-4EFF-A751-217EE9AB7D2E";
      let templateNote = MNNote.new(templateNoteId, false);
      
      if (templateNote) {
        // å…‹éš†æ¨¡æ¿å¡ç‰‡åˆ°å½“å‰å¡ç‰‡
        let clonedNote = templateNote.clone();
        if (clonedNote) {
          // åˆå¹¶å…‹éš†çš„å¡ç‰‡åˆ°å½“å‰å¡ç‰‡ï¼ˆæ–°å†…å®¹ä¼šæ·»åŠ åˆ°æœ«å°¾ï¼‰
          clonedNote.mergeInto(note);
          
          // æ–°åˆå¹¶çš„"å…³é”®è¯ï¼š"å­—æ®µåœ¨æœ€åä¸€ä¸ªä½ç½®ï¼ˆnote.comments.length - 1ï¼‰
          // å°†å®ƒç§»åŠ¨åˆ°åŸæ¥çš„ä½ç½®
          let lastCommentIndex = note.comments.length - 1;
          note.moveComment(lastCommentIndex, originalFieldIndex);
          
          // åˆ·æ–°æ˜¾ç¤º
          note.refresh();
        }
      } else {
        MNUtil.log("è­¦å‘Šï¼šæ— æ³•æ‰¾åˆ°å…³é”®è¯æ¨¡æ¿å¡ç‰‡ (ID: 13D040DD-A662-4EFF-A751-217EE9AB7D2E)");
      }
      
    } catch (error) {
      MNUtil.addErrorLog(error, "processEmptyKeywordField", {
        noteId: note.noteId,
        noteTitle: note.noteTitle
      });
    }
  }

  /**
   * ä¿®æ”¹æ ‡é¢˜
   * 
   * TODO:
   * []å¼ºåˆ¶ä¿®æ”¹å‰ç¼€
   * []å¦‚æœæœ‰è¡¥å……å†…å®¹ï¼Œåˆ™ä¸ä¿®æ”¹å‰ç¼€ï¼Œé˜²æ­¢æ¡ä»¶å†…å®¹è¢«æ¸…é™¤
   */
  static changeTitle(note, forced = false, inputType = null) {
    /**
     * ä¸åœ¨åˆ¶å¡æ—¶ä¿®æ”¹å¡ç‰‡æ ‡é¢˜çš„ç±»å‹
     * 
     * å½’ç±»ï¼šå› ä¸ºå–æ¶ˆäº†ä»¥å‰çš„â€œxxâ€ï¼šâ€œyyâ€ é‡Œçš„ xxï¼Œåªç”¨é“¾æ¥æ¥è€ƒè™‘æ‰€å±ï¼Œæ‰€ä»¥ä¸éœ€è¦æ¶‰åŠæ”¹å˜æ ‡é¢˜
     */
    let noteType = inputType?inputType:this.getNoteType(note)
    
    let excludingTypes = ["æ€è·¯", "ä½œè€…", "ç ”ç©¶è¿›å±•", "è®ºæ–‡", "ä¹¦ä½œ", "æ–‡çŒ®"];
    if (!excludingTypes.includes(noteType)) {
      switch (noteType) {
        case "å½’ç±»":
          /**
           * å»æ‰å½’ç±»å¡ç‰‡çš„æ ‡é¢˜ä¸­çš„â€œxxâ€ï¼šâ€œyyâ€ é‡Œçš„ xx
           */
          if (this.hasOldClassificationTitle(note)) {
            note.title = `â€œ${this.parseNoteTitle(note).content}â€ç›¸å…³${this.parseNoteTitle(note).type}`;
          }
          break;
        default:
          // è·å–å½’ç±»å¡ç‰‡
          let classificationNote = this.getFirstClassificationParentNote(note);
          if (classificationNote) {
            let classificationNoteTitleParts = this.parseNoteTitle(classificationNote);
            // ç”Ÿæˆæ–°çš„å‰ç¼€å†…å®¹ï¼ˆä¸åŒ…å«ã€ã€‘ï¼‰
            let newPrefixContent = this.createChildNoteTitlePrefixContent(classificationNote);
            
            
            // è§£æå½“å‰ç¬”è®°çš„æ ‡é¢˜
            let noteTitleParts = this.parseNoteTitle(note);
            
            // å¼ºåˆ¶ä¿®æ”¹å‰ç¼€çš„å¤„ç†
            if (forced === true) {
              // å…ˆç§»é™¤ç°æœ‰å‰ç¼€
              this.removeTitlePrefix(note);
              // é‡æ–°è§£ææ ‡é¢˜
              noteTitleParts = this.parseNoteTitle(note);
            }
            
            // æ™ºèƒ½å‰ç¼€æ¯”è¾ƒé€»è¾‘
            let shouldUpdatePrefix = true;
            if (!forced && noteTitleParts.prefixContent) {
              // å¦‚æœç°æœ‰å‰ç¼€åŒ…å«æ–°å‰ç¼€å†…å®¹ï¼Œåˆ™ä¿ç•™ç°æœ‰å‰ç¼€
              // ä¾‹å¦‚ï¼šç°æœ‰å‰ç¼€ "AB" åŒ…å«æ–°å‰ç¼€ "A"ï¼Œåˆ™ä¸æ›´æ–°
              if (noteTitleParts.prefixContent.includes(newPrefixContent)) {
                shouldUpdatePrefix = false;
              }
            }
            
            // å¦‚æœæ˜¯å¼ºåˆ¶æ¨¡å¼ï¼Œæ€»æ˜¯æ›´æ–°å‰ç¼€
            if (forced === true) {
              shouldUpdatePrefix = true;
            }
            
            // æ„å»ºæœ€ç»ˆæ ‡é¢˜
            let finalPrefix;
            if (shouldUpdatePrefix) {
              // ä½¿ç”¨æ–°å‰ç¼€
              finalPrefix = this.createTitlePrefix(inputType?inputType:classificationNoteTitleParts.type, newPrefixContent);
            } else {
              // ä¿ç•™ç°æœ‰å‰ç¼€
              finalPrefix = this.createTitlePrefix(inputType?inputType:noteTitleParts.type || classificationNoteTitleParts.type, noteTitleParts.prefixContent);
            }
            

            // å®šä¹‰ç±» noteTitleParts.content å‰è¦åŠ  `; `
            if (noteType === "å®šä¹‰") {
              note.title = finalPrefix + '; ' + noteTitleParts.content;
            } else {
              note.title = `${finalPrefix}${noteTitleParts.content}`;
            }
          }
          break;
      }
    }

    note.title = Pangu.spacing(note.title)

    KnowledgeBaseIndexer.addToIncrementalIndex(note)

    // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šä¿®æ”¹æ ‡é¢˜åæ¸…é™¤ç±»å‹ç¼“å­˜ï¼Œå› ä¸ºæ ‡é¢˜æ”¹å˜å¯èƒ½å¯¼è‡´ç±»å‹åˆ¤æ–­æ”¹å˜
    this.noteTypeCache.delete(note);
    // KnowledgeBaseUtils.log("æ¸…é™¤å¡ç‰‡ç±»å‹ç¼“å­˜", "changeTitle", {
    //   noteId: note.noteId,
    //   noteTitle: note.noteTitle
    // })
  }

  /**
   * æ‰¹é‡æ›´æ–°å½’ç±»å¡ç‰‡ä¸‹æ‰€æœ‰çŸ¥è¯†ç‚¹å­å­™å¡ç‰‡çš„å‰ç¼€
   * ç‚¹å‡»å½’ç±»å¡ç‰‡åè°ƒç”¨æ­¤å‡½æ•°ï¼Œä¼šå¼ºåˆ¶æ›´æ–°æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„å­å­™å¡ç‰‡å‰ç¼€
   * 
   * @param {MNNote} classificationNote - å½’ç±»å¡ç‰‡
   */
  static batchUpdateChildrenPrefixes(classificationNote, descendant = false) {
    // æ£€æŸ¥æ˜¯å¦ä¸ºå½’ç±»å¡ç‰‡
    if (!this.isClassificationNote(classificationNote)) {
      MNUtil.showHUD("è¯·é€‰æ‹©ä¸€ä¸ªå½’ç±»å¡ç‰‡");
      return;
    }
    let descendants
    if (descendant) {
      // è·å–æ‰€æœ‰å­å­™å¡ç‰‡
      descendants = this.getAllDescendantNotes(classificationNote);
    } else {
      // åªè·å–å­å¡ç‰‡
      descendants = classificationNote.childNotes
    }
    
    let processedCount = 0;
    let skippedCount = 0;
    
    // æ‰¹é‡å¤„ç†
    MNUtil.undoGrouping(() => {
      descendants.forEach(note => {
        const mnNote = MNNote.new(note);
        
        // è·³è¿‡æ²¡æœ‰æ ‡é¢˜çš„å¡ç‰‡
        if (!mnNote.noteTitle) {
          skippedCount++;
          return;
        }
        
        // // è·³è¿‡éçŸ¥è¯†ç‚¹å¡ç‰‡ï¼ˆä½¿ç”¨å·²æœ‰çš„ isKnowledgeNote å‡½æ•°ï¼‰
        // if (!this.isKnowledgeNote(mnNote)) {
        //   skippedCount++;
        //   return;
        // }
        
        // å¼ºåˆ¶æ›´æ–°å‰ç¼€
        this.changeTitle(mnNote, true);
        this.linkParentNote(mnNote)
        processedCount++;
      });

      classificationNote.refreshAll()
    });
    
    // æ˜¾ç¤ºå¤„ç†ç»“æœ
    MNUtil.showHUD(`å·²æ›´æ–° ${processedCount} ä¸ªçŸ¥è¯†ç‚¹å¡ç‰‡çš„å‰ç¼€ï¼Œè·³è¿‡ ${skippedCount} ä¸ªå¡ç‰‡`, 2);
  }

  /**
   * æ‰¹é‡é‡æ–°å¤„ç†å½’ç±»å¡ç‰‡æ ‡é¢˜
   * 
   * ä¸“é—¨ç”¨äºå¤„ç†"å½’ç±»"ç±»å‹çš„å¡ç‰‡ï¼Œå°†æ—§æ ¼å¼æ ‡é¢˜è½¬æ¢ä¸ºæ–°æ ¼å¼
   * æ—§æ ¼å¼ï¼š"xx"ï¼š"yy"ç›¸å…³ zz -> æ–°æ ¼å¼ï¼š"yy"ç›¸å…³ zz
   * 
   * @param {string} scope - å¤„ç†èŒƒå›´ï¼š"selected" | "children" | "descendants"
   * @param {MNNote} [rootNote] - å½“ scope ä¸º "children" æˆ– "descendants" æ—¶ï¼ŒæŒ‡å®šæ ¹å¡ç‰‡
   */
  static async batchChangeClassificationTitles(scope = "descendants", rootNote = null) {
    try {
      let targetNotes = [];
      let processedCount = 0;
      let skippedCount = 0;

      // æ ¹æ®èŒƒå›´è·å–ç›®æ ‡å¡ç‰‡
      switch (scope) {
        case "selected":
          let focusNote = MNNote.getFocusNote();
          if (focusNote) {
            targetNotes = [focusNote.note];
          } else {
            MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¡ç‰‡");
            return;
          }
          break;
        case "children":
          if (!rootNote) {
            rootNote = MNNote.getFocusNote();
          }
          if (rootNote) {
            // rootNote.childNotes è¿”å› MNNote å¯¹è±¡æ•°ç»„ï¼Œéœ€è¦è½¬æ¢ä¸ºåŸç”Ÿ note å¯¹è±¡æ•°ç»„
            targetNotes = (rootNote.childNotes || []).map(mnNote => mnNote.note);
            targetNotes.push(rootNote.note)
          } else {
            MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ ¹å¡ç‰‡");
            return;
          }
          break;
        case "descendants":
          if (!rootNote) {
            rootNote = MNNote.getFocusNote();
          }
          if (rootNote) {
            targetNotes = this.getAllDescendantNotes(rootNote);
            targetNotes.push(rootNote.note)
          } else {
            MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ ¹å¡ç‰‡");
            return;
          }
          break;
        default:
          MNUtil.showHUD("æ— æ•ˆçš„å¤„ç†èŒƒå›´");
          return;
      }

      // ç­›é€‰å‡ºå½’ç±»å¡ç‰‡
      let classificationNotes = [];
      for (let noteObj of targetNotes) {
        let note = new MNNote(noteObj);
        if (this.getNoteType(note) === "å½’ç±»") {
          classificationNotes.push(note);
        }
      }

      if (classificationNotes.length === 0) {
        MNUtil.showHUD("æ²¡æœ‰æ‰¾åˆ°å½’ç±»å¡ç‰‡");
        return;
      }

      // è¯¢é—®ç”¨æˆ·ç¡®è®¤
      let confirmMessage = `æ‰¾åˆ° ${classificationNotes.length} ä¸ªå½’ç±»å¡ç‰‡ï¼Œæ˜¯å¦æ‰¹é‡æ›´æ–°æ ‡é¢˜æ ¼å¼ï¼Ÿ`;
      let userConfirmed = await MNUtil.confirm("æ‰¹é‡ä¿®æ”¹å½’ç±»å¡ç‰‡æ ‡é¢˜", confirmMessage);
      if (!userConfirmed) {
        return;
      }

      // æ˜¾ç¤ºè¿›åº¦æç¤º
      MNUtil.showHUD(`å¼€å§‹å¤„ç† ${classificationNotes.length} ä¸ªå½’ç±»å¡ç‰‡...`);

      // ä½¿ç”¨ undoGrouping åŒ…è£…æ‰¹é‡æ“ä½œ
      MNUtil.undoGrouping(() => {
        for (let i = 0; i < classificationNotes.length; i++) {
          let note = classificationNotes[i];
          let originalTitle = note.title;
          
          // ä½¿ç”¨ç°æœ‰çš„è§£ææ–¹æ³•
          // let titleParts = this.parseNoteTitle(note);
          
          // æ£€æŸ¥æ˜¯å¦è§£ææˆåŠŸï¼Œå¹¶ä¸”æ˜¯æ—§æ ¼å¼
          if (this.hasOldClassificationTitle(note)) {
            // è½¬æ¢ä¸ºæ–°æ ¼å¼ï¼š"content"ç›¸å…³ type
            // note.title = `â€œ${titleParts.content}â€ç›¸å…³${titleParts.type}`;
            this.changeTitle(note)

            processedCount++;
            MNUtil.log({
              level: "info",
              message: `å½’ç±»å¡ç‰‡æ ‡é¢˜å·²æ›´æ–°ï¼š${originalTitle} -> ${note.title}`,
              source: "KnowledgeBaseTemplate.batchChangeClassificationTitles"
            });
          } else {
            skippedCount++;
            MNUtil.log({
              level: "info",
              message: `è·³è¿‡æ ‡é¢˜ï¼ˆå·²æ˜¯æ–°æ ¼å¼æˆ–æ— æ³•è§£æï¼‰ï¼š${originalTitle}`,
              source: "KnowledgeBaseTemplate.batchChangeClassificationTitles"
            });
          }
        }
      });

      // æ˜¾ç¤ºè¿›åº¦æ›´æ–°
      for (let i = 0; i < classificationNotes.length; i++) {
        if ((i + 1) % 5 === 0) {
          MNUtil.showHUD(`å¤„ç†ä¸­... ${i + 1}/${classificationNotes.length}`);
          await MNUtil.delay(0.1);
        }
      }

      // æ˜¾ç¤ºå¤„ç†ç»“æœ
      let resultMessage = `å½’ç±»å¡ç‰‡å¤„ç†å®Œæˆï¼\nå·²æ›´æ–°ï¼š${processedCount} ä¸ª\nè·³è¿‡ï¼š${skippedCount} ä¸ª`;
      MNUtil.showHUD(resultMessage);
      
      // è®°å½•å¤„ç†ç»“æœ
      MNUtil.log({
        level: "info",
        message: `æ‰¹é‡å½’ç±»å¡ç‰‡æ ‡é¢˜å¤„ç†å®Œæˆ - èŒƒå›´ï¼š${scope}ï¼Œå¤„ç†ï¼š${processedCount}ï¼Œè·³è¿‡ï¼š${skippedCount}`,
        source: "KnowledgeBaseTemplate.batchChangeClassificationTitles"
      });

    } catch (error) {
      MNUtil.showHUD("æ‰¹é‡å¤„ç†å½’ç±»å¡ç‰‡æ ‡é¢˜æ—¶å‡ºé”™ï¼š" + error.message);
      MNUtil.log({
        level: "error",
        message: "æ‰¹é‡å¤„ç†å½’ç±»å¡ç‰‡æ ‡é¢˜å¤±è´¥ï¼š" + error.message,
        source: "KnowledgeBaseTemplate.batchChangeClassificationTitles"
      });
    }
  }

  static hasOldClassificationTitle(note) {
    // æ£€æŸ¥æ ‡é¢˜æ˜¯å¦ç¬¦åˆæ—§æ ¼å¼ï¼š"xx"ï¼š"yy"ç›¸å…³ zz
    return /^â€œ[^â€]*â€ï¼šâ€œ[^â€]*â€\s*ç›¸å…³[^â€œ]*$/.test(note.title);
  }

  /**
   * æ‰¹é‡é‡æ–°å¤„ç†å¡ç‰‡æ ‡é¢˜
   * 
   * å¯ä»¥é€‰æ‹©å¤„ç†å½“å‰æ–‡æ¡£çš„æ‰€æœ‰å¡ç‰‡æˆ–æŒ‡å®šèŒƒå›´çš„å¡ç‰‡
   * 
   * @param {string} scope - å¤„ç†èŒƒå›´ï¼š"all" | "selected" | "children" | "descendants"
   * @param {MNNote} [rootNote] - å½“ scope ä¸º "children" æˆ– "descendants" æ—¶ï¼ŒæŒ‡å®šæ ¹å¡ç‰‡
   */
  static async batchChangeTitles(scope = "all", rootNote = null) {
    try {
      let targetNotes = [];
      let processedCount = 0;
      let skippedCount = 0;

      // æ ¹æ®èŒƒå›´è·å–ç›®æ ‡å¡ç‰‡
      switch (scope) {
        case "all":
          // è·å–å½“å‰ç¬”è®°æœ¬çš„æ‰€æœ‰å¡ç‰‡
          let currentNotebook = MNUtil.currentNotebook;
          if (currentNotebook) {
            targetNotes = currentNotebook.notes || [];
          } else {
            MNUtil.showHUD("è¯·å…ˆæ‰“å¼€ä¸€ä¸ªç¬”è®°æœ¬");
            return;
          }
          break;
          
        case "selected":
          // è·å–å½“å‰é€‰ä¸­çš„å¡ç‰‡
          let focusNote = MNNote.getFocusNote();
          if (focusNote) {
            targetNotes = [focusNote.note];
          } else {
            MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¡ç‰‡");
            return;
          }
          break;
          
        case "children":
          // è·å–æŒ‡å®šå¡ç‰‡çš„ç›´æ¥å­å¡ç‰‡
          if (!rootNote) {
            rootNote = MNNote.getFocusNote();
          }
          if (rootNote) {
            // rootNote.childNotes è¿”å› MNNote å¯¹è±¡æ•°ç»„ï¼Œéœ€è¦è½¬æ¢ä¸ºåŸç”Ÿ note å¯¹è±¡æ•°ç»„
            targetNotes = (rootNote.childNotes || []).map(mnNote => mnNote.note);
          } else {
            MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ ¹å¡ç‰‡");
            return;
          }
          break;
          
        case "descendants":
          // è·å–æŒ‡å®šå¡ç‰‡çš„æ‰€æœ‰åä»£å¡ç‰‡
          if (!rootNote) {
            rootNote = MNNote.getFocusNote();
          }
          if (rootNote) {
            targetNotes = this.getAllDescendantNotes(rootNote);
          } else {
            MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ ¹å¡ç‰‡");
            return;
          }
          break;
          
        default:
          MNUtil.showHUD("æ— æ•ˆçš„å¤„ç†èŒƒå›´");
          return;
      }

      if (targetNotes.length === 0) {
        MNUtil.showHUD("æ²¡æœ‰æ‰¾åˆ°éœ€è¦å¤„ç†çš„å¡ç‰‡");
        return;
      }

      // è¯¢é—®ç”¨æˆ·ç¡®è®¤
      let confirmMessage = `å³å°†æ‰¹é‡å¤„ç† ${targetNotes.length} ä¸ªå¡ç‰‡çš„æ ‡é¢˜ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ`;
      let userConfirmed = await MNUtil.confirm("æ‰¹é‡ä¿®æ”¹æ ‡é¢˜", confirmMessage);
      if (!userConfirmed) {
        return;
      }

      // æ˜¾ç¤ºè¿›åº¦æç¤º
      MNUtil.showHUD(`å¼€å§‹å¤„ç† ${targetNotes.length} ä¸ªå¡ç‰‡...`);

      // ä½¿ç”¨ undoGrouping åŒ…è£…æ‰¹é‡æ“ä½œ
      MNUtil.undoGrouping(() => {
        for (let i = 0; i < targetNotes.length; i++) {
          let note = new MNNote(targetNotes[i]);
          
          // è®°å½•å¤„ç†å‰çš„æ ‡é¢˜
          let originalTitle = note.title;
          
          // è°ƒç”¨ changeTitle æ–¹æ³•
          this.changeTitle(note);
          
          // æ£€æŸ¥æ ‡é¢˜æ˜¯å¦å‘ç”Ÿå˜åŒ–
          if (note.title !== originalTitle) {
            processedCount++;
            MNUtil.log({
              level: "info",
              message: `æ ‡é¢˜å·²æ›´æ–°ï¼š${originalTitle} -> ${note.title}`,
              source: "KnowledgeBaseTemplate.batchChangeTitles"
            });
          } else {
            skippedCount++;
          }
        }
      });

      // æ˜¾ç¤ºè¿›åº¦æ›´æ–°
      for (let i = 0; i < targetNotes.length; i++) {
        if ((i + 1) % 10 === 0) {
          MNUtil.showHUD(`å¤„ç†ä¸­... ${i + 1}/${targetNotes.length}`);
          await MNUtil.delay(0.1);
        }
      }

      // æ˜¾ç¤ºå¤„ç†ç»“æœ
      let resultMessage = `å¤„ç†å®Œæˆï¼\nå·²æ›´æ–°ï¼š${processedCount} ä¸ª\nè·³è¿‡ï¼š${skippedCount} ä¸ª`;
      MNUtil.showHUD(resultMessage);
      
      // è®°å½•å¤„ç†ç»“æœ
      MNUtil.log({
        level: "info",
        message: `æ‰¹é‡æ ‡é¢˜å¤„ç†å®Œæˆ - èŒƒå›´ï¼š${scope}ï¼Œå¤„ç†ï¼š${processedCount}ï¼Œè·³è¿‡ï¼š${skippedCount}`,
        source: "KnowledgeBaseTemplate.batchChangeTitles"
      });

    } catch (error) {
      MNUtil.showHUD("æ‰¹é‡å¤„ç†æ ‡é¢˜æ—¶å‡ºé”™ï¼š" + error.message);
      MNUtil.log({
        level: "error",
        message: "æ‰¹é‡å¤„ç†æ ‡é¢˜å¤±è´¥ï¼š" + error.message,
        source: "KnowledgeBaseTemplate.batchChangeTitles"
      });
    }
  }

  /**
   * è·å–æŒ‡å®šå¡ç‰‡çš„æ‰€æœ‰åä»£å¡ç‰‡ï¼ˆåŒ…æ‹¬å­å¡ç‰‡å’Œå­å¡ç‰‡çš„å­å¡ç‰‡ç­‰ï¼‰
   * 
   * @param {MNNote} rootNote - æ ¹å¡ç‰‡
   * @returns {object[]} æ‰€æœ‰åä»£å¡ç‰‡çš„åŸç”Ÿå¯¹è±¡æ•°ç»„
   */
  static getAllDescendantNotes(rootNote) {
    let descendants = [];
    
    // ç¡®ä¿ rootNote æ˜¯ MNNote å¯¹è±¡
    if (!rootNote || !rootNote.childNotes) {
      return descendants;
    }
    
    let childNotes = rootNote.childNotes || [];  // è¿™é‡Œè¿”å›çš„æ˜¯ MNNote å¯¹è±¡æ•°ç»„
    
    for (let childMNNote of childNotes) {
      // childMNNote å·²ç»æ˜¯ MNNote å¯¹è±¡ï¼Œä¸éœ€è¦å†ç”¨ new MNNote() åŒ…è£…
      descendants.push(childMNNote.note);
      
      // é€’å½’è·å–å­å¡ç‰‡çš„åä»£
      let childDescendants = this.getAllDescendantNotes(childMNNote);
      descendants.push(...childDescendants);
    }
    
    return descendants;
  }

  /**
   * è·å–æŒ‡å®šå¡ç‰‡çš„æ‰€æœ‰åä»£å¡ç‰‡ï¼Œæ”¯æŒè·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡
   * 
   * @param {MNNote} rootNote - æ ¹å¡ç‰‡
   * @param {boolean} skipEmptyTitle - æ˜¯å¦è·³è¿‡ç©ºç™½æ ‡é¢˜çš„å¡ç‰‡åŠå…¶å­å­™
   * @param {Array<string>} rootNoteIds - æ ¹ç›®å½•IDåˆ—è¡¨ï¼Œç”¨äºæ£€æŸ¥ç©ºç™½å¡ç‰‡çš„å­å¡ç‰‡æ˜¯å¦ä¸ºæ ¹ç›®å½•
   * @returns {object[]} æ‰€æœ‰åä»£å¡ç‰‡çš„åŸç”Ÿå¯¹è±¡æ•°ç»„
   */
  static getAllDescendantNotesWithSkipEmpty(rootNote, skipEmptyTitle = false, rootNoteIds = []) {
    let descendants = [];
    
    // ç¡®ä¿ rootNote æ˜¯ MNNote å¯¹è±¡
    if (!rootNote || !rootNote.childNotes) {
      return descendants;
    }
    
    let childNotes = rootNote.childNotes || [];  // è¿™é‡Œè¿”å›çš„æ˜¯ MNNote å¯¹è±¡æ•°ç»„
    
    for (let childMNNote of childNotes) {
      // æ£€æŸ¥æ˜¯å¦éœ€è¦è·³è¿‡ç©ºæ ‡é¢˜å¡ç‰‡
      const title = childMNNote.noteTitle || "";
      if (skipEmptyTitle && title.trim() === "") {
        // æ£€æŸ¥è¯¥ç©ºç™½å¡ç‰‡çš„ç¬¬ä¸€ä¸ªå­å¡ç‰‡æ˜¯å¦åœ¨æ ¹ç›®å½•åˆ—è¡¨ä¸­
        let shouldSkip = true;
        if (rootNoteIds && rootNoteIds.length > 0 && childMNNote.childNotes && childMNNote.childNotes.length > 0) {
          const firstChildId = childMNNote.childNotes[0].noteId;
          if (rootNoteIds.includes(firstChildId)) {
            shouldSkip = false;
            MNUtil.log(`âš ï¸ ç©ºç™½æ ‡é¢˜å¡ç‰‡çš„å­å¡ç‰‡ä¸ºæ ¹ç›®å½•ï¼Œä¸è·³è¿‡: ${childMNNote.noteId} -> ${firstChildId}`);
          }
        }
        
        if (shouldSkip) {
          // è·³è¿‡è¯¥å¡ç‰‡åŠå…¶æ‰€æœ‰å­å­™
          MNUtil.log(`ğŸš« è·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡: ${childMNNote.noteId}`);
          continue;
        }
      }
      
      // childMNNote å·²ç»æ˜¯ MNNote å¯¹è±¡ï¼Œä¸éœ€è¦å†ç”¨ new MNNote() åŒ…è£…
      descendants.push(childMNNote.note);
      
      // é€’å½’è·å–å­å¡ç‰‡çš„åä»£ï¼ˆä¼ é€’ skipEmptyTitle å’Œ rootNoteIds å‚æ•°ï¼‰
      let childDescendants = this.getAllDescendantNotesWithSkipEmpty(childMNNote, skipEmptyTitle, rootNoteIds);
      descendants.push(...childDescendants);
    }
    
    return descendants;
  }

  /**
   * è·å–ç¬¬ä¸€ä¸ªå½’ç±»å¡ç‰‡çš„çˆ¶çˆ·å¡ç‰‡
   */
  static getFirstClassificationParentNote(note) {
    // KnowledgeBaseUtils.log("å¼€å§‹æ‰§è¡Œ getFirstClassificationParentNote", "getFirstClassificationParentNote", {
    //   noteId: note.noteId,
    //   noteTitle: note.noteTitle
    // })

    // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šæ£€æŸ¥ç¼“å­˜
    if (this.classificationParentCache.has(note)) {
      const cached = this.classificationParentCache.get(note);
      // KnowledgeBaseUtils.log("ä½¿ç”¨ç¼“å­˜çš„å½’ç±»çˆ¶å¡ç‰‡", "getFirstClassificationParentNote", {
      //   noteId: note.noteId,
      //   cached: cached ? cached.noteId : null
      // })
      return cached;
    }

    let parentNote = note.parentNote;
    let depth = 0;

    while (parentNote) {
      depth++;
      // ç›´æ¥è°ƒç”¨ getNoteTypeï¼Œä¸ä¼ é€’ depth
      // å› ä¸ºè¿™æ˜¯åœ¨éå†çˆ¶èŠ‚ç‚¹é“¾ï¼Œä¸æ˜¯é€’å½’è°ƒç”¨
      if (this.getNoteType(parentNote) === "å½’ç±»") {
        // KnowledgeBaseUtils.log("æ‰¾åˆ°å½’ç±»çˆ¶å¡ç‰‡", "getFirstClassificationParentNote", {
        //   noteId: note.noteId,
        //   classificationParentNoteId: parentNote.noteId,
        //   classificationParentNoteTitle: parentNote.noteTitle,
        //   traversalDepth: depth
        // })

        // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šå­˜å…¥ç¼“å­˜
        this.classificationParentCache.set(note, parentNote);

        return parentNote;
      }
      parentNote = parentNote.parentNote;
    }

    // KnowledgeBaseUtils.log("æœªæ‰¾åˆ°å½’ç±»çˆ¶å¡ç‰‡", "getFirstClassificationParentNote", {
    //   noteId: note.noteId,
    //   traversalDepth: depth
    // })

    // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜ null ç»“æœï¼ˆé¿å…é‡å¤æŸ¥æ‰¾ï¼‰
    this.classificationParentCache.set(note, null);

    return null;
  }

  /**
   * ã€éæ‘˜å½•ç‰ˆæœ¬ã€‘åˆå§‹çŠ¶æ€åˆå¹¶æ¨¡æ¿å¡ç‰‡åè‡ªåŠ¨ç§»åŠ¨å¡ç‰‡çš„å†…å®¹
   */
  static mergeTemplateAndAutoMoveNoteContent(note, directly) {
    // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœåªæœ‰ä¸€æ¡è¯„è®ºä¸”æ˜¯æ‰‹å†™ç±»å‹ï¼Œç›´æ¥åˆå¹¶æ¨¡æ¿ä¸ç§»åŠ¨å†…å®¹
    if (note.MNComments.length === 1) {
      let commentType = note.MNComments[0].type;
      if (commentType === "drawingComment" || 
          commentType === "imageCommentWithDrawing" || 
          commentType === "mergedImageCommentWithDrawing") {
        // MNUtil.log("ğŸ–Šï¸ æ£€æµ‹åˆ°å•ä¸ªæ‰‹å†™è¯„è®ºï¼Œç›´æ¥åˆå¹¶æ¨¡æ¿ï¼Œä¸ç§»åŠ¨å†…å®¹");
        this.mergeTemplate(note);
        return;
      }
    }
    
    // ç™½åå•ï¼šè¿™äº›ç±»å‹çš„å¡ç‰‡å³ä½¿åªæœ‰å›¾ç‰‡+é“¾æ¥ä¹ŸæŒ‰æ­£å¸¸æ–¹å¼å¤„ç†
    const typeWhitelist = []; // æš‚æ—¶ä¸ºç©ºï¼Œåç»­å¯ä»¥æ·»åŠ éœ€è¦æ’é™¤çš„å¡ç‰‡ç±»å‹
    
    // è·å–å¡ç‰‡ç±»å‹
    let noteType = this.getNoteType(note, directly);
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºç‰¹æ®Šæƒ…å†µï¼šåªæœ‰åˆå¹¶å›¾ç‰‡å’Œé“¾æ¥
    let isSpecialCase = false;
    let linkIndices = [];
    
    if (!typeWhitelist.includes(noteType)) {
      // æ£€æŸ¥æ‰€æœ‰è¯„è®ºæ˜¯å¦åªåŒ…å«åˆå¹¶å›¾ç‰‡å’Œé“¾æ¥
      let hasOtherContent = false;
      
      for (let i = 0; i < note.MNComments.length; i++) {
        let comment = note.MNComments[i];
        if (!comment) {
          continue;
        }
        if (comment.type === "mergedImageComment" || comment.type === "mergedImageCommentWithDrawing") {
          // æ˜¯åˆå¹¶å›¾ç‰‡ï¼Œç»§ç»­
          continue;
        } else if (comment.type === "linkComment") {
          // æ˜¯é“¾æ¥ï¼Œè®°å½•ç´¢å¼•
          linkIndices.push(i);
        } else {
          // æœ‰å…¶ä»–ç±»å‹çš„å†…å®¹
          hasOtherContent = true;
          break;
        }
      }
      
      // å¦‚æœæ²¡æœ‰å…¶ä»–å†…å®¹ä¸”æœ‰é“¾æ¥ï¼Œåˆ™ä¸ºç‰¹æ®Šæƒ…å†µ
      isSpecialCase = !hasOtherContent && linkIndices.length > 0;
    }
    
    let moveIndexArr = this.autoGetNewContentToMoveIndexArr(note);
    
    // åœ¨åˆå¹¶æ¨¡æ¿å‰ï¼Œå¦‚æœå¡ç‰‡å·²ç»æœ‰æ–‡å­—è¯„è®ºäº†ï¼Œå…ˆæå– Markdown é“¾æ¥
    let marginNoteLinks = [];
    if (moveIndexArr.length > 0) {
      marginNoteLinks = this.extractMarginNoteLinksFromComments(note, moveIndexArr);
      // MNUtil.log(`ğŸ” åœ¨åˆå¹¶æ¨¡æ¿å‰æ‰¾åˆ° ${marginNoteLinks.length} ä¸ª MarginNote é“¾æ¥`);
    }
    
    let ifTemplateMerged = this.mergeTemplate(note)

    // ä½¿ç”¨æ˜ å°„è¡¨è·å–é»˜è®¤å­—æ®µ
    let field = this.getDefaultFieldForType(noteType);
    if (!ifTemplateMerged) {
      // ç‰¹æ®Šå¤„ç†ï¼šå°†é“¾æ¥ç§»åŠ¨åˆ°æœ€åº•ä¸‹
      if (isSpecialCase) {
        note.moveCommentsByIndexArr(moveIndexArr, note.comments.length);
      } else {
        if (field && moveIndexArr.length > 0) {
          this.moveCommentsArrToField(note, moveIndexArr, field);
        }
      }
    }

    if (!["è¯æ˜", "åä¾‹", "åŸç†"].includes(this.normalizeFieldName(field))) {
      return
    }
    
    // å¤„ç†ä¹‹å‰æå–çš„ MarginNote é“¾æ¥
    if (marginNoteLinks.length > 0) {
      // MNUtil.log("ğŸ”— å¼€å§‹å¤„ç†åˆå¹¶æ¨¡æ¿å‰æå–çš„ MarginNote é“¾æ¥...");
      this.processExtractedMarginNoteLinks(note, marginNoteLinks);
    }
  }

  static ifTemplateMerged(note) {
    return note.MNComments.some(comment => comment.type === "HtmlComment");
  }

  /**
   * åˆå¹¶æ¨¡æ¿å¡ç‰‡
   */
  static mergeTemplate(note) {
    let ifTemplateMerged = note.MNComments.some(comment => comment.type === "HtmlComment"); // æ˜¯å¦å·²åˆå¹¶æ¨¡æ¿å¡ç‰‡ï¼Œè¦åœ¨ä¸‹é¢çš„ä»£ç å‰è·å–ï¼Œå¦åˆ™ä¸€ç›´æ˜¯å·²åˆå¹¶
    // é˜²æ­¢é‡å¤åˆ¶å¡ï¼šå¦‚æœé‡Œé¢æœ‰ HtmlComment åˆ™ä¸åˆ¶å¡
    if (!note.MNComments.some(comment => comment.type === "HtmlComment")) {
      this.cloneAndMergeById(note, this.types[this.getNoteType(note)].templateNoteId);
    }

    // è¿”å›æ˜¯å¦å·²åˆ¶å¡
    return ifTemplateMerged
  }

  /**
   * åˆå¹¶ä¸¤ä¸ªå¡ç‰‡çš„æ ‡é¢˜é“¾æ¥è¯
   * å°†æºå¡ç‰‡çš„æ ‡é¢˜é“¾æ¥è¯ä¸é‡å¤åœ°åˆå¹¶åˆ°ç›®æ ‡å¡ç‰‡
   * 
   * @param {MNNote} targetNote - ç›®æ ‡å¡ç‰‡ï¼ˆAï¼‰
   * @param {MNNote} sourceNote - æºå¡ç‰‡ï¼ˆBï¼‰
   */
  static mergeTitleLinkWords(targetNote, sourceNote) {
    // å¦‚æœä»»ä¸€å¡ç‰‡æ²¡æœ‰æ ‡é¢˜ï¼Œä¸å¤„ç†
    if (!sourceNote.noteTitle) {
      KnowledgeBaseUtils.log("sourceNote æ²¡æœ‰æ ‡é¢˜", "mergeTitleLinkWords")
      return;
    }

    if (this.getNoteType(sourceNote)!=="å®šä¹‰") { return }
    
    // è§£æä¸¤ä¸ªå¡ç‰‡çš„æ ‡é¢˜
    const targetParts = this.parseNoteTitle(targetNote);
    const sourceParts = this.parseNoteTitle(sourceNote);
    
    // è·å–æ ‡é¢˜é“¾æ¥è¯æ•°ç»„
    let targetWords = targetParts.titleLinkWordsArr || [];
    let sourceWords = sourceParts.titleLinkWordsArr || [];
    
    // å¦‚æœæºå¡ç‰‡æ²¡æœ‰æ ‡é¢˜é“¾æ¥è¯ï¼Œç›´æ¥è¿”å›
    if (sourceWords.length === 0) {
      return;
    }
    
    // åˆå¹¶å¹¶å»é‡ï¼ˆä¿æŒé¡ºåºï¼šå…ˆç›®æ ‡çš„ï¼Œå†æºçš„æ–°å¢éƒ¨åˆ†ï¼‰
    const mergedWords = [...targetWords];
    for (const word of sourceWords) {
      if (!mergedWords.includes(word)) {
        mergedWords.push(word);
      }
    }
    
    // å¦‚æœæ²¡æœ‰æ–°å¢è¯ï¼Œç›´æ¥è¿”å›
    if (mergedWords.length === targetWords.length) {
      return;
    }
    
    // æ„å»ºæ–°æ ‡é¢˜
    let newTitle = "";
    
    // ä¿ç•™ç›®æ ‡å¡ç‰‡çš„å‰ç¼€éƒ¨åˆ†
    if (targetParts.type) {
      if (targetParts.prefixContent) {
        newTitle = `ã€${targetParts.type} >> ${targetParts.prefixContent}ã€‘`;
      } else {
        newTitle = `ã€${targetParts.type}ã€‘`;
      }
    }
    
    // æ·»åŠ åˆå¹¶åçš„é“¾æ¥è¯
    if (mergedWords.length > 0) {
      // åˆ¤æ–­åŸæ ‡é¢˜æ˜¯å¦åœ¨ã€‘åæœ‰åˆ†å·
      const hasLeadingSemicolon = targetNote.noteTitle.includes("ã€‘; ");
      if (hasLeadingSemicolon && newTitle) {
        newTitle += "; ";
      }
      newTitle += mergedWords.join("; ");
    }
    
    // æ›´æ–°ç›®æ ‡å¡ç‰‡æ ‡é¢˜
    targetNote.noteTitle = newTitle;
    
    MNUtil.log(`âœ… æ ‡é¢˜é“¾æ¥è¯åˆå¹¶å®Œæˆ: ${sourceWords.length} ä¸ªæºè¯ä¸­æœ‰ ${mergedWords.length - targetWords.length} ä¸ªæ–°å¢è¯`);
  }

  /**
   * æŸ¥æ‰¾å¹¶æ›´æ–°æ‰€æœ‰é“¾æ¥åˆ°æŒ‡å®šå¡ç‰‡çš„ç¬”è®°
   * åªå¤„ç†æºå¡ç‰‡èƒ½å¤Ÿé€šè¿‡é“¾æ¥è®¿é—®åˆ°çš„å¡ç‰‡ï¼Œä»¥åŠæºå¡ç‰‡çš„çˆ¶å­å¡ç‰‡
   *
   * @param {string} sourceNoteURL - æºå¡ç‰‡çš„ URLï¼ˆå°†è¢«æ›¿æ¢ï¼‰
   * @param {string} targetNoteURL - ç›®æ ‡å¡ç‰‡çš„ URLï¼ˆæ›¿æ¢åçš„ URLï¼‰
   * @returns {number} æ›´æ–°çš„é“¾æ¥æ•°é‡
   */
  static updateAllIncomingLinks(sourceNoteURL, targetNoteURL) {

    let updateCount = 0;
    const sourceNoteId = sourceNoteURL.toNoteId();

    try {
      const sourceNote = MNNote.new(sourceNoteId, false);
      if (!sourceNote) {
        return 0;
      }

      // æ”¶é›†éœ€è¦æ£€æŸ¥çš„å¡ç‰‡
      const notesToCheck = new Set();

      //   æ·»åŠ æºå¡ç‰‡é“¾æ¥åˆ°çš„å¡ç‰‡ï¼ˆé€šè¿‡ linkCommentï¼‰
      sourceNote.MNComments.forEach(comment => {
        if (comment.type === "linkComment") {
          const linkedNoteId = comment.text.toNoteId();
          if (linkedNoteId) {
            notesToCheck.add(linkedNoteId);
          }
        }
      });

      //   æ·»åŠ æºå¡ç‰‡ markdown ä¸­é“¾æ¥åˆ°çš„å¡ç‰‡
      sourceNote.MNComments.forEach(comment => {
        if (comment.type === "markdownComment") {
          // æå– markdown ä¸­çš„æ‰€æœ‰é“¾æ¥
          const regex = /marginnote4app:\/\/note\/([A-Z0-9-]+)/g;
          let match;
          while ((match = regex.exec(comment.text)) !== null) {
            notesToCheck.add(match[1]);
          }
        }
      });

      // éå†éœ€è¦æ£€æŸ¥çš„å¡ç‰‡ï¼ŒæŸ¥æ‰¾å¹¶æ›´æ–°é“¾æ¥
      notesToCheck.forEach(noteId => {
        if (noteId === sourceNoteId) return;

        const note = MNNote.new(noteId, false);
        if (!note) return;

        let hasUpdates = false;

        // 1. æ£€æŸ¥å¹¶æ›´æ–° linkComment
        const linkIndices = note.getLinkCommentsIndexArr(sourceNoteURL);
        if (linkIndices.length > 0) {
          linkIndices.forEach(idx => {
            note.replaceWithMarkdownComment(targetNoteURL, idx);
            updateCount++;
          });
          hasUpdates = true;
        }

        // 2. æ£€æŸ¥å¹¶æ›´æ–° markdownComment ä¸­çš„è¡Œå†…é“¾æ¥
        note.MNComments.forEach((comment, idx) => {
          if (comment.type === "markdownComment" && comment.text.includes(sourceNoteURL)) {
            const oldText = comment.text;
            const newText = oldText.replace(new RegExp(sourceNoteURL.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), targetNoteURL);
            if (oldText !== newText) {
              comment.text = newText;
              updateCount++;
              hasUpdates = true;
            }
          }
        });

        // å¦‚æœæœ‰æ›´æ–°ï¼Œåˆ·æ–°ç¬”è®°
        if (hasUpdates) {
          note.refresh();
        }
      });

    } catch (error) {
      // é™é»˜å¤„ç†é”™è¯¯
      MNUtil.copyJSON(error);
    }

    return updateCount;
  }


  /**
   * ã€æ–°ç‰ˆæœ¬ã€‘åˆå¹¶çŸ¥è¯†å¡ç‰‡ - é‡æ–°è®¾è®¡çš„å®ç°
   * å°† sourceNote (B) çš„å†…å®¹æŒ‰å­—æ®µæ™ºèƒ½åˆå¹¶åˆ° targetNote (A) ä¸­
   *
   * æ”¹è¿›ç‚¹ï¼š
   * 1. ä¸ä½¿ç”¨ clone()ï¼Œç›´æ¥æ“ä½œæºå¡ç‰‡
   * 2. æå‰æ›´æ–°æ‰€æœ‰é“¾æ¥ï¼Œç¡®ä¿é“¾æ¥å®Œæ•´æ€§
   * 3. åˆ©ç”¨ç°æœ‰çš„ IndexArr å°è£…æ–¹æ³•
   * 4. å‚è€ƒ splitComments çš„æ¸…æ™°å¤„ç†æµç¨‹
   *
   * @param {MNNote} targetNote - ç›®æ ‡å¡ç‰‡ (A)ï¼Œä¿ç•™çš„å¡ç‰‡
   * @param {MNNote} sourceNote - æºå¡ç‰‡ (B)ï¼Œå°†è¢«åˆå¹¶çš„å¡ç‰‡
   */
  static renewKnowledgeNotes(targetNote, sourceNote) {
    try {
      // 1. é¢„å¤„ç†
      sourceNote.convertLinksToNewVersion();
      sourceNote.cleanupBrokenLinks();
      sourceNote.fixMergeProblematicLinks();
      this.removeUnnecessaryComments(sourceNote);
      
      KnowledgeBaseUtils.log("åˆå¹¶æ ‡é¢˜é“¾æ¥è¯", "renewKnowledgeNotes")
      // 2. åˆå¹¶æ ‡é¢˜é“¾æ¥è¯
      this.mergeTitleLinkWords(targetNote, sourceNote);

      // 3. è·å–å¡ç‰‡ç±»å‹å’Œå­—æ®µæ˜ å°„
      const targetType = this.getNoteType(targetNote);
      const sourceType = this.getNoteType(sourceNote);
      const fieldMapping = this.buildFieldMapping(sourceType, targetType);

      MNUtil.undoGrouping(() => {
        KnowledgeBaseUtils.log("å¼€å§‹æ‰§è¡Œ", "renewKnowledgeNotes")
        // 4. ã€å…³é”®ã€‘åœ¨ä»»ä½•å†…å®¹æ“ä½œå‰ï¼Œå…ˆæ›´æ–°æ‰€æœ‰æŒ‡å‘æºå¡ç‰‡çš„é“¾æ¥
        this.updateAllIncomingLinks(sourceNote.noteURL, targetNote.noteURL);

        // 5. è§£ææºå¡ç‰‡ç»“æ„
        const sourceCommentsObj = this.parseNoteComments(sourceNote);
        const sourceHtmlComments = sourceCommentsObj.htmlCommentsObjArr;

        // 6. å¦‚æœæ²¡æœ‰å­—æ®µç»“æ„ï¼Œç›´æ¥åˆå¹¶åˆ°æ‘˜å½•åŒº
        if (!sourceHtmlComments || sourceHtmlComments.length === 0) {
          KnowledgeBaseUtils.log("æ— å­—æ®µç»“æ„", "renewKnowledgeNotes")
          sourceNote.noteTitle = "";
          sourceNote.mergeInto(targetNote);
          this.autoMoveNewContentToField(targetNote, "æ‘˜å½•", true, false);
          targetNote.refresh();
          MNUtil.showHUD("âœ… åˆå¹¶å®Œæˆï¼ˆå†…å®¹å·²ç§»è‡³æ‘˜å½•åŒºï¼‰");
          return;
        }

        // 7. æœ‰å­—æ®µç»“æ„ - é€å­—æ®µå¤„ç†
        const processedIndices = new Set();

        // å¤„ç†æ¯ä¸ªå­—æ®µ
        sourceHtmlComments.forEach(htmlComment => {
          const fieldName = this.normalizeFieldName(htmlComment.text);
          KnowledgeBaseUtils.log("å¼€å§‹å¤„ç†å­—æ®µ" + fieldName, "renewKnowledgeNotes")
          // è®°å½•å·²å¤„ç†çš„ç´¢å¼•
          processedIndices.add(htmlComment.index);
          htmlComment.excludingFieldBlockIndexArr.forEach(idx => processedIndices.add(idx));

          // è·³è¿‡"ç›¸å…³é“¾æ¥"å­—æ®µ
          if (fieldName === "ç›¸å…³é“¾æ¥") {
            return;
          }

          // ç¡®å®šç›®æ ‡å­—æ®µå
          const targetFieldName = fieldMapping[fieldName] || fieldName;

          if (htmlComment.excludingFieldBlockIndexArr.length === 0) {
            return;
          }

          this.extractComments(sourceNote, htmlComment.excludingFieldBlockIndexArr).mergeInto(targetNote);
          this.cleanupExtractedContentLinks(sourceNote, htmlComment.excludingFieldBlockIndexArr);
          sourceNote.removeCommentsByIndexArr(htmlComment.includingFieldBlockIndexArr)
          this.autoMoveNewContentToField(targetNote, targetFieldName, true, false);
          KnowledgeBaseUtils.log("ç»“æŸå¤„ç†å­—æ®µ" + fieldName, "renewKnowledgeNotes")
        });

        if (sourceNote.comments.length > 0) {
          // è¿˜å‰©æ‘˜å½•åŒº
          KnowledgeBaseUtils.log("åˆå¹¶æ‘˜å½•åŒº", "renewKnowledgeNotes")
          this.retainFieldContentByName(sourceNote, "æ‘˜å½•")
          sourceNote.title = ""
          sourceNote.mergeInto(targetNote);
          this.autoMoveNewContentToField(targetNote, "æ‘˜å½•", true, false);
        } else {
          KnowledgeBaseUtils.log("åˆ é™¤å¡ç‰‡", "renewKnowledgeNotes")
          sourceNote.delete(false);
        }

        // 10. åˆ·æ–°ç›®æ ‡å¡ç‰‡
        targetNote.refresh();
        targetNote.focusInMindMap(0.4)
      });

      MNUtil.showHUD("âœ… çŸ¥è¯†å¡ç‰‡åˆå¹¶å®Œæˆ");

    } catch (error) {
      MNUtil.copyJSON(error);
      MNUtil.showHUD("âŒ åˆå¹¶å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—");
    }
  }

  /**
   * æ ‡å‡†åŒ–å­—æ®µåï¼Œå»é™¤å¤šä½™çš„å†’å·å’Œç©ºæ ¼
   * 
   * @param {string} fieldText - åŸå§‹å­—æ®µæ–‡æœ¬
   * @returns {string} æ ‡å‡†åŒ–åçš„å­—æ®µå
   */
  static normalizeFieldName(fieldText) {
    // å»é™¤å¼€å¤´å’Œç»“å°¾çš„ç©ºæ ¼
    let normalized = fieldText.trim();
    
    // å¤„ç†å¤šä¸ªè¿ç»­çš„ä¸­æ–‡å†’å·
    normalized = normalized.replace(/ï¼š+/g, 'ï¼š');
    
    // å¦‚æœä»¥å†’å·ç»“å°¾ï¼Œå»æ‰å®ƒ
    if (normalized.endsWith('ï¼š') || normalized.endsWith(':')) {
      normalized = normalized.slice(0, -1);
    }
    
    return normalized;
  }

  /**
   * åˆå¹¶ä¸¤ä¸ªå¡ç‰‡ä¸­æŒ‡å®šå­—æ®µçš„å†…å®¹
   * @param {MNNote} targetNote - ç›®æ ‡å¡ç‰‡ï¼ˆå†…å®¹å°†åˆå¹¶åˆ°è¿™é‡Œï¼‰
   * @param {MNNote} sourceNote - æºå¡ç‰‡ï¼ˆä»è¿™é‡Œæå–å­—æ®µå†…å®¹ï¼‰
   * @param {string} fieldName - è¦åˆå¹¶çš„å­—æ®µåï¼ˆä¸åŒ…å«å†’å·ï¼‰
   * @returns {boolean} æˆåŠŸè¿”å› trueï¼Œå¤±è´¥è¿”å› false
   */
  static mergeSpecificField(targetNote, sourceNote, fieldName) {
    try {
      // 1. æ ‡å‡†åŒ–å­—æ®µå
      const normalizedFieldName = this.normalizeFieldName(fieldName);
      
      // 2. æ£€æŸ¥ä¸¤ä¸ªå¡ç‰‡æ˜¯å¦éƒ½æœ‰è¯¥å­—æ®µ
      const sourceHasField = sourceNote.getIncludingHtmlCommentIndex(normalizedFieldName) !== -1;
      const targetHasField = targetNote.getIncludingHtmlCommentIndex(normalizedFieldName) !== -1;
      
      if (!sourceHasField || !targetHasField) {
        MNUtil.showHUD(`ä¸¤ä¸ªå¡ç‰‡éƒ½éœ€è¦åŒ…å«å­—æ®µ"${normalizedFieldName}"`);
        return false;
      }
      
      // 3. è®°å½•ç›®æ ‡å¡ç‰‡åˆå¹¶å‰çš„è¯„è®ºæ•°
      const beforeCount = targetNote.comments.length;
      
      // 4. ä½¿ç”¨ undoGrouping åŒ…è£…æ‰€æœ‰æ“ä½œ
      MNUtil.undoGrouping(() => {
        // 5. ä¿ç•™æºå¡ç‰‡ä¸­æŒ‡å®šå­—æ®µçš„å†…å®¹
        this.retainFieldContentByName(sourceNote, normalizedFieldName);
        
        // 6. æ¸…ç©ºæºå¡ç‰‡æ ‡é¢˜å¹¶åˆå¹¶åˆ°ç›®æ ‡å¡ç‰‡
        sourceNote.noteTitle = "";
        sourceNote.mergeInto(targetNote);
        
        // 7. è®¡ç®—æ–°å†…å®¹çš„ç´¢å¼•ï¼ˆä» beforeCount å¼€å§‹ï¼‰
        const newContentCount = targetNote.comments.length - beforeCount;
        const newIndices = Array.from({length: newContentCount}, (_, i) => beforeCount + i);
        
        // 8. å°†æ–°å†…å®¹ç§»åŠ¨åˆ°ç›®æ ‡å­—æ®µä½ç½®
        this.moveCommentsArrToField(targetNote, newIndices, normalizedFieldName, true);
        
        // 9. åˆ·æ–°æ˜¾ç¤º
        targetNote.refresh();
      });
      
      MNUtil.showHUD(`âœ… å·²åˆå¹¶å­—æ®µ"${normalizedFieldName}"çš„å†…å®¹`);
      
      MNUtil.log({
        level: "info",
        message: `å­—æ®µåˆå¹¶å®Œæˆ - å­—æ®µï¼š${normalizedFieldName}ï¼Œæ–°å¢å†…å®¹ï¼š${targetNote.comments.length - beforeCount} æ¡`,
        source: "MNMath.mergeSpecificField"
      });
      
      return true;
      
    } catch (error) {
      MNUtil.showHUD(`âŒ åˆå¹¶å­—æ®µå¤±è´¥: ${error.message}`);
      MNUtil.log({
        level: "error",
        message: `åˆå¹¶å­—æ®µå¤±è´¥: ${error.message}`,
        source: "MNMath.mergeSpecificField"
      });
      return false;
    }
  }
  
  /**
   * å»ºç«‹å­—æ®µæ˜ å°„å…³ç³»
   * 
   * @param {string} sourceType - æºå¡ç‰‡ç±»å‹
   * @param {string} targetType - ç›®æ ‡å¡ç‰‡ç±»å‹
   * @returns {Object} å­—æ®µæ˜ å°„è¡¨
   */
  static buildFieldMapping(sourceType, targetType) {
    const mapping = {};
    
    // ç‰¹æ®Šå¤„ç†ï¼šæ€æƒ³æ–¹æ³• -> å‘½é¢˜
    if (sourceType === 'æ€æƒ³æ–¹æ³•' && targetType === 'å‘½é¢˜') {
      mapping['åŸç†'] = 'è¯æ˜';
    }
    
    // åç»­å¯ä»¥æ·»åŠ æ›´å¤šç‰¹æ®Šæ˜ å°„è§„åˆ™
    
    return mapping;
  }

  /**
   * ä¿®æ”¹å¡ç‰‡é¢œè‰²
   */
  static changeNoteColor(note, inputType = null) {
    if (inputType && this.types[inputType]) {
      note.colorIndex = this.types[inputType].colorIndex;
    } else {
      note.colorIndex = this.types[this.getNoteType(note)].colorIndex;
    }
  }

  /**
   * å…‹éš†å¹¶åˆå¹¶
   */
  static cloneAndMergeById(note, id){
    let clonedNote = MNNote.clone(id)
    note.merge(clonedNote.note)
  }

  /**
   * è‡ªåŠ¨è·å–å¹¶è¿”å›å½“å‰å¡ç‰‡çš„å¾…ç§»åŠ¨å†…å®¹çš„ indexArr
   * 
   * 
   * @param {MNNote} note - å½“å‰å¡ç‰‡
   */
  static autoGetNewContentToMoveIndexArr(note) {
    let moveIndexArr = []
    let lastHtmlCommentText = this.parseNoteComments(note).htmlCommentsTextArr.slice(-1)[0] || "";
    
    if (lastHtmlCommentText) {
      // å¦‚æœæœ‰HTMLè¯„è®ºï¼Œç§»åŠ¨HTMLè¯„è®ºä¸­çš„éé“¾æ¥å†…å®¹
      moveIndexArr = this.getHtmlBlockNonLinkContentIndexArr(note, lastHtmlCommentText);
    } else {
      // å¦‚æœæ²¡æœ‰HTMLè¯„è®ºï¼Œè·³è¿‡å¼€å¤´è¿ç»­çš„åˆå¹¶å›¾ç‰‡è¯„è®ºï¼Œä»ç¬¬ä¸€ä¸ªéåˆå¹¶å›¾ç‰‡è¯„è®ºå¼€å§‹ç§»åŠ¨
      let firstNonMergedImageIndex = -1;
      
      // ä»æ‰€æœ‰è¯„è®ºçš„å¼€å¤´å¼€å§‹æŸ¥æ‰¾ç¬¬ä¸€ä¸ªéåˆå¹¶å›¾ç‰‡è¯„è®º
      for (let i = 0; i < note.MNComments.length; i++) {
        let comment = note.MNComments[i];
        // æ£€æŸ¥æ˜¯å¦ä¸ºåˆå¹¶çš„å›¾ç‰‡è¯„è®ºç±»å‹ï¼ˆåŒ…æ‹¬å¸¦ç»˜åˆ¶å’Œä¸å¸¦ç»˜åˆ¶çš„ï¼‰
        if (comment.type !== "mergedImageComment" && comment.type !== "mergedImageCommentWithDrawing") {
          firstNonMergedImageIndex = i;
          break;
        }
      }
      
      if (firstNonMergedImageIndex !== -1) {
        // ä»ç¬¬ä¸€ä¸ªéåˆå¹¶å›¾ç‰‡è¯„è®ºåˆ°æ‰€æœ‰è¯„è®ºçš„ç»“å°¾ä½œä¸ºæ–°å†…å®¹
        moveIndexArr = Array.from({length: note.MNComments.length - firstNonMergedImageIndex}, (_, i) => i + firstNonMergedImageIndex);
      } else {
        // å¦‚æœæ‰€æœ‰è¯„è®ºéƒ½æ˜¯åˆå¹¶å›¾ç‰‡è¯„è®ºï¼Œåˆ™æ–°å†…å®¹ä¸ºç©º
        moveIndexArr = [];
      }
    }

    return moveIndexArr;
  }


  /**
   * å¢åŠ æ€è·¯å¡ç‰‡
   * 
   * @param {MNNote} note - å½“å‰å¡ç‰‡
   * @param {string} title - æ€è·¯å¡ç‰‡çš„æ ‡é¢˜
   */
  static addNewIdeaNote(note, title) {
    // ç”Ÿæˆå¡ç‰‡
    let ideaNote = MNNote.clone(this.types.æ€è·¯.templateNoteId);
    
    // å¤„ç†æ ‡é¢˜
    let prefixContent = this.createChildNoteTitlePrefixContent(note);
    
    // å¦‚æœçˆ¶å¡ç‰‡ä¹Ÿæ˜¯æ€è·¯å¡ç‰‡ï¼Œä½¿ç”¨ ğŸ’¡ å’Œçˆ¶å¡ç‰‡å†…å®¹
    if (this.getNoteType(note) === "æ€è·¯") {
      // è·å–çˆ¶å¡ç‰‡çš„ content éƒ¨åˆ†
      let parentTitleParts = this.parseNoteTitle(note);
      
      // åœ¨å‰ç¼€å†…å®¹ååŠ å…¥ ğŸ’¡ å’Œçˆ¶å¡ç‰‡å†…å®¹
      prefixContent = prefixContent + "ï½œğŸ’¡ " + parentTitleParts.content;
    }
    
    ideaNote.title = this.createTitlePrefix(this.types.æ€è·¯.prefixName, prefixContent) + title;
    
    // è®¾ç½®å®Œæ ‡é¢˜åå†æ·»åŠ ä¸ºå­å¡ç‰‡
    note.addChild(ideaNote);
    
    // å¤„ç†é“¾æ¥å’Œè¯„è®º - è¯„è®ºå†…å®¹ä¿æŒåŸæ ·ï¼Œä¸åšç‰¹æ®Šå¤„ç†
    note.appendMarkdownComment(HtmlMarkdownUtils.createHtmlMarkdownText(title, "idea"));  // åŠ å…¥æ€è·¯ htmlMD
    note.appendNoteLink(ideaNote, "Both");  // åŒå‘é“¾æ¥
    this.moveCommentsArrToField(note, "Y, Z", this.getIdeaLinkMoveToField(note));  // ç§»åŠ¨ note çš„ä¸¤ä¸ªè¯„è®º

    // å»¶è¿Ÿèšç„¦ï¼Œç¡®ä¿æ‰€æœ‰æ“ä½œå®Œæˆåå†å®šä½
    MNUtil.delay(0.5).then(() => {
      if (MNUtil.mindmapView) {
        ideaNote.focusInMindMap(0.3)
      }
    })
  }

  /**
   * å¢åŠ æ€»ç»“å¡ç‰‡
   * 
   * @param {MNNote} note - å½“å‰å¡ç‰‡
   * @param {string} title - æ€»ç»“å¡ç‰‡çš„æ ‡é¢˜
   */
  static addNewSummaryNote(note, title) {
    // ç”Ÿæˆå¡ç‰‡
    let summaryNote = MNNote.clone(this.types.æ€»ç»“.templateNoteId);
    
    // å¤„ç†æ ‡é¢˜
    let prefixContent = this.createChildNoteTitlePrefixContent(note);
    summaryNote.title = this.createTitlePrefix(this.types.æ€»ç»“.prefixName, prefixContent) + title;
    
    // è®¾ç½®å®Œæ ‡é¢˜åå†æ·»åŠ ä¸ºå­å¡ç‰‡
    note.addChild(summaryNote);
    
    // å¤„ç†é“¾æ¥å’Œè¯„è®º
    note.appendMarkdownComment(HtmlMarkdownUtils.createHtmlMarkdownText(title, "remark"));  // ä½¿ç”¨ remark æ ·å¼
    note.appendNoteLink(summaryNote, "Both");  // åŒå‘é“¾æ¥
    
    // æ ¹æ®çˆ¶å¡ç‰‡ç±»å‹å†³å®šç§»åŠ¨åˆ°å“ªä¸ªå­—æ®µ
    let targetField = this.getNoteType(note) === "æ€»ç»“" ? "è¦ç‚¹åˆ—ä¸¾" : "ç›¸å…³æ€è€ƒ";
    this.moveCommentsArrToField(note, "Y, Z", targetField);  // ç§»åŠ¨åˆ°å¯¹åº”å­—æ®µ
    
    // åœ¨æ€»ç»“å¡ç‰‡ä¸­ï¼Œå°†çˆ¶å¡ç‰‡çš„é“¾æ¥ç§»åŠ¨åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ
    // åŒå‘é“¾æ¥ä¼šåœ¨æ€»ç»“å¡ç‰‡çš„æœ€åä½ç½®åˆ›å»ºçˆ¶å¡ç‰‡çš„é“¾æ¥
    this.moveCommentsArrToField(summaryNote, "Z", "ç›¸å…³é“¾æ¥");
    
    // å»¶è¿Ÿèšç„¦ï¼Œç¡®ä¿æ‰€æœ‰æ“ä½œå®Œæˆåå†å®šä½
    MNUtil.delay(0.5).then(() => {
      if (MNUtil.mindmapView) {
        summaryNote.focusInMindMap(0.3)
      }
    })
  }

  /**
   * å¢åŠ å®šä¹‰å¡ç‰‡
   * 
   * @param {MNNote} note - å½“å‰å¡ç‰‡ï¼ˆå‘½é¢˜æˆ–ä¾‹å­å¡ç‰‡ï¼‰
   * @param {string} title - å®šä¹‰å¡ç‰‡çš„æ ‡é¢˜
   */
  static addNewDefinitionNote(note, title) {
    // æ£€æŸ¥çˆ¶å¡ç‰‡ç±»å‹
    const supportedParentTypes = ["å‘½é¢˜", "ä¾‹å­"];
    const parentType = this.getNoteType(note);
    
    if (!supportedParentTypes.includes(parentType)) {
      MNUtil.showHUD("åªèƒ½åœ¨å‘½é¢˜æˆ–ä¾‹å­å¡ç‰‡ä¸Šç”Ÿæˆå®šä¹‰å¡ç‰‡");
      return;
    }
    
    // ç”Ÿæˆå®šä¹‰å¡ç‰‡
    let definitionNote = MNNote.clone(this.types.å®šä¹‰.templateNoteId);
    
    // å¤„ç†æ ‡é¢˜
    let prefixContent = this.createChildNoteTitlePrefixContent(note);
    definitionNote.title = this.createTitlePrefix(this.types.å®šä¹‰.prefixName, prefixContent) + "; " + title;
    
    // è®¾ç½®å®Œæ ‡é¢˜åå†æ·»åŠ ä¸ºå­å¡ç‰‡
    note.addChild(definitionNote);
    
    // å¤„ç†é“¾æ¥ï¼ˆä¸éœ€è¦æ·»åŠ  markdown è¯„è®ºï¼‰
    note.appendNoteLink(definitionNote, "Both");  // åŒå‘é“¾æ¥
    
    // åœ¨çˆ¶å¡ç‰‡ï¼ˆå‘½é¢˜/ä¾‹å­ï¼‰ä¸­ï¼Œç§»åŠ¨å®šä¹‰å¡ç‰‡çš„é“¾æ¥åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ
    this.moveCommentsArrToField(note, "Z", "ç›¸å…³é“¾æ¥");  // åªç§»åŠ¨æœ€åä¸€ä¸ªè¯„è®ºï¼ˆé“¾æ¥ï¼‰
    
    // å®šä¹‰å¡ç‰‡çš„ç›¸å…³é“¾æ¥æœ¬èº«å°±åœ¨æœ€åï¼Œæ— éœ€ç§»åŠ¨
    
    // å»¶è¿Ÿèšç„¦ï¼Œç¡®ä¿æ‰€æœ‰æ“ä½œå®Œæˆåå†å®šä½
    MNUtil.delay(0.5).then(() => {
      if (MNUtil.mindmapView) {
        definitionNote.focusInMindMap(0.3)
      }
    })
  }

  static createChildNoteWithTitle(note, title, colorIndex = note.colorIndex) {
    let config = {
      title: title,
      content: "",
      markdown: true,
      color: colorIndex
    }
    // åˆ›å»ºæ–°å…„å¼Ÿå¡ç‰‡ï¼Œæ ‡é¢˜ä¸ºæ—§å¡ç‰‡çš„æ ‡é¢˜
    return note.createChildNote(config)
  }

  /**
   * åŸºäº note çš„æ ‡é¢˜ç”Ÿæˆä¸¤å¼ åŒæ ‡é¢˜çš„å¡ç‰‡
   * 
   * åœºæ™¯ï¼šnote æ˜¯ä¸€ä¸ªâ€œç­‰ä»·åˆ»ç”»/å……è¦æ¡ä»¶â€å‘½é¢˜ï¼Œéœ€è¦ç”Ÿæˆå……åˆ†æ€§å’Œå¿…è¦æ€§ä¸¤ä¸ªå¡ç‰‡
   *   
   * @param {MNNote} note 
   */
  static createEquivalenceNotes(note) {
    MNUtil.undoGrouping(()=>{
      try {
        let sufficiencyNote = MNNote.clone(this.types.å‘½é¢˜.templateNoteId);
        let neccessaryNote = MNNote.clone(this.types.å‘½é¢˜.templateNoteId);

        sufficiencyNote.title = this.getFirstTitleLinkWord(note)
        neccessaryNote.title = this.getFirstTitleLinkWord(note)

        sufficiencyNote.colorIndex = this.types.å‘½é¢˜.colorIndex
        neccessaryNote.colorIndex = this.types.å‘½é¢˜.colorIndex

        sufficiencyNote.appendMarkdownComment("- [é€†å‘½é¢˜](" + neccessaryNote.noteURL + ")ä¹Ÿæˆç«‹: [ç­‰ä»·åˆ»ç”»](" + note.noteURL + ")")
        neccessaryNote.appendMarkdownComment("- [é€†å‘½é¢˜](" + sufficiencyNote.noteURL + ")ä¹Ÿæˆç«‹: [ç­‰ä»·åˆ»ç”»](" + note.noteURL + ")")
        this.autoMoveNewContentToField(sufficiencyNote, "ç›¸å…³æ€è€ƒ", true, false)
        this.autoMoveNewContentToField(neccessaryNote, "ç›¸å…³æ€è€ƒ", true, false)

        note.appendNoteLink(sufficiencyNote, "To")
        note.appendNoteLink(neccessaryNote, "To")

        this.moveCommentsArrToField(note, "Y, Z", "è¯æ˜")

        note.addChild(sufficiencyNote)
        note.addChild(neccessaryNote)
      } catch (error) {
        MNUtil.showHUD(error);
      }
    })
  }

  /**
   * æ ¹æ®å¡ç‰‡ç±»å‹ç¡®å®šæ€è·¯é“¾æ¥å†…å®¹è¦ç§»åŠ¨åˆ°å“ªä¸ªå­—æ®µä¸‹
   */
  static getIdeaLinkMoveToField(note) {
    switch (this.getNoteType(note)) {
      case "å‘½é¢˜":
      case "ä¾‹å­":
        return "è¯æ˜"
      case "åä¾‹":
        return "åä¾‹"
      case "æ€æƒ³æ–¹æ³•":
        return "åŸç†"
      case "é—®é¢˜":
        return "ç ”ç©¶æ€è·¯"
      case "æ€è·¯":
        return "å…·ä½“å°è¯•"
      default:
        break;
    }
  }

  /**
   * ç”Ÿæˆæ ‡é¢˜å‰ç¼€
   */
  static createTitlePrefix(prefixName, content) {
    return `ã€${prefixName} >> ${content}ã€‘`;
  }

  /**
   * è·å–å¡ç‰‡ç±»å‹
   *
   * @param {MNNote} note - è¦åˆ¤æ–­ç±»å‹çš„å¡ç‰‡
   * @param {boolean} directly - æ˜¯å¦åªåŸºäºå¡ç‰‡è‡ªèº«æ ‡é¢˜åˆ¤æ–­ï¼ˆä¸å‘ä¸ŠæŸ¥æ‰¾ï¼‰
   * @param {boolean} bycolor - directly = true æ—¶æ˜¯å¦é€šè¿‡é¢œè‰²åˆ¤æ–­ï¼ˆä»…åœ¨ç›´æ¥åˆ¤æ–­å¤±è´¥æ—¶ä½¿ç”¨ï¼‰
   * @returns {string|undefined} å¡ç‰‡ç±»å‹
   */
  static getNoteType(note, directly = false, bycolor = true) {
    // é˜²å¾¡æ€§æ£€æŸ¥
    if (!note) {
      KnowledgeBaseUtils.log(`è¿”å› undefined åŸå› ï¼šæ— å¡ç‰‡`, "getNoteType");
      return undefined;
    }

    // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šæ£€æŸ¥ç¼“å­˜ï¼ˆä»…åœ¨é directly æ¨¡å¼ä¸‹ä½¿ç”¨ç¼“å­˜ï¼‰
    if (!directly && this.noteTypeCache.has(note)) {
      const cached = this.noteTypeCache.get(note);
      // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿˜æœ‰æ•ˆï¼ˆæ ‡é¢˜æœªå˜ï¼‰
      if (cached && cached.title === (note.title || "")) {
        return cached.type;
      }
    }

    let noteType = null;
    let title = note.title || "";
    let match
    let matchResult
    /**
     * å¦‚æœæ˜¯
     * "xxx"ï¼š"yyy"ç›¸å…³ zz
     * æˆ–è€…æ˜¯
     * "yyy"ç›¸å…³ zz
     * åˆ™æ˜¯å½’ç±»å¡ç‰‡
     */
    if (/^â€œ[^â€]*â€ï¼šâ€œ[^â€]*â€\s*ç›¸å…³[^â€œ]*$/.test(title) || /^â€œ[^â€]+â€\s*ç›¸å…³[^â€œ]*$/.test(title)) {
      noteType = "å½’ç±»"
    } else {
      /**
       * å¦‚æœæ˜¯
       * ã€xxï¼šyyã€‘zz
       * åˆ™æ ¹æ® xx ä½œä¸º prefixName åœ¨ types æœç´¢ç±»å‹
       */
      match = title.match(/^ã€(.{2,4})\s*(?:>>|ï¼š)\s*.*ã€‘(.*)/)
      if (match) {
        matchResult = match[1].trim();
      } else {
        match = title.match(/^ã€(.*)ã€‘(.*)/)
        if (match) {
          matchResult = match[1].trim();
        }
      }
      if (!matchResult && !directly) {
        // ä»æ ‡é¢˜åˆ¤æ–­ä¸äº†çš„è¯ï¼Œå°±ä»å¡ç‰‡çš„å½’ç±»å¡ç‰‡æ¥åˆ¤æ–­
        let classificationNote = this.getFirstClassificationParentNote(note);
        if (classificationNote) {
          let classificationNoteTitleParts = this.parseNoteTitle(classificationNote);
          matchResult = classificationNoteTitleParts.type;
        }
      }
      for (let typeKey in this.types) {
        let type = this.types[typeKey];
        if (type.prefixName === matchResult) {
          noteType = String(typeKey);
          break;
        }
      }
    }

    if (!noteType && directly) {
      // å¦‚æœè¿˜æ˜¯è·å–ä¸åˆ°çš„è¯ï¼Œå°±å°è¯•ç”¨é¢œè‰²åˆ¤æ–­
      if (bycolor) {
        noteType = this.getNoteTypeByColor(note.colorIndex);
      }
    }

    // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šå­˜å…¥ç¼“å­˜ï¼ˆä»…åœ¨é directly æ¨¡å¼ä¸‹ç¼“å­˜ï¼‰
    if (!directly && noteType) {
      this.noteTypeCache.set(note, {
        title: note.title || "",
        type: noteType
      });
    }

    return noteType || undefined;
  }

  /**
   * åˆ¤æ–­å¡ç‰‡è‡ªèº«æ˜¯å¦ä¸ºçŸ¥è¯†ç‚¹å¡ç‰‡ï¼ˆä¸å‘ä¸ŠæŸ¥æ‰¾ï¼‰
   * åªåŸºäºå¡ç‰‡è‡ªèº«çš„æ ‡é¢˜æ ¼å¼åˆ¤æ–­ï¼Œä¸ä¼šæŸ¥æ‰¾çˆ¶å¡ç‰‡
   * 
   * @param {MNNote} note - è¦åˆ¤æ–­çš„å¡ç‰‡
   * @returns {boolean} å¦‚æœå¡ç‰‡æ ‡é¢˜æœ¬èº«å°±æ˜¯çŸ¥è¯†ç‚¹æ ¼å¼è¿”å› trueï¼Œå¦åˆ™è¿”å› false
   */
  static isKnowledgeNote(note) {
    const title = note.noteTitle || note.title || "";
    // æ£€æŸ¥æ˜¯å¦æœ‰çŸ¥è¯†ç‚¹å¡ç‰‡çš„æ ‡é¢˜æ ¼å¼ï¼šã€ç±»å‹ï¼šxxxã€‘æˆ–ã€ç±»å‹ >> xxxã€‘
    const match = title.match(/^ã€(.{1,4})\s*(?:>>|ï¼š)\s*.*ã€‘/);
    if (!match) return false;
    
    const type = match[1].trim();
    // æ£€æŸ¥ç±»å‹æ˜¯å¦åœ¨çŸ¥è¯†ç‚¹ç±»å‹åˆ—è¡¨ä¸­
    for (let typeKey in this.types) {
      if (this.types[typeKey].prefixName === type && 
          this.knowledgeNoteTypes.includes(typeKey)) {
        return true;
      }
    }
    return false;
  }

  /**
   * åˆ¤æ–­å¡ç‰‡è‡ªèº«æ˜¯å¦ä¸ºå½’ç±»å¡ç‰‡ï¼ˆä¸å‘ä¸ŠæŸ¥æ‰¾ï¼‰
   * åªåŸºäºå¡ç‰‡è‡ªèº«çš„æ ‡é¢˜æ ¼å¼åˆ¤æ–­ï¼Œä¸ä¼šæŸ¥æ‰¾çˆ¶å¡ç‰‡
   * 
   * @param {MNNote} note - è¦åˆ¤æ–­çš„å¡ç‰‡
   * @returns {boolean} å¦‚æœå¡ç‰‡æ ‡é¢˜æœ¬èº«å°±æ˜¯å½’ç±»æ ¼å¼è¿”å› trueï¼Œå¦åˆ™è¿”å› false
   */
  static isClassificationNote(note) {
    const title = note.noteTitle || note.title || "";
    // æ£€æŸ¥æ˜¯å¦æœ‰å½’ç±»å¡ç‰‡çš„æ ‡é¢˜æ ¼å¼ï¼š"xxx"ç›¸å…³ æˆ– "xxx"ï¼š"xxx"ç›¸å…³
    return /^â€œ[^â€œ]*â€ï¼šâ€œ[^â€œ]*â€\s*ç›¸å…³.*$/.test(title) || 
           /^â€œ[^â€œ]+â€\s*ç›¸å…³.*$/.test(title);
  }

  /**
   * åŸºäºå¡ç‰‡æ ‡é¢˜ç”Ÿæˆå­å¡ç‰‡å‰ç¼€å†…å®¹
   */
  static createChildNoteTitlePrefixContent(note) {
    let titleParts = this.parseNoteTitle(note);
    let noteType = this.getNoteType(note);
    
    switch (noteType) {
      case 'å½’ç±»':
        return titleParts.content;
      case 'é—®é¢˜':
        // é—®é¢˜å¡ç‰‡çš„å­æ€è·¯å‰é¢åŠ ä¸Š â“ å¼ºè°ƒè¿™æ˜¯é’ˆå¯¹é—®é¢˜çš„æ€è·¯
        return titleParts.prefixContent + "ï½œâ“" + titleParts.content;
      case 'æ€è·¯':
        // æ€è·¯å¡ç‰‡çš„å­æ€è·¯åªè¿”å› prefixContentï¼Œå…·ä½“å¤„ç†åœ¨ addNewIdeaNote ä¸­
        return titleParts.prefixContent;
      default:
        return titleParts.prefixContent + "ï½œ" + titleParts.content;
    }
  }

  /**
   * è§£æå¡ç‰‡æ ‡é¢˜ï¼Œæå–ç»“æ„åŒ–ä¿¡æ¯
   *
   * è¯¥æ–¹æ³•æ ¹æ®ä¸åŒçš„å¡ç‰‡ç±»å‹ï¼ˆå½’ç±» vs å…¶ä»–ç±»å‹ï¼‰ï¼Œä½¿ç”¨ä¸åŒçš„æ­£åˆ™è¡¨è¾¾å¼è§£ææ ‡é¢˜æ ¼å¼ï¼Œ
   * å¹¶æå–å‡ºç±»å‹ã€å‰ç¼€å†…å®¹ã€ä¸»å†…å®¹å’Œæ ‡é¢˜é“¾æ¥è¯æ•°ç»„ç­‰ç»“æ„åŒ–ä¿¡æ¯ã€‚
   *
   * @param {MNNote} note - è¦è§£æçš„å¡ç‰‡å¯¹è±¡
   *
   * @returns {Object} è§£æåçš„æ ‡é¢˜ç»“æ„å¯¹è±¡ï¼ŒåŒ…å«ä»¥ä¸‹å¯èƒ½çš„å±æ€§ï¼š
   * @returns {string} [returns.type] - å¡ç‰‡ç±»å‹ï¼ˆä»æ ‡é¢˜å‰ç¼€ã€ã€‘ä¸­æå–ï¼‰
   * @returns {string} [returns.prefixContent] - å‰ç¼€å†…å®¹ï¼ˆã€ç±»å‹>>å‰ç¼€å†…å®¹ã€‘ä¸­çš„å‰ç¼€éƒ¨åˆ†ï¼‰
   * @returns {string} [returns.content] - ä¸»è¦å†…å®¹ï¼ˆæ ‡é¢˜çš„æ ¸å¿ƒå†…å®¹éƒ¨åˆ†ï¼‰
   * @returns {string[]} [returns.titleLinkWordsArr] - æ ‡é¢˜é“¾æ¥è¯æ•°ç»„ï¼ˆä»¥ "; " åˆ†å‰²çš„è¯ç»„ï¼‰
   *
   * @description
   * ### æ”¯æŒçš„æ ‡é¢˜æ ¼å¼ï¼š
   *
   * #### 1. å½’ç±»å¡ç‰‡æ ¼å¼
   * - **æ ¼å¼1**: `"xxx"ï¼š"yyy"ç›¸å…³ zzz`
   *   - `content`: "yyy"
   *   - `type`: "zzz"
   * - **æ ¼å¼2**: `"xxx"ç›¸å…³ yyy`
   *   - `content`: "xxx"
   *   - `type`: "yyy"
   *
   * #### 2. å…¶ä»–ç±»å‹å¡ç‰‡æ ¼å¼
   * - **æ ¼å¼1**: `ã€ç±»å‹ >> å‰ç¼€å†…å®¹ã€‘ä¸»å†…å®¹; é“¾æ¥è¯1; é“¾æ¥è¯2`
   *   - `type`: "ç±»å‹"
   *   - `prefixContent`: "å‰ç¼€å†…å®¹"
   *   - `content`: "ä¸»å†…å®¹; é“¾æ¥è¯1; é“¾æ¥è¯2"
   *   - `titleLinkWordsArr`: ["ä¸»å†…å®¹", "é“¾æ¥è¯1", "é“¾æ¥è¯2"]
   *
   * - **æ ¼å¼2**: `ã€ç±»å‹ï¼šå‰ç¼€å†…å®¹ã€‘ä¸»å†…å®¹; é“¾æ¥è¯1; é“¾æ¥è¯2`ï¼ˆä½¿ç”¨ä¸­æ–‡å†’å·ï¼‰
   *   - è§£æè§„åˆ™åŒä¸Š
   *
   * - **æ ¼å¼3**: `ã€ç±»å‹ã€‘ä¸»å†…å®¹; é“¾æ¥è¯1; é“¾æ¥è¯2`ï¼ˆæ— å‰ç¼€å†…å®¹ï¼‰
   *   - `type`: "ç±»å‹"
   *   - `prefixContent`: ""
   *   - `content`: "ä¸»å†…å®¹; é“¾æ¥è¯1; é“¾æ¥è¯2"ï¼ˆä¼šå»é™¤å¼€å¤´çš„ "; " å¦‚æœå­˜åœ¨ï¼‰
   *   - `titleLinkWordsArr`: ["ä¸»å†…å®¹", "é“¾æ¥è¯1", "é“¾æ¥è¯2"]
   *
   * - **æ ¼å¼4**: çº¯æ–‡æœ¬ï¼ˆæ— ä»»ä½•æ ‡è®°ï¼‰
   *   - `content`: "åŸå§‹æ ‡é¢˜å†…å®¹"
   *   - `titleLinkWordsArr`: æŒ‰ "; " åˆ†å‰²çš„è¯ç»„æ•°ç»„
   *
   * @example
   * // å½’ç±»å¡ç‰‡
   * let note1 = { title: '"å®šä¹‰"ï¼š"æ‹“æ‰‘ç©ºé—´"ç›¸å…³ å½’ç±»' };
   * let result1 = parseNoteTitle(note1);
   * // => { content: "æ‹“æ‰‘ç©ºé—´", type: "å½’ç±»" }
   *
   * @example
   * // å¸¦å‰ç¼€çš„æ ‡å‡†æ ¼å¼
   * let note2 = { title: 'ã€å‘½é¢˜>>ç´§æ€§ã€‘ç´§ç©ºé—´çš„è¿ç»­åƒæ˜¯ç´§çš„; ç´§æ€§; è¿ç»­æ˜ å°„' };
   * let result2 = parseNoteTitle(note2);
   * // => {
   * //   type: "å‘½é¢˜",
   * //   prefixContent: "ç´§æ€§",
   * //   content: "ç´§ç©ºé—´çš„è¿ç»­åƒæ˜¯ç´§çš„; ç´§æ€§; è¿ç»­æ˜ å°„",
   * //   titleLinkWordsArr: ["ç´§ç©ºé—´çš„è¿ç»­åƒæ˜¯ç´§çš„", "ç´§æ€§", "è¿ç»­æ˜ å°„"]
   * // }
   *
   * @example
   * // æ— å‰ç¼€æ ¼å¼
   * let note3 = { title: 'ã€å®šä¹‰ã€‘åº¦é‡ç©ºé—´; è·ç¦»å‡½æ•°' };
   * let result3 = parseNoteTitle(note3);
   * // => {
   * //   type: "å®šä¹‰",
   * //   prefixContent: "",
   * //   content: "åº¦é‡ç©ºé—´; è·ç¦»å‡½æ•°",
   * //   titleLinkWordsArr: ["åº¦é‡ç©ºé—´", "è·ç¦»å‡½æ•°"]
   * // }
   *
   * @example
   * // çº¯æ–‡æœ¬æ ¼å¼
   * let note4 = { title: 'è¿™æ˜¯ä¸€ä¸ªæ™®é€šæ ‡é¢˜; å…³é”®è¯1; å…³é”®è¯2' };
   * let result4 = parseNoteTitle(note4);
   * // => {
   * //   content: "è¿™æ˜¯ä¸€ä¸ªæ™®é€šæ ‡é¢˜; å…³é”®è¯1; å…³é”®è¯2",
   * //   titleLinkWordsArr: ["è¿™æ˜¯ä¸€ä¸ªæ™®é€šæ ‡é¢˜", "å…³é”®è¯1", "å…³é”®è¯2"]
   * // }
   *
   * @example
   * // é˜²å¾¡æ€§æ£€æŸ¥
   * let result5 = parseNoteTitle(null);
   * // => {}
   *
   * @note
   * - è§£æå‰ä¼šè‡ªåŠ¨æ¸…ç†æ ‡é¢˜ä¸­çš„é«˜äº®æ ‡è®°ï¼ˆé€šè¿‡ `KnowledgeBaseIndexer.cleanHighlightMarkers`ï¼‰
   * - æ ‡é¢˜é“¾æ¥è¯é€šè¿‡ `; ` åˆ†å‰²ï¼Œç©ºè¯ä¼šè¢«è¿‡æ»¤æ‰
   * - å¯¹äºå½’ç±»å¡ç‰‡ï¼Œåªè§£æ `content` å’Œ `type`ï¼Œä¸è§£æ `titleLinkWordsArr`
   * - å¦‚æœä¼ å…¥çš„ note ä¸ºç©ºæˆ– nullï¼Œè¿”å›ç©ºå¯¹è±¡ `{}`
   *
   * @see {@link KnowledgeBaseIndexer.cleanHighlightMarkers} æ¸…ç†é«˜äº®æ ‡è®°çš„æ–¹æ³•
   * @see {@link getNoteType} è·å–å¡ç‰‡ç±»å‹çš„æ–¹æ³•
   */
  static parseNoteTitle(note) {
    // é˜²å¾¡æ€§æ£€æŸ¥
    if (!note) {
      return {};
    }

    // æ¸…ç†æ ‡é¢˜ä¸­çš„é«˜äº®æ ‡è®°
    let title = KnowledgeBaseIndexer.cleanHighlightMarkers(note.title || "");
    let titleParts = {}
    let match
    
    // è·å–å¡ç‰‡ç±»å‹æ—¶ä¼ é€’é˜²æŠ¤æ·±åº¦
    const noteType = this.getNoteType(note, false, 0);
    switch (noteType) {
      case "å½’ç±»":
        match = title.match(/^â€œ[^â€]+â€ï¼šâ€œ([^â€]+)â€\s*ç›¸å…³\s*(.*)$/);
        if (match) {
          titleParts.content = match[1].trim();
          titleParts.type = match[2].trim();
        } else {
          match = title.match(/^â€œ([^â€]+)â€\s*ç›¸å…³\s*(.*)$/);
          if (match) {
            titleParts.content = match[1].trim();
            titleParts.type = match[2].trim();
          }
        }
        break;
      default:
        match = title.match(/^ã€(.{2,4})\s*(?:>>|ï¼š)\s*(.*)ã€‘(.*)/)
        if (match) {
          titleParts.type = match[1].trim();
          titleParts.prefixContent = match[2].trim();
          titleParts.content = match[3].trim();
          // å¦‚æœ content ä»¥ `; ` å¼€å¤´ï¼Œåˆ™å»æ‰?
          // æš‚æ—¶ä¸å»æ‰ï¼Œå› ä¸ºåˆ¶å¡ä¼šæŠŠæ ‡é¢˜é“¾æ¥çš„ç¬¬ä¸€ä¸ªè¯å‰é¢çš„åˆ†å·å»æ‰
          // if (titleParts.content.startsWith("; ")) {
          //   titleParts.content = titleParts.content.slice(2).trim();
          // }
          titleParts.titleLinkWordsArr = titleParts.content.split(/; /).map(word => word.trim()).filter(word => word.length > 0);
        } else {
          match = title.match(/^ã€(.*)ã€‘(.*)/)
          if (match) {
            titleParts.type = match[1].trim();
            titleParts.prefixContent = ""
            titleParts.content = match[2].trim();
            // å¦‚æœ content ä»¥ `; ` å¼€å¤´ï¼Œåˆ™å»æ‰
            if (titleParts.content.startsWith("; ")) {
              titleParts.content = titleParts.content.slice(2).trim();
            }
            titleParts.titleLinkWordsArr = titleParts.content.split(/; /).map(word => word.trim()).filter(word => word.length > 0);
          } else {
            titleParts.content = title.trim();
            // å³ä½¿æ²¡æœ‰å‰ç¼€ä¹Ÿè¦è§£æé“¾æ¥è¯
            titleParts.titleLinkWordsArr = titleParts.content.split(/; /).map(word => word.trim()).filter(word => word.length > 0);
          }
        }
        break;
    }

    return titleParts
  }

  /**
   * è§£æå¡ç‰‡è¯„è®º
   * 
   * è¿”å›ä¸€ä¸ªå¯¹è±¡æ•°ç»„ commentsObjï¼ŒåŒ…å«ï¼š
   * htmlComment(ä½œä¸ºè¯„è®ºå­—æ®µåˆ†éš”) çš„è¯¦ç»†ä¿¡æ¯ : htmlCommentsObjArr
   * htmlComment(ä½œä¸ºè¯„è®ºå­—æ®µåˆ†éš”) çš„æ–‡æœ¬ä¿¡æ¯ : htmlCommentsTextArr
   * 
   */
  static parseNoteComments(note) {
    let commentsObj = {
      htmlCommentsObjArr: [],
      htmlCommentsTextArr: [],
      htmlMarkdownCommentsObjArr: [],
      htmlMarkdownCommentsTextArr: [],
      linksObjArr: [],
      linksURLArr: [],
    }
    let comments = note.MNComments

    /**
     * å¤„ç† htmlCommentsObjArr
     */
    // let includingFieldBlockIndexArr = []
    // let excludingFieldBlockIndexArr = []
    comments.forEach((comment, index) => {
      if (comment && comment.type == "HtmlComment") {
        commentsObj.htmlCommentsObjArr.push(
          {
            index: index, // HtmlComment æ‰€åœ¨å¡ç‰‡çš„è¯„è®ºä¸­çš„ index
            text: comment.text, // HtmlComment çš„å†…å®¹
            includingFieldBlockIndexArr: [], // åŒ…å«è¿™ä¸ªå­—æ®µæœ¬èº«çš„ä¸‹æ–¹ Block çš„ Index æ•°ç»„
            excludingFieldBlockIndexArr: [], // ä¸åŒ…å«è¿™ä¸ªå­—æ®µæœ¬èº«çš„ä¸‹æ–¹ Block çš„ Index æ•°ç»„
          }
        );
      }
    })

    // å› ä¸ºä¸Šé¢çš„å¾ªç¯è¿˜åœ¨éå†æ‰€æœ‰çš„ HtmlCommentsï¼Œæ‰€ä»¥ä¸èƒ½è·å–åˆ°ä¸‹ä¸€ä¸ªï¼Œæ‰€ä»¥è¦ç­‰åˆ°å…ˆéå†å®Œå†å¤„ç† Block 
    switch (commentsObj.htmlCommentsObjArr.length) {
      case 0:
        break;
      case 1:
        commentsObj.htmlCommentsObjArr[0].includingFieldBlockIndexArr = comments.map((comment, index) => index).filter(index => index >= commentsObj.htmlCommentsObjArr[0].index);
        commentsObj.htmlCommentsObjArr[0].excludingFieldBlockIndexArr = comments.map((comment, index) => index).filter(index => index > commentsObj.htmlCommentsObjArr[0].index);
        break;
      default:
        for (let i = 0; i < commentsObj.htmlCommentsObjArr.length; i++) {
          let currentHtmlComment = commentsObj.htmlCommentsObjArr[i];
          if (i === commentsObj.htmlCommentsObjArr.length - 1) {
            currentHtmlComment.includingFieldBlockIndexArr = comments.map((comment, index) => index).filter(index => index >= currentHtmlComment.index);
            currentHtmlComment.excludingFieldBlockIndexArr = comments.map((comment, index) => index).filter(index => index > currentHtmlComment.index);
          } else {
            let nextHtmlComment = commentsObj.htmlCommentsObjArr[i + 1];
            currentHtmlComment.includingFieldBlockIndexArr = comments.map((comment, index) => index).filter(index => index < nextHtmlComment.index && index >= currentHtmlComment.index);
            currentHtmlComment.excludingFieldBlockIndexArr = comments.map((comment, index) => index).filter(index => index < nextHtmlComment.index && index > currentHtmlComment.index);
          
          }
        }
        break
    }

    /**
     * å¤„ç† htmlCommentsTextArr
     */
    if (commentsObj.htmlCommentsObjArr.length > 0) {
      // commentsObj.htmlCommentsTextArr
      commentsObj.htmlCommentsObjArr.forEach(htmlComment => {
        commentsObj.htmlCommentsTextArr.push(htmlComment.text)
      })
    }

    /**
     * å¤„ç† htmlMarkdownCommentsObjArr
     */
    comments.forEach((comment, index) => {
      if (!comment) return; // è·³è¿‡ undefined æˆ– null çš„è¯„è®º
      let text = comment.text || ""
      let isHtmlMD = false
      let hasLeadingDash = false
      let cleanText = text
      
      // æ£€æŸ¥æ˜¯å¦æœ‰å‰å¯¼ "- "
      if (text.startsWith("- ")) {
        hasLeadingDash = true
        cleanText = text.substring(2) // å»æ‰ "- "
      }
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯ HtmlMarkdown è¯„è®º
      if (HtmlMarkdownUtils.isHtmlMDComment(cleanText)) {
        isHtmlMD = true
      }
      
      if (isHtmlMD) {
        let type = HtmlMarkdownUtils.getSpanType(cleanText)
        let content = HtmlMarkdownUtils.getSpanTextContent(cleanText)
        
        commentsObj.htmlMarkdownCommentsObjArr.push({
          index: index, // HtmlMarkdown è¯„è®ºæ‰€åœ¨å¡ç‰‡çš„è¯„è®ºä¸­çš„ index
          text: text, // åŸå§‹è¯„è®ºæ–‡æœ¬ï¼ˆåŒ…å«å¯èƒ½çš„ "- " å‰ç¼€ï¼‰
          cleanText: cleanText, // å»æ‰ "- " å‰ç¼€çš„æ–‡æœ¬
          type: type, // è¯„è®ºçš„ç±»å‹ï¼ˆå¦‚ 'goal', 'level1' ç­‰ï¼‰
          content: content, // è¯„è®ºçš„çº¯æ–‡æœ¬å†…å®¹ï¼ˆå»æ‰ HTML æ ‡ç­¾å’Œå›¾æ ‡ï¼‰
          hasLeadingDash: hasLeadingDash // æ˜¯å¦æœ‰å‰å¯¼ "- "
        })
      }
    })

    /**
     * å¤„ç† htmlMarkdownCommentsTextArr
     */
    if (commentsObj.htmlMarkdownCommentsObjArr.length > 0) {
      commentsObj.htmlMarkdownCommentsObjArr.forEach(htmlMDComment => {
        // åˆ›å»ºç”¨äºæ˜¾ç¤ºçš„æ–‡æœ¬ï¼Œæ ¼å¼ï¼š[ç±»å‹] å†…å®¹
        let displayText = `[${htmlMDComment.type}] ${htmlMDComment.content}`
        if (htmlMDComment.hasLeadingDash) {
          displayText = "- " + displayText
        }
        commentsObj.htmlMarkdownCommentsTextArr.push(displayText)
      })
    }


    /**
     * æ‰€æœ‰çš„é“¾æ¥ï¼ˆä¸åŒ…å«æ¦‚è¦ï¼‰
     */

    comments.forEach((comment, index) => {
      if (comment && comment.type === "linkComment") {
        commentsObj.linksObjArr.push({
          index: index, // linkComment æ‰€åœ¨å¡ç‰‡çš„è¯„è®ºä¸­çš„ index
          link: comment.text, // å…·ä½“çš„ link
        })
      }
    })

    commentsObj.linksObjArr.forEach(linkObj => {
      commentsObj.linksURLArr.push(linkObj.link)
    })

    return commentsObj
  }

  /**
   * é€šè¿‡å¼¹çª—æ¥ä¿®æ”¹è¯„è®ºç±»å‹æˆ–å°†æ™®é€šè¯„è®ºè½¬æ¢ä¸º HtmlMarkdown è¯„è®º
   */
  static changeHtmlMarkdownCommentTypeByPopup(note) {
    // 1. æ”¶é›†æ‰€æœ‰å¯è½¬æ¢çš„è¯„è®º
    const allConvertibleComments = [];

    note.MNComments.forEach((comment, index) => {
      if (!comment) return;

      // è·³è¿‡ç‰¹æ®Šç±»å‹ï¼šHtmlCommentï¼ˆå­—æ®µï¼‰å’Œ linkComment
      if (comment.type === 'HtmlComment' || comment.type === 'linkComment') {
        return;
      }

      let text = comment.text || "";
      let hasLeadingDash = text.startsWith("- ");
      let cleanText = hasLeadingDash ? text.substring(2) : text;

      if (HtmlMarkdownUtils.isHtmlMDComment(cleanText)) {
        // HtmlMarkdown è¯„è®º
        let type = HtmlMarkdownUtils.getSpanType(cleanText);
        let content = HtmlMarkdownUtils.getSpanTextContent(cleanText);

        allConvertibleComments.push({
          index: index,
          isHtmlMD: true,
          type: type,
          content: content,
          displayText: (hasLeadingDash ? "- " : "") + `[${type}] ${content}`,
          hasLeadingDash: hasLeadingDash
        });
      } else if (cleanText.trim()) {
        // æ™®é€šæ–‡æœ¬è¯„è®ºï¼ˆæ’é™¤ç©ºè¯„è®ºï¼‰
        let displayContent = cleanText.length > 30 ? cleanText.substring(0, 30) + "..." : cleanText;
        allConvertibleComments.push({
          index: index,
          isHtmlMD: false,
          content: cleanText,
          displayText: (hasLeadingDash ? "- " : "") + `[æ–‡æœ¬] ${displayContent}`,
          hasLeadingDash: hasLeadingDash
        });
      }
    });

    if (allConvertibleComments.length === 0) {
      MNUtil.showHUD("å½“å‰ç¬”è®°æ²¡æœ‰å¯è½¬æ¢çš„è¯„è®º");
      return;
    }

    // 2. æ˜¾ç¤ºè¯„è®ºé€‰æ‹©å¼¹çª—
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©è¦è½¬æ¢çš„è¯„è®º",
      "å¯ä»¥ä¿®æ”¹ HtmlMarkdown è¯„è®ºç±»å‹æˆ–å°†æ–‡æœ¬è¯„è®ºè½¬æ¢ä¸º HtmlMarkdown",
      0,
      "å–æ¶ˆ",
      allConvertibleComments.map(c => c.displayText),
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          return; // å–æ¶ˆ
        }

        let selectedComment = allConvertibleComments[buttonIndex - 1];

        // è·å–æ‰€æœ‰å¯ç”¨çš„ç±»å‹é€‰é¡¹
        let availableTypes = Object.keys(HtmlMarkdownUtils.icons);
        let typeDisplayTexts = availableTypes.map(type => `${HtmlMarkdownUtils.icons[type]} ${type}`);

        // 3. æ˜¾ç¤ºç±»å‹é€‰æ‹©å¼¹çª—
        let promptMessage = selectedComment.isHtmlMD
          ? `å½“å‰ç±»å‹ï¼š${HtmlMarkdownUtils.icons[selectedComment.type]} ${selectedComment.type}\n\nè¯·é€‰æ‹©è¦è½¬æ¢æˆçš„ç±»å‹ï¼š`
          : "è¿™æ˜¯ä¸€ä¸ªæ–‡æœ¬è¯„è®ºï¼Œè¯·é€‰æ‹©è¦è½¬æ¢æˆçš„ç±»å‹ï¼š";

        UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
          "é€‰æ‹©ç›®æ ‡ç±»å‹",
          promptMessage,
          0,
          "å–æ¶ˆ",
          typeDisplayTexts,
          (alert, typeButtonIndex) => {
            if (typeButtonIndex === 0) {
              return; // å–æ¶ˆ
            }

            let targetType = availableTypes[typeButtonIndex - 1];

            // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰ç±»å‹ç›¸åŒï¼ˆä»…å¯¹ HtmlMarkdown è¯„è®ºï¼‰
            if (selectedComment.isHtmlMD && targetType === selectedComment.type) {
              MNUtil.showHUD("ç›®æ ‡ç±»å‹ä¸å½“å‰ç±»å‹ç›¸åŒï¼Œæ— éœ€ä¿®æ”¹");
              return;
            }

            MNUtil.undoGrouping(() => {
              try {
                let targetComment = note.MNComments[selectedComment.index];
                let newHtmlMarkdownText;

                // 4. æ ¹æ®ç›®æ ‡ç±»å‹åˆ›å»ºè¯„è®º
                const numberedTypes = ['case', 'step'];
                if (numberedTypes.includes(targetType)) {
                  // ä½¿ç”¨å¸¦åºå·çš„åˆ›å»ºæ–¹æ³•
                  newHtmlMarkdownText = HtmlMarkdownUtils.createNumberedHtmlText(
                    selectedComment.content,
                    targetType,
                    null,  // number å‚æ•°ä¸º nullï¼Œè‡ªåŠ¨è®¡ç®—
                    note   // ä¼ å…¥ note ç”¨äºè‡ªåŠ¨è®¡ç®—åºå·
                  );
                } else {
                  // ä½¿ç”¨æ™®é€šåˆ›å»ºæ–¹æ³•
                  newHtmlMarkdownText = HtmlMarkdownUtils.createHtmlMarkdownText(
                    selectedComment.content,
                    targetType
                  );
                }

                // ä¿æŒå‰å¯¼ç ´æŠ˜å·
                if (selectedComment.hasLeadingDash) {
                  newHtmlMarkdownText = "- " + newHtmlMarkdownText;
                }

                // æ›´æ–°è¯„è®ºæ–‡æœ¬
                targetComment.text = newHtmlMarkdownText;

                MNUtil.showHUD(`âœ… å·²è½¬æ¢ä¸º ${targetType} ç±»å‹`);

              } catch (error) {
                MNUtil.showHUD("è½¬æ¢å¤±è´¥ï¼š" + error.toString());
              }
            });
          }
        );
      }
    );
  }

  /**
   * é€šè¿‡å¼¹çª—é€‰æ‹©å¹¶ä»…ä¿ç•™æŸä¸ªå­—æ®µä¸‹çš„å†…å®¹
   * åˆ é™¤å…¶ä»–æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬å­—æ®µæœ¬èº«ï¼‰
   * 
   * @param {MNNote} note - è¦æ“ä½œçš„ç¬”è®°å¯¹è±¡
   * 
   * @example
   * // å¼¹çª—è®©ç”¨æˆ·é€‰æ‹©è¦ä¿ç•™çš„å­—æ®µå†…å®¹
   * KnowledgeBaseTemplate.retainFieldContentOnly(note);
   */
  static retainFieldContentOnly(note, keepTitle = false) {
    let commentsObj = this.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    let htmlCommentsTextArr = commentsObj.htmlCommentsTextArr;
    
    if (htmlCommentsTextArr.length === 0) {
      MNUtil.showHUD("å½“å‰å¡ç‰‡æ²¡æœ‰å­—æ®µç»“æ„");
      return;
    }
    
    // åˆ›å»ºå­—æ®µé€‰æ‹©èœå•
    let fieldOptions = htmlCommentsTextArr.map(text => text.trim());
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©è¦ä¿ç•™å†…å®¹çš„å­—æ®µ",
      "ä»…ä¿ç•™è¯¥å­—æ®µä¸‹çš„å†…å®¹ï¼Œåˆ é™¤å…¶ä»–æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬å­—æ®µæœ¬èº«ï¼‰",
      0,  // æ™®é€šæ ·å¼
      "å–æ¶ˆ",
      fieldOptions,
      (_, buttonIndex) => {
        if (buttonIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
        
        let selectedFieldIndex = buttonIndex - 1; // buttonIndexä»1å¼€å§‹
        let selectedFieldObj = htmlCommentsObjArr[selectedFieldIndex];
        let selectedField = fieldOptions[selectedFieldIndex];
        
        // è·å–è¦ä¿ç•™çš„å†…å®¹ç´¢å¼•ï¼ˆä¸åŒ…æ‹¬å­—æ®µæœ¬èº«ï¼‰
        let retainIndices = selectedFieldObj.excludingFieldBlockIndexArr;
        
        if (retainIndices.length === 0) {
          MNUtil.showHUD(`å­—æ®µ"${selectedField}"ä¸‹æ²¡æœ‰å†…å®¹`);
          return;
        }
        
        // ç¡®è®¤å¯¹è¯æ¡†
        let confirmMessage = `ç¡®å®šåªä¿ç•™"${selectedField}"å­—æ®µä¸‹çš„ ${retainIndices.length} æ¡å†…å®¹å—ï¼Ÿ\n\nâš ï¸ æ­¤æ“ä½œå°†åˆ é™¤å…¶ä»–æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬å­—æ®µæ ‡é¢˜ï¼‰`;
        
        UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
          "ç¡®è®¤æ“ä½œ",
          confirmMessage,
          0,  // æ™®é€šæ ·å¼
          "å–æ¶ˆ",
          ["ç¡®å®šåˆ é™¤"],
          (_, confirmButtonIndex) => {
            if (confirmButtonIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
            
            MNUtil.undoGrouping(() => {
              try {
                // è·å–æ‰€æœ‰è¯„è®ºçš„ç´¢å¼•
                let allIndices = Array.from({length: note.comments.length}, (_, i) => i);
                
                // è®¡ç®—è¦åˆ é™¤çš„ç´¢å¼•ï¼ˆæ‰€æœ‰ç´¢å¼•å‡å»è¦ä¿ç•™çš„ç´¢å¼•ï¼‰
                let deleteIndices = allIndices.filter(index => !retainIndices.includes(index));
                
                // ä»åå‘å‰åˆ é™¤ï¼ˆé¿å…ç´¢å¼•å˜åŒ–é—®é¢˜ï¼‰
                deleteIndices.sort((a, b) => b - a);
                
                let deletedCount = 0;
                deleteIndices.forEach(index => {
                  note.removeCommentByIndex(index);
                  deletedCount++;
                });
                
                // åˆ·æ–°å¡ç‰‡æ˜¾ç¤º
                MNUtil.undoGrouping(()=>{
                  note.refresh();
                })

                if (!keepTitle) {
                  note.title = ""
                }
                
                MNUtil.showHUD(`å·²åˆ é™¤ ${deletedCount} æ¡å†…å®¹ï¼Œä¿ç•™äº†"${selectedField}"å­—æ®µä¸‹çš„ ${retainIndices.length} æ¡å†…å®¹`);
                
                MNUtil.log({
                  level: "info",
                  message: `ä¿ç•™å­—æ®µå†…å®¹æ“ä½œå®Œæˆ - å­—æ®µï¼š${selectedField}ï¼Œä¿ç•™ï¼š${retainIndices.length} æ¡ï¼Œåˆ é™¤ï¼š${deletedCount} æ¡`,
                  source: "KnowledgeBaseTemplate.retainFieldContentOnly"
                });
                
              } catch (error) {
                MNUtil.showHUD("æ“ä½œå¤±è´¥ï¼š" + error.toString());
                MNUtil.log({
                  level: "error",
                  message: "ä¿ç•™å­—æ®µå†…å®¹å¤±è´¥ï¼š" + error.message,
                  source: "KnowledgeBaseTemplate.retainFieldContentOnly"
                });
              }
            });
          }
        );
      }
    );
  }

  /**
   * ä»…ä¿ç•™æŒ‡å®šå­—æ®µä¸‹çš„å†…å®¹ï¼ˆä¸é€šè¿‡å¼¹çª—ï¼‰
   * åˆ é™¤å…¶ä»–æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬å­—æ®µæœ¬èº«ï¼‰
   *
   * @param {MNNote} note - è¦æ“ä½œçš„ç¬”è®°å¯¹è±¡
   * @param {string} fieldName - è¦ä¿ç•™å†…å®¹çš„å­—æ®µåç§°ï¼Œæ”¯æŒ"æ‘˜å½•åŒº"/"æ‘˜å½•"ä¿ç•™æ‘˜å½•åŒºå†…å®¹
   * @returns {boolean} æ“ä½œæ˜¯å¦æˆåŠŸ
   *
   * @example
   * // ä»…ä¿ç•™"è¯æ˜"å­—æ®µä¸‹çš„å†…å®¹
   * let success = KnowledgeBaseTemplate.retainFieldContentByName(note, "è¯æ˜");
   *
   * @example
   * // ä»…ä¿ç•™"ç›¸å…³é“¾æ¥"å­—æ®µä¸‹çš„å†…å®¹
   * KnowledgeBaseTemplate.retainFieldContentByName(note, "ç›¸å…³é“¾æ¥");
   *
   * @example
   * // ä»…ä¿ç•™æ‘˜å½•åŒºçš„å†…å®¹ï¼ˆç¬¬ä¸€ä¸ªå­—æ®µä¹‹å‰çš„ mergedImageCommentï¼‰
   * KnowledgeBaseTemplate.retainFieldContentByName(note, "æ‘˜å½•åŒº");
   * KnowledgeBaseTemplate.retainFieldContentByName(note, "æ‘˜å½•");
   */
  static retainFieldContentByName(note, fieldName) {
    let retainIndices = [];

    // ç‰¹æ®Šå¤„ç†ï¼šæ‘˜å½•åŒº
    if (fieldName === "æ‘˜å½•åŒº" || fieldName === "æ‘˜å½•") {
      retainIndices = this.getExcerptBlockIndexArr(note, true);

      if (retainIndices.length === 0) {
        // MNUtil.showHUD(`æ‘˜å½•åŒºæ²¡æœ‰å†…å®¹`);
        if (note.comments.length > 0 ) {
          note.removeCommentsByIndexArr(Array.from({length: note.comments.length}, (_, i) => i));
        }
        return true;
      }

      // æ‘˜å½•åŒºå¤„ç†é€»è¾‘ä¸å­—æ®µå¤„ç†ç›¸åŒï¼Œè·³åˆ°åé¢ç»Ÿä¸€å¤„ç†
    } else {
      // å¸¸è§„å­—æ®µå¤„ç†
      let commentsObj = this.parseNoteComments(note);
      let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;

      // æŸ¥æ‰¾æŒ‡å®šåç§°çš„å­—æ®µ
      let targetFieldObj = null;
      for (let fieldObj of htmlCommentsObjArr) {
        if (fieldObj.text.includes(fieldName)) {
          targetFieldObj = fieldObj;
          break;
        }
      }

      if (!targetFieldObj) {
        MNUtil.showHUD(`æœªæ‰¾åˆ°å­—æ®µ"${fieldName}"`);
        return false;
      }

      // è·å–è¦ä¿ç•™çš„å†…å®¹ç´¢å¼•ï¼ˆä¸åŒ…æ‹¬å­—æ®µæœ¬èº«ï¼‰
      retainIndices = targetFieldObj.excludingFieldBlockIndexArr;

      if (retainIndices.length === 0) {
        MNUtil.showHUD(`å­—æ®µ"${fieldName}"ä¸‹æ²¡æœ‰å†…å®¹`);
        return false;
      }
    }
    
    MNUtil.undoGrouping(() => {
      try {
        // è®¡ç®—è¦åˆ é™¤çš„å†…å®¹æ•°é‡
        let inverseIndices = this.getInverseCommentsIndexArr(note, retainIndices);
        let deletedCount = inverseIndices.length;

        note.removeCommentsByIndexArr(inverseIndices);

        // åˆ·æ–°å¡ç‰‡æ˜¾ç¤º
        note.refresh();

        MNUtil.showHUD(`å·²åˆ é™¤ ${deletedCount} æ¡å†…å®¹ï¼Œä¿ç•™äº†"${fieldName}"çš„ ${retainIndices.length} æ¡å†…å®¹`, 0.5);

        MNUtil.log({
          level: "info",
          message: `ä¿ç•™å­—æ®µå†…å®¹æ“ä½œå®Œæˆ - å­—æ®µï¼š${fieldName}ï¼Œä¿ç•™ï¼š${retainIndices.length} æ¡ï¼Œåˆ é™¤ï¼š${deletedCount} æ¡`,
          source: "KnowledgeBaseTemplate.retainFieldContentByName"
        });
        
      } catch (error) {
        MNUtil.showHUD("æ“ä½œå¤±è´¥ï¼š" + error.toString());
        MNUtil.log({
          level: "error",
          message: "ä¿ç•™å­—æ®µå†…å®¹å¤±è´¥ï¼š" + error.message,
          source: "KnowledgeBaseTemplate.retainFieldContentByName"
        });
        return false;
      }
    });
    
    return true;
  }

  /**
   * è·å– note çš„ indexArr çš„åé€‰ indexArr
   */
  static getInverseCommentsIndexArr(note, indexArr) {
    try {
      // è·å–æ‰€æœ‰è¯„è®ºçš„ç´¢å¼•
      let allIndices = Array.from({length: note.comments.length}, (_, i) => i);

      return allIndices.filter(index => !indexArr.includes(index));
    } catch (error) {
      MNUtil.showHUD("è·å–åé€‰ç´¢å¼•å¤±è´¥ï¼š" + error.toString());
    }
  }

  /**
   * æ›´æ–°åŒå‘é“¾æ¥
   * å°†å½“å‰å¡ç‰‡ä¸­çš„æŸä¸ªé“¾æ¥æ›¿æ¢ä¸ºå‰ªè´´æ¿ä¸­çš„æ–°é“¾æ¥ï¼Œå¹¶è‡ªåŠ¨å¤„ç†åŒå‘é“¾æ¥
   * 
   * @param {MNNote} note - å½“å‰å¡ç‰‡
   */
  static async updateBidirectionalLink(note) {
    try {
      // æ­¥éª¤1: è·å–å‰ªè´´æ¿ä¸­çš„æ–°é“¾æ¥
      let clipboardText = MNUtil.clipboardText.trim();
      let newLinkUrl = null;
      
      // ä½¿ç”¨ç°æœ‰ API åˆ¤æ–­å’Œè½¬æ¢
      if (clipboardText.isNoteIdorURL()) {
        newLinkUrl = clipboardText.toNoteURL();
      } else {
        MNUtil.showHUD("è¯·å…ˆå¤åˆ¶è¦æ›¿æ¢çš„å¡ç‰‡é“¾æ¥æˆ–ID");
        return;
      }
      
      // æ­¥éª¤2: è§£æå½“å‰ç¬”è®°çš„æ‰€æœ‰å­—æ®µå’Œé“¾æ¥
      const commentsObj = this.parseNoteComments(note);
      const htmlFields = commentsObj.htmlCommentsObjArr;
      const allLinks = commentsObj.linksObjArr;
      
      // æ£€æŸ¥æ˜¯å¦æœ‰é“¾æ¥
      if (allLinks.length === 0) {
        MNUtil.showHUD("å½“å‰ç¬”è®°æ²¡æœ‰é“¾æ¥");
        return;
      }
      
      let links = [];
      
      // æ­¥éª¤3: æ ¹æ®æ˜¯å¦æœ‰å­—æ®µå†³å®šå¤„ç†æ–¹å¼
      if (htmlFields.length > 0) {
        // æœ‰å­—æ®µæ—¶ï¼Œè®©ç”¨æˆ·é€‰æ‹©å¤„ç†æ–¹å¼
        const options = ["æŸ¥çœ‹æ‰€æœ‰é“¾æ¥", ...htmlFields.map(field => field.text)];
        const selectedIndex = await MNUtil.userSelect(
          "é€‰æ‹©æŸ¥çœ‹æ–¹å¼", 
          "é€‰æ‹©è¦æŸ¥æ‰¾é“¾æ¥çš„å­—æ®µï¼Œæˆ–æŸ¥çœ‹æ‰€æœ‰é“¾æ¥", 
          options
        );
        
        if (selectedIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
        
        if (selectedIndex === 1) {
          // æŸ¥çœ‹æ‰€æœ‰é“¾æ¥
          links = allLinks.map(linkObj => ({
            index: linkObj.index,
            url: linkObj.link,
            noteId: linkObj.link.toNoteId(),
            type: note.MNComments[linkObj.index].type
          }));
        } else {
          // é€‰æ‹©äº†ç‰¹å®šå­—æ®µ
          const selectedField = htmlFields[selectedIndex - 2];
          links = this.getLinksInField(note, selectedField);
          
          if (links.length === 0) {
            MNUtil.showHUD(`å­—æ®µ"${selectedField.text}"ä¸‹æ²¡æœ‰æ‰¾åˆ°é“¾æ¥`);
            return;
          }
        }
      } else {
        // æ²¡æœ‰å­—æ®µæ—¶ï¼Œç›´æ¥ä½¿ç”¨æ‰€æœ‰é“¾æ¥
        links = allLinks.map(linkObj => ({
          index: linkObj.index,
          url: linkObj.link,
          noteId: linkObj.link.toNoteId(),
          type: note.MNComments[linkObj.index].type
        }));
      }
      
      // æ­¥éª¤4: è·å–é“¾æ¥å¯¹åº”çš„ç¬”è®°æ ‡é¢˜ï¼ˆä½¿ç”¨ä¼˜åŒ–çš„æ˜¾ç¤ºæ ¼å¼ï¼‰
      const linkDisplayNames = await this.formatLinksForDisplay(links);
      
      // æ­¥éª¤5: è®©ç”¨æˆ·é€‰æ‹©è¦æ›¿æ¢çš„é“¾æ¥
      const selectedLinkIndex = await MNUtil.userSelect(
        "é€‰æ‹©è¦æ›¿æ¢çš„é“¾æ¥",
        `å°†æ›¿æ¢ä¸ºå‰ªè´´æ¿ä¸­çš„é“¾æ¥`,
        linkDisplayNames
      );
      
      if (selectedLinkIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
      
      const selectedLink = links[selectedLinkIndex - 1];
      
      // æ­¥éª¤6: æ‰§è¡Œæ›¿æ¢æ“ä½œ
      await this.performLinkReplacement(note, selectedLink, newLinkUrl);
      
    } catch (error) {
      MNUtil.showHUD("æ“ä½œå¤±è´¥ï¼š" + error.message);
      MNUtil.addErrorLog(error, "updateBidirectionalLink", { noteId: note.noteId });
    }
  }

  /**
   * è·å–å­—æ®µä¸­çš„é“¾æ¥
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Object} field - å­—æ®µå¯¹è±¡
   * @returns {Array} é“¾æ¥æ•°ç»„
   */
  static getLinksInField(note, field) {
    const fieldCommentIndices = field.excludingFieldBlockIndexArr;
    const links = [];
    
    for (const index of fieldCommentIndices) {
      const comment = note.MNComments[index];
      if (comment && comment.text) {
        const commentText = comment.text.trim();
        
        // ä½¿ç”¨ç°æœ‰ API åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ç¬”è®°é“¾æ¥
        if (commentText.isValidNoteURL()) {
          // æ£€æŸ¥æ˜¯å¦ä¸ºçº¯é“¾æ¥ï¼ˆä¸åœ¨ Markdown æ ¼å¼ä¸­ï¼‰
          if (!commentText.includes("](") && !commentText.includes("[")) {
            links.push({
              index: index,
              url: commentText,
              noteId: commentText.toNoteId(),
              type: comment.type
            });
          }
        }
      }
    }
    
    return links;
  }

  /**
   * æ ¼å¼åŒ–é“¾æ¥æ˜¾ç¤ºï¼ˆå¤ç”¨ removeBidirectionalLinks çš„é€»è¾‘ï¼‰
   * 
   * @param {Array} links - é“¾æ¥æ•°ç»„
   * @returns {Array<string>} æ ¼å¼åŒ–çš„æ˜¾ç¤ºåç§°æ•°ç»„
   */
  static async formatLinksForDisplay(links) {
    const linkDisplayNames = [];
    for (const link of links) {
      try {
        const targetNote = MNNote.new(link.noteId);
        if (targetNote) {
          const targetMNNote = MNNote.new(targetNote);
          const titleParts = this.parseNoteTitle(targetMNNote);
          
          // è·å–å†…å®¹éƒ¨åˆ†ï¼Œå¹¶å»æ‰å¯èƒ½çš„ "; " å‰ç¼€
          let content = titleParts.content || targetNote.noteTitle || "[æ— æ ‡é¢˜]";
          if (content.startsWith("; ")) {
            content = content.substring(2).trim();
          }
          
          // æ ¼å¼åŒ–æ˜¾ç¤ºï¼š[ç±»å‹] å†…å®¹
          const type = titleParts.type || "";
          const displayTitle = type ? `[${type}] ${content}` : content;
          
          linkDisplayNames.push(displayTitle);
        } else {
          linkDisplayNames.push(`[ç¬”è®°ä¸å­˜åœ¨: ${link.noteId.substring(0, 8)}...]`);
        }
      } catch (error) {
        linkDisplayNames.push(`[è·å–å¤±è´¥: ${link.noteId.substring(0, 8)}...]`);
      }
    }
    return linkDisplayNames;
  }

  /**
   * æ‰§è¡Œé“¾æ¥æ›¿æ¢
   * 
   * @param {MNNote} note - å½“å‰ç¬”è®°
   * @param {Object} oldLink - è¦æ›¿æ¢çš„æ—§é“¾æ¥
   * @param {string} newLinkUrl - æ–°é“¾æ¥URL
   */
  static async performLinkReplacement(note, oldLink, newLinkUrl) {
    const oldNoteId = oldLink.noteId;
    const newNoteId = newLinkUrl.toNoteId();
    
    MNUtil.undoGrouping(() => {
      // 1. æ›¿æ¢å½“å‰ç¬”è®°ä¸­çš„é“¾æ¥
      const comment = note.MNComments[oldLink.index];
      if (comment) {
        comment.text = newLinkUrl;
      }
      
      // 2. å¤„ç†æ—§é“¾æ¥çš„åå‘é“¾æ¥
      try {
        const oldTargetNote = MNNote.new(oldNoteId);
        if (oldTargetNote) {
          this.removeApplicationFieldLink(oldTargetNote, note.noteId);
        }
      } catch (error) {
        MNUtil.log("å¤„ç†æ—§é“¾æ¥åå‘é“¾æ¥æ—¶å‡ºé”™: " + error);
      }
      
      // 3. å¤„ç†æ–°é“¾æ¥çš„åå‘é“¾æ¥
      try {
        const newTargetNote = MNNote.new(newNoteId);
        if (newTargetNote) {
          this.addApplicationFieldLink(newTargetNote, note);
        }
      } catch (error) {
        MNUtil.log("å¤„ç†æ–°é“¾æ¥åå‘é“¾æ¥æ—¶å‡ºé”™: " + error);
      }
      
      MNUtil.showHUD("é“¾æ¥æ›¿æ¢æˆåŠŸ");
    });
  }

  /**
   * ä»åº”ç”¨å­—æ®µåˆ é™¤æŒ‡å®šé“¾æ¥
   * 
   * @param {Object} targetNote - ç›®æ ‡ç¬”è®°
   * @param {string} sourceNoteId - æºç¬”è®°ID
   */
  static removeApplicationFieldLink(targetNote, sourceNoteId) {
    const targetMNNote = MNNote.new(targetNote);
    const commentsObj = this.parseNoteComments(targetMNNote);
    const sourceNoteUrl = sourceNoteId.toNoteURL();
    
    // æŸ¥æ‰¾"åº”ç”¨"æˆ–"åº”ç”¨:"å­—æ®µ
    const applicationField = commentsObj.htmlCommentsObjArr.find(field => {
      const fieldText = field.text.trim();
      return fieldText === "åº”ç”¨" || fieldText === "åº”ç”¨:" || fieldText === "åº”ç”¨ï¼š";
    });
    
    if (applicationField) {
      // æœ‰"åº”ç”¨"å­—æ®µï¼šåœ¨å­—æ®µä¸­æŸ¥æ‰¾å¹¶åˆ é™¤é“¾æ¥
      const fieldIndices = applicationField.excludingFieldBlockIndexArr;
      
      // ä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–é—®é¢˜
      for (let i = fieldIndices.length - 1; i >= 0; i--) {
        const index = fieldIndices[i];
        const comment = targetMNNote.MNComments[index];
        if (comment && comment.text) {
          const commentText = comment.text.trim();
          if (commentText === sourceNoteUrl) {
            targetMNNote.removeCommentByIndex(index);
            return; // æ‰¾åˆ°å¹¶åˆ é™¤åç›´æ¥è¿”å›
          }
        }
      }
    }
    
    // æ²¡æœ‰"åº”ç”¨"å­—æ®µæˆ–åœ¨å­—æ®µä¸­æ²¡æ‰¾åˆ°ï¼šéå†æ‰€æœ‰è¯„è®ºæŸ¥æ‰¾é“¾æ¥
    const allComments = targetMNNote.MNComments;
    
    for (let i = allComments.length - 1; i >= 0; i--) {
      const comment = allComments[i];
      
      // è·³è¿‡ HTML å­—æ®µ
      if (comment && comment.type === "HtmlComment") {
        continue;
      }
      
      // åªå¤„ç†é“¾æ¥ç±»å‹çš„è¯„è®º
      if (comment && comment.type === "linkComment" && comment.text) {
        const commentText = comment.text.trim();
        
        // ä½¿ç”¨ includes è¿›è¡Œæ›´çµæ´»çš„åŒ¹é…ï¼ˆæ”¯æŒéƒ¨åˆ† URL åŒ¹é…ï¼‰
        if (commentText.isValidNoteURL() && 
            (commentText === sourceNoteUrl || commentText.includes(sourceNoteUrl.toNoteId()))) {
          targetMNNote.removeCommentByIndex(i);
          return; // æ‰¾åˆ°å¹¶åˆ é™¤åè¿”å›
        }
      }
    }
  }

  /**
   * å‘åº”ç”¨å­—æ®µæ·»åŠ é“¾æ¥ï¼ˆå¸¦å»é‡ï¼‰
   * 
   * @param {Object} targetNote - ç›®æ ‡ç¬”è®°
   * @param {MNNote} sourceNote - æºç¬”è®°
   */
  static addApplicationFieldLink(targetNote, sourceNote) {
    const targetMNNote = MNNote.new(targetNote);
    const commentsObj = this.parseNoteComments(targetMNNote);
    const sourceNoteUrl = sourceNote.noteId.toNoteURL();
    
    // æŸ¥æ‰¾"åº”ç”¨"å­—æ®µ
    const applicationField = commentsObj.htmlCommentsObjArr.find(field => {
      const fieldText = field.text.trim();
      return fieldText === "åº”ç”¨" || fieldText === "åº”ç”¨:" || fieldText === "åº”ç”¨ï¼š";
    });
    
    if (applicationField) {
      // æœ‰"åº”ç”¨"å­—æ®µï¼šæ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
      const fieldIndices = applicationField.excludingFieldBlockIndexArr;
      
      for (const index of fieldIndices) {
        const comment = targetMNNote.MNComments[index];
        if (comment && comment.text && comment.text.trim() === sourceNoteUrl) {
          // å·²å­˜åœ¨ï¼Œä¸éœ€è¦æ·»åŠ 
          return;
        }
      }
      
      // æ·»åŠ é“¾æ¥åˆ°å­—æ®µ
      targetMNNote.appendNoteLink(sourceNote, "To");
      
      // è°ƒç”¨å»é‡åŠŸèƒ½
      this.removeDuplicateLinksInLastField(targetMNNote);
    } else {
      // æ²¡æœ‰"åº”ç”¨"å­—æ®µï¼šå…ˆæ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥é“¾æ¥
      const allComments = targetMNNote.MNComments;
      
      for (const comment of allComments) {
        // è·³è¿‡ HTML å­—æ®µ
        if (comment && comment.type === "HtmlComment") {
          continue;
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥é“¾æ¥
        if (comment && comment.text) {
          const commentText = comment.text.trim();
          
          if (commentText.isValidNoteURL() && commentText === sourceNoteUrl) {
            // é“¾æ¥å·²å­˜åœ¨ï¼Œä¸éœ€è¦æ·»åŠ 
            return;
          }
        }
      }
      
      // é“¾æ¥ä¸å­˜åœ¨ï¼Œç›´æ¥æ·»åŠ åˆ°ç¬”è®°æœ«å°¾
      targetMNNote.appendNoteLink(sourceNote, "To");
    }
  }

  /**
   * æ ¹æ®æ–‡æœ¬åˆ é™¤è¯„è®ºï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œæ”¯æŒé“¾æ¥è¯„è®ºï¼‰
   * @param {MNNote} note - è¦å¤„ç†çš„ç¬”è®°
   * @param {string|string[]} texts - è¦åˆ é™¤çš„æ–‡æœ¬æˆ–æ–‡æœ¬æ•°ç»„
   */
  static removeCommentsByText(note, texts) {
    if (!note || !texts) {
      return;
    }
    
    // å¤„ç†å‚æ•°ï¼Œç¡®ä¿æ˜¯æ•°ç»„
    const textsToRemove = Array.isArray(texts) ? texts : [texts];
    
    // è¿‡æ»¤æ‰éå­—ç¬¦ä¸²å…ƒç´ 
    const validTexts = textsToRemove.filter(text => typeof text === 'string');
    
    if (validTexts.length === 0) {
      return;
    }
    
    // ä»åå‘å‰éå†ï¼Œé¿å…ç´¢å¼•æ··ä¹±
    for (let i = note.comments.length - 1; i >= 0; i--) {
      const comment = note.comments[i];
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ é™¤
      if (comment && comment.text && validTexts.includes(comment.text)) {
        // æ”¯æŒ TextNoteã€HtmlNote å’Œæ‰€æœ‰åŒ…å« text å±æ€§çš„è¯„è®ºç±»å‹
        if (comment.type === "TextNote" || comment.type === "HtmlNote") {
          note.removeCommentByIndex(i);
        }
      }
    }
  }

  /**
   * åˆ é™¤æŒ‡å‘ç‰¹å®šç¬”è®°çš„é“¾æ¥
   * @param {MNNote} note - è¦å¤„ç†çš„ç¬”è®°
   * @param {string} targetNoteIdOrUrl - ç›®æ ‡ç¬”è®°IDæˆ–URL
   */
  static removeLinkToNote(note, targetNoteIdOrUrl) {
    if (!note || !targetNoteIdOrUrl) {
      return;
    }
    
    // æå–çº¯ç²¹çš„ noteIdï¼ˆå¦‚æœä¼ å…¥çš„æ˜¯å®Œæ•´ URLï¼‰
    let targetNoteId = targetNoteIdOrUrl;
    const noteIdMatch = targetNoteIdOrUrl.match(/marginnote[34]app:\/\/note\/([A-Z0-9-]+)/i);
    if (noteIdMatch) {
      targetNoteId = noteIdMatch[1];
    }
    
    // ä½¿ç”¨ MNComments è·å–åŒ…è£…åçš„è¯„è®º
    const comments = note.MNComments;
    if (!comments || comments.length === 0) {
      return;
    }
    
    // æ”¶é›†è¦åˆ é™¤çš„ç´¢å¼•
    const indicesToRemove = [];
    
    comments.forEach((comment, index) => {
      if (comment && comment.type === "linkComment" && comment.text) {
        // æ£€æŸ¥é“¾æ¥æ˜¯å¦æŒ‡å‘ç›®æ ‡ç¬”è®°
        if (comment.text.includes(targetNoteId)) {
          indicesToRemove.push(index);
        }
      }
    });
    
    // ä»åå‘å‰åˆ é™¤
    indicesToRemove.sort((a, b) => b - a);
    indicesToRemove.forEach(index => {
      note.removeCommentByIndex(index);
    });
  }

  /**
   * ç§»é™¤æœ€åä¸€ä¸ªå­—æ®µä¸­çš„é‡å¤é“¾æ¥
   * ï¼ˆä»åŸä½ç½®è¿ç§»åˆ° KnowledgeBaseTemplate ç±»ï¼‰
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   */
  static removeDuplicateLinksInLastField(note) {
    let commentsObj = this.parseNoteComments(note);
    let htmlComments = commentsObj.htmlCommentsObjArr;
    
    if (htmlComments.length === 0) return;
    
    // è·å–æœ€åä¸€ä¸ªå­—æ®µçš„è¯„è®ºç´¢å¼•èŒƒå›´
    let lastField = htmlComments[htmlComments.length - 1];
    let fieldIndexRange = lastField.excludingFieldBlockIndexArr;
    
    if (fieldIndexRange.length === 0) return;
    
    // æ”¶é›†è¿™ä¸ªå­—æ®µèŒƒå›´å†…çš„æ‰€æœ‰é“¾æ¥
    let linksInField = {};
    let duplicateIndices = [];
    
    fieldIndexRange.forEach(index => {
      let comment = note.MNComments[index];
      if (comment && comment.type === "linkComment") {
        let linkUrl = comment.text;
        if (linksInField[linkUrl]) {
          // è¿™æ˜¯é‡å¤çš„é“¾æ¥ï¼Œæ ‡è®°è¦åˆ é™¤
          duplicateIndices.push(index);
        } else {
          // ç¬¬ä¸€æ¬¡å‡ºç°ï¼Œè®°å½•ä¸‹æ¥
          linksInField[linkUrl] = index;
        }
      }
    });
    
    // // ä»åå‘å‰åˆ é™¤é‡å¤çš„é“¾æ¥ï¼ˆé¿å…ç´¢å¼•æ··ä¹±ï¼‰
    // duplicateIndices.sort((a, b) => b - a);
    // duplicateIndices.forEach(index => {
    //   note.removeCommentByIndex(index);
    // });
    note.removeCommentsByIndexArr(duplicateIndices);
  }

  /**
   * æ£€æµ‹å¹¶ç§»åŠ¨ä»»åŠ¡å¡ç‰‡é“¾æ¥åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ
   * åœ¨åˆ¶å¡è¿‡ç¨‹ä¸­ï¼Œè‡ªåŠ¨å°†æœ€åä¸€ä¸ªå­—æ®µä¸‹æ–¹çš„ä»»åŠ¡å¡ç‰‡é“¾æ¥ç§»åŠ¨åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„çŸ¥è¯†å¡ç‰‡
   */
  static moveTaskCardLinksToRelatedField(note) {
    try {
      // 1. è§£æå¡ç‰‡ç»“æ„ï¼Œè·å–å­—æ®µä¿¡æ¯
      const commentsObj = this.parseNoteComments(note);
      const htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
      
      if (htmlCommentsObjArr.length === 0) {
        return; // æ²¡æœ‰å­—æ®µï¼Œç›´æ¥è¿”å›
      }
      
      // 2. è·å–æœ€åä¸€ä¸ªå­—æ®µåŠå…¶ä¸‹æ–¹çš„å†…å®¹
      const lastField = htmlCommentsObjArr[htmlCommentsObjArr.length - 1];
      const lastFieldName = lastField.text;
      
      // å¦‚æœæœ€åä¸€ä¸ªå­—æ®µå·²ç»æ˜¯"ç›¸å…³é“¾æ¥"ï¼Œåˆ™æ— éœ€å¤„ç†
      if (lastFieldName === "ç›¸å…³é“¾æ¥" || lastFieldName === "ç›¸å…³é“¾æ¥ï¼š") {
        return;
      }
      
      // 3. æ£€æŸ¥æ˜¯å¦å­˜åœ¨"ç›¸å…³é“¾æ¥"å­—æ®µ
      let relatedLinksFieldObj = null;
      for (let i = 0; i < htmlCommentsObjArr.length; i++) {
        const field = htmlCommentsObjArr[i];
        if (field.text === "ç›¸å…³é“¾æ¥" || field.text === "ç›¸å…³é“¾æ¥ï¼š") {
          relatedLinksFieldObj = field;
          break;
        }
      }
      
      // å¦‚æœæ²¡æœ‰"ç›¸å…³é“¾æ¥"å­—æ®µï¼Œåˆ™æ— æ³•ç§»åŠ¨
      if (!relatedLinksFieldObj) {
        return;
      }
      
      // 4. è·å–æœ€åä¸€ä¸ªå­—æ®µä¸‹æ–¹çš„æ‰€æœ‰é“¾æ¥
      const lastFieldIndices = lastField.excludingFieldBlockIndexArr;
      const taskCardLinkIndices = [];
      
      // éå†æœ€åä¸€ä¸ªå­—æ®µä¸‹æ–¹çš„è¯„è®º
      for (let i = 0; i < lastFieldIndices.length; i++) {
        const commentIndex = lastFieldIndices[i];
        const comment = note.MNComments[commentIndex];
        
        // æ£€æŸ¥è¯„è®ºæ˜¯å¦å­˜åœ¨
        if (!comment) {
          console.log(`[moveTaskCardLinksToRelatedField] Comment at index ${commentIndex} is undefined`);
          continue;
        }
        
        // è·å–è¯„è®ºç±»å‹ï¼Œå¤„ç† type å¯èƒ½ä¸º undefined çš„æƒ…å†µ
        let commentType = comment.type;
        if (!commentType && comment.detail) {
          // å¦‚æœ type ä¸º undefinedï¼Œå°è¯•é‡æ–°è®¡ç®—ç±»å‹
          commentType = MNComment.getCommentType(comment.detail);
        }
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯é“¾æ¥è¯„è®º
        if (commentType === "linkComment") {
          // è·å–é“¾æ¥ URLï¼Œå…¼å®¹ä¸åŒçš„å±æ€§ä½ç½®
          const linkUrl = comment.text || comment.detail?.text || "";
          
          if (!linkUrl) {
            console.log(`[moveTaskCardLinksToRelatedField] Link URL is empty for comment at index ${commentIndex}`);
            continue;
          }
          
          // åˆ¤æ–­é“¾æ¥æ˜¯å¦æŒ‡å‘ä»»åŠ¡å¡ç‰‡
          if (this.isTaskCardLink(linkUrl)) {
            taskCardLinkIndices.push(commentIndex);
          }
        }
      }
      
      // 5. å¦‚æœæ‰¾åˆ°ä»»åŠ¡å¡ç‰‡é“¾æ¥ï¼Œç§»åŠ¨åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ
      if (taskCardLinkIndices.length > 0) {
        // ç§»åŠ¨åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µçš„åº•éƒ¨
        this.moveCommentsArrToField(note, taskCardLinkIndices, relatedLinksFieldObj.text, true);
        
        // å¯é€‰ï¼šæ˜¾ç¤ºæç¤º
        // MNUtil.showHUD(`å·²å°† ${taskCardLinkIndices.length} ä¸ªä»»åŠ¡å¡ç‰‡é“¾æ¥ç§»åŠ¨åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ`);
      }
      
    } catch (error) {
      // é”™è¯¯å¤„ç†ï¼Œä½†ä¸ä¸­æ–­åˆ¶å¡æµç¨‹
      console.error("[moveTaskCardLinksToRelatedField] Error:", error);
      console.error("[moveTaskCardLinksToRelatedField] Error stack:", error.stack);
      // å¯é€‰ï¼šåœ¨å¼€å‘é˜¶æ®µæ˜¾ç¤ºé”™è¯¯æç¤º
      // MNUtil.showHUD(`ä»»åŠ¡å¡ç‰‡é“¾æ¥å¤„ç†å‡ºé”™: ${error.message}`);
    }
  }

  /**
   * ç§»åŠ¨æ‰€æœ‰æ€»ç»“é“¾æ¥åˆ°å¡ç‰‡æœ€ä¸Šæ–¹
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   */
  static moveSummaryLinksToTop(note) {
    try {
      const summaryLinkIndices = [];
      
      // éå†æ‰€æœ‰è¯„è®ºï¼Œç›´æ¥æ£€æŸ¥æ–‡æœ¬å†…å®¹
      for (let i = 0; i < note.MNComments.length; i++) {
        const comment = note.MNComments[i];
        if (!comment) continue;
        
        // è·å–è¯„è®ºæ–‡æœ¬ - å…¼å®¹ä¸åŒçš„å±æ€§ä½ç½®
        const text = comment.text || (comment.detail && comment.detail.text) || "";
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯æ€»ç»“é“¾æ¥ï¼šmarginnote4app://note/ID/summary/0
        // åŒ¹é…æ ¼å¼ï¼šmarginnote[æ•°å­—]app://note/[ä»»æ„å­—ç¬¦]/summary/
        if (/^marginnote\dapp:\/\/note\/.*\/summary\//.test(text)) {
          summaryLinkIndices.push(i);
        }
      }
      
      // ä½¿ç”¨ moveCommentsByIndexArr æ‰¹é‡ç§»åŠ¨åˆ°é¡¶éƒ¨
      if (summaryLinkIndices.length > 0) {
        note.moveCommentsByIndexArr(summaryLinkIndices, 0);
      }
      
    } catch (error) {
      // å¼€å‘é˜¶æ®µæ˜¾ç¤ºé”™è¯¯æç¤º
      MNUtil.showHUD(`æ€»ç»“é“¾æ¥å¤„ç†å‡ºé”™: ${error.message}`);
    }
  }

  /**
   * è·å–æŒ‡å®šå­—æ®µå†…çš„ HtmlMarkdown è¯„è®º
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} fieldName - å­—æ®µåç§°
   * @returns {Array<{index: number, text: string, type: string, content: string}>} HtmlMarkdown è¯„è®ºæ•°ç»„
   */
  static getFieldHtmlMarkdownComments(note, fieldName) {
    const commentsObj = this.parseNoteComments(note);
    const htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    const htmlMarkdownCommentsObjArr = commentsObj.htmlMarkdownCommentsObjArr;
    
    // æ‰¾åˆ°è¯¥å­—æ®µçš„ç´¢å¼•èŒƒå›´
    let fieldObj = htmlCommentsObjArr.find(obj => obj.text.includes(fieldName));
    if (!fieldObj) return [];
    
    // è·å–è¯¥å­—æ®µçš„è¯„è®ºç´¢å¼•èŒƒå›´ï¼ˆä¸åŒ…å«å­—æ®µæœ¬èº«ï¼‰
    const fieldIndices = fieldObj.excludingFieldBlockIndexArr;
    
    // ç­›é€‰å‡ºè¯¥èŒƒå›´å†…çš„ HtmlMarkdown è¯„è®º
    return htmlMarkdownCommentsObjArr.filter(mdComment => 
      fieldIndices.includes(mdComment.index)
    );
  }

  /**
   * æ˜¾ç¤ºå­—æ®µå†… HtmlMarkdown å­é€‰æ‹©å¯¹è¯æ¡†
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} fieldName - å­—æ®µåç§°
   * @param {Function} callback - å›è°ƒå‡½æ•°ï¼Œå‚æ•°ä¸ºé€‰æ‹©çš„ç›®æ ‡ç´¢å¼•
   */
  static showFieldSubSelectionDialog(note, fieldName, callback) {
    const htmlMarkdownComments = this.getFieldHtmlMarkdownComments(note, fieldName);
    
    if (htmlMarkdownComments.length === 0) {
      // å¦‚æœæ²¡æœ‰ HtmlMarkdown è¯„è®ºï¼Œç›´æ¥è¿”å›å­—æ®µåº•éƒ¨
      const fieldObj = this.parseNoteComments(note).htmlCommentsObjArr.find(obj => obj.text.includes(fieldName));
      if (fieldObj && fieldObj.excludingFieldBlockIndexArr.length > 0) {
        const lastIndex = fieldObj.excludingFieldBlockIndexArr[fieldObj.excludingFieldBlockIndexArr.length - 1];
        callback(lastIndex + 1);
      } else {
        callback(null);
      }
      return;
    }
    
    // æ„å»ºé€‰é¡¹åˆ—è¡¨
    const options = ["ğŸ” å­—æ®µé¡¶éƒ¨"];
    htmlMarkdownComments.forEach(mdComment => {
      const icon = HtmlMarkdownUtils.icons[mdComment.type] || "";
      const prefix = HtmlMarkdownUtils.prefix[mdComment.type] || "";
      // æ˜ç¡®æ ‡ç¤ºä½ç½®å…³ç³»
      options.push(`â†‘ åœ¨æ­¤ä¹‹å‰ï¼š${icon} ${prefix}${mdComment.content}`);
      options.push(`â†“ åœ¨æ­¤ä¹‹åï¼š${icon} ${prefix}${mdComment.content}`);
    });
    options.push("â¬‡ï¸ å­—æ®µåº•éƒ¨");
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      `é€‰æ‹©åœ¨ã€${fieldName}ã€‘ä¸­çš„ä½ç½®`,
      "é€‰æ‹©è¦ç§»åŠ¨åˆ°çš„å…·ä½“ä½ç½®",
      0,
      "å–æ¶ˆ",
      options,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          callback(null);
          return;
        }
        
        const fieldObj = this.parseNoteComments(note).htmlCommentsObjArr.find(obj => obj.text.includes(fieldName));
        if (!fieldObj) {
          callback(null);
          return;
        }
        
        if (buttonIndex === 1) {
          // å­—æ®µé¡¶éƒ¨
          callback(fieldObj.index + 1);
        } else if (buttonIndex === options.length) {
          // å­—æ®µåº•éƒ¨
          const lastIndex = fieldObj.excludingFieldBlockIndexArr[fieldObj.excludingFieldBlockIndexArr.length - 1] || fieldObj.index;
          callback(lastIndex + 1);
        } else {
          // HtmlMarkdown è¯„è®ºä½ç½®
          const mdIndex = Math.floor((buttonIndex - 2) / 2);
          const isAfter = (buttonIndex - 2) % 2 === 1;
          
          if (mdIndex < htmlMarkdownComments.length) {
            const targetIndex = htmlMarkdownComments[mdIndex].index;
            callback(isAfter ? targetIndex + 1 : targetIndex);
          } else {
            callback(null);
          }
        }
      }
    );
  }

  /**
   * è§£æå­—æ®µå†…çš„æ™®é€šè¯„è®ºï¼ˆé HtmlComment ç±»å‹ï¼‰
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Object} fieldObj - å­—æ®µå¯¹è±¡ï¼ˆæ¥è‡ª parseNoteCommentsï¼‰
   * @returns {Array} è¿”å›å­—æ®µå†…çš„è¯„è®ºä¿¡æ¯æ•°ç»„
   */
  static parseFieldInternalComments(note, fieldObj) {
    const comments = [];
    const fieldIndices = fieldObj.excludingFieldBlockIndexArr;
    
    for (const index of fieldIndices) {
      const comment = note.MNComments[index];
      if (!comment) continue;
      
      // æ£€æŸ¥æ˜¯å¦ä¸º HtmlCommentï¼Œå¦‚æœæ˜¯åˆ™è·³è¿‡
      if (comment.text && comment.text.includes('<!-- ') && comment.text.includes(' -->')) {
        continue;
      }
      
      const commentInfo = {
        index: index,
        comment: comment,
        displayText: this.formatCommentForDisplay(comment, index, note)
      };
      
      comments.push(commentInfo);
    }
    
    return comments;
  }
  
  /**
   * æ ¹æ®è¯„è®ºç±»å‹è¿”å›å¯¹åº”çš„å›¾æ ‡
   * 
   * @param {Object} comment - è¯„è®ºå¯¹è±¡
   * @returns {string} å›¾æ ‡å­—ç¬¦
   */
  static getCommentTypeIcon(comment) {
    if (comment.icon) return comment.icon;
    
    switch (comment.type) {
      case 'TextNote':
        return 'ğŸ“';
      case 'PaintNote':
        return 'âœï¸';
      case 'linkComment':
        return 'ğŸ”—';
      case 'mergedImageComment':
      case 'mergedImageCommentWithDrawing':
        return 'ğŸ–¼ï¸';
      case 'markdownComment':
        return 'ğŸ“„';
      default:
        return 'â€¢';
    }
  }
  
  /**
   * æ˜¾ç¤º HtmlMarkdown è¯„è®ºä¸‹çš„ä½ç½®é€‰æ‹©å¯¹è¯æ¡†
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Object} htmlMarkdownComment - HtmlMarkdown è¯„è®ºå¯¹è±¡
   * @param {Object} fieldObj - å­—æ®µå¯¹è±¡ï¼ŒåŒ…å«å­—æ®µçš„è¾¹ç•Œä¿¡æ¯
   * @param {Function} callback - å›è°ƒå‡½æ•°
   */
  static showHtmlMarkdownInternalPositionDialog(note, htmlMarkdownComment, fieldObj, callback, previousDialog = null) {
    // è·å–è¯¥ HtmlMarkdown è¯„è®ºåé¢çš„å†…å®¹ï¼Œé™åˆ¶åœ¨å½“å‰å­—æ®µèŒƒå›´å†…
    const comments = note.MNComments;
    const startIndex = htmlMarkdownComment.index;
    const internalComments = [];
    
    // è·å–å­—æ®µçš„ç´¢å¼•èŒƒå›´
    const fieldIndices = fieldObj.excludingFieldBlockIndexArr;
    const maxIndex = Math.max(...fieldIndices);
    
    // ä»ä¸‹ä¸€ä¸ªä½ç½®å¼€å§‹æ”¶é›†ï¼Œä½†é™åˆ¶åœ¨å­—æ®µèŒƒå›´å†…
    for (let i = startIndex + 1; i <= maxIndex && i < comments.length; i++) {
      // åªå¤„ç†å±äºå½“å‰å­—æ®µçš„è¯„è®º
      if (!fieldIndices.includes(i)) continue;
      
      const comment = comments[i];
      if (!comment) continue;
      
      // å¦‚æœé‡åˆ° HtmlCommentï¼ˆå­—æ®µï¼‰ï¼Œè·³è¿‡
      if (comment.text && comment.text.includes('<!-- ') && comment.text.includes(' -->')) {
        continue;
      }
      
      // æ£€æŸ¥æ˜¯å¦ä¸º HtmlMarkdown
      let cleanText = comment.text || "";
      if (cleanText.startsWith("- ")) {
        cleanText = cleanText.substring(2);
      }
      if (HtmlMarkdownUtils.isHtmlMDComment(cleanText)) {
        break;  // é‡åˆ°ä¸‹ä¸€ä¸ª HtmlMarkdownï¼Œåœæ­¢
      }
      
      const displayText = this.formatCommentForDisplay(comment, i, note);
      internalComments.push({
        index: i,
        comment: comment,
        displayText: displayText
      });
    }
    
    // æ„å»ºé€‰é¡¹
    const icon = HtmlMarkdownUtils.icons[htmlMarkdownComment.type] || 'ğŸ“„';
    const content = htmlMarkdownComment.content || '';
    let options = [];
    
    // å¦‚æœæœ‰ä¸Šä¸€å±‚ï¼Œæ·»åŠ è¿”å›é€‰é¡¹
    if (previousDialog) {
      options.push("â¬…ï¸ è¿”å›ä¸Šä¸€å±‚");
    }
    
    options.push(`[${icon}] ${content} é¡¶éƒ¨`);
    
    if (internalComments.length > 0) {
      // ä¸ºæ¯ä¸ªå†…éƒ¨è¯„è®ºç”Ÿæˆä½ç½®é€‰é¡¹
      for (let i = 0; i < internalComments.length; i++) {
        const commentInfo = internalComments[i];
        options.push(`${commentInfo.displayText} â†‘ ä¸Šæ–¹`);
        options.push(`${commentInfo.displayText} â†“ ä¸‹æ–¹`);
      }
    }
    
    options.push(`[${icon}] ${content} åº•éƒ¨`);
    
    // æ˜¾ç¤ºé€‰æ‹©å¯¹è¯æ¡†
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      `é€‰æ‹©ã€${icon} ${content}ã€‘å†…çš„å…·ä½“ä½ç½®`,
      "é€‰æ‹©è¦æ’å…¥çš„ä½ç½®",
      0,
      "å–æ¶ˆ",
      options,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          callback(null);
          return;
        }
        
        // å¦‚æœæœ‰è¿”å›é€‰é¡¹ï¼Œå¤„ç†è¿”å›
        if (previousDialog && buttonIndex === 1) {
          previousDialog();
          return;
        }
        
        // æ ¹æ®æ˜¯å¦æœ‰è¿”å›é€‰é¡¹è°ƒæ•´ç´¢å¼•
        const offset = previousDialog ? 1 : 0;
        
        if (buttonIndex === 1 + offset) {
          // HtmlMarkdown é¡¶éƒ¨ï¼ˆå³å…¶ä¸‹æ–¹ï¼‰
          callback(startIndex + 1);
        } else if (buttonIndex === options.length) {
          // HtmlMarkdown åº•éƒ¨
          if (internalComments.length > 0) {
            const lastIndex = internalComments[internalComments.length - 1].index;
            callback(lastIndex + 1);
          } else {
            callback(startIndex + 1);
          }
        } else {
          // è¯„è®ºä½ç½®
          const commentIndex = Math.floor((buttonIndex - 2 - offset) / 2);
          const isAfter = (buttonIndex - 2 - offset) % 2 === 1;
          
          if (commentIndex < internalComments.length) {
            const targetIndex = internalComments[commentIndex].index;
            callback(isAfter ? targetIndex + 1 : targetIndex);
          } else {
            callback(null);
          }
        }
      }
    );
  }

  /**
   * è§£æå­—æ®µå†…çš„é¡¶å±‚ç»“æ„ï¼ˆç”¨äºç¬¬ä¸‰å±‚æ˜¾ç¤ºï¼‰
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Object} fieldObj - å­—æ®µå¯¹è±¡
   * @returns {Object} è¿”å›å­—æ®µå†…çš„é¡¶å±‚ç»“æ„
   */
  static parseFieldTopLevelStructure(note, fieldObj) {
    const structure = {
      independentComments: [],  // HtmlMarkdown ä¹‹å‰çš„ç‹¬ç«‹è¯„è®º
      htmlMarkdownSections: []  // HtmlMarkdown åŒºå—ï¼ˆåŒ…å«å…¶æ ‡é¢˜å’ŒèŒƒå›´ï¼‰
    };
    
    const fieldIndices = fieldObj.excludingFieldBlockIndexArr;
    const parsedComments = this.parseNoteComments(note);
    
    // ç¬¬ä¸€æ­¥ï¼šæ‰¾å‡ºæ‰€æœ‰ HtmlMarkdown çš„ä½ç½®
    const htmlMarkdownIndices = [];
    for (let i = 0; i < fieldIndices.length; i++) {
      const index = fieldIndices[i];
      const comment = note.MNComments[index];
      if (!comment) continue;
      
      // è·³è¿‡ HtmlCommentï¼ˆå­—æ®µï¼‰
      if (comment.text && comment.text.includes('<!-- ') && comment.text.includes(' -->')) {
        continue;
      }
      
      // æ£€æŸ¥æ˜¯å¦ä¸º HtmlMarkdown è¯„è®º
      const htmlMarkdownObj = parsedComments.htmlMarkdownCommentsObjArr.find(obj => obj.index === index);
      if (htmlMarkdownObj) {
        htmlMarkdownIndices.push({
          index: index,
          htmlMarkdownObj: htmlMarkdownObj
        });
      }
    }
    
    // ç¬¬äºŒæ­¥ï¼šå¤„ç†ç‹¬ç«‹è¯„è®ºï¼ˆåªæœ‰ç¬¬ä¸€ä¸ª HtmlMarkdown ä¹‹å‰çš„å†…å®¹æ˜¯ç‹¬ç«‹çš„ï¼‰
    const firstHtmlMarkdownIndex = htmlMarkdownIndices.length > 0 ? htmlMarkdownIndices[0].index : null;
    
    for (let i = 0; i < fieldIndices.length; i++) {
      const index = fieldIndices[i];
      
      // å¦‚æœæœ‰ HtmlMarkdownï¼Œä¸”å½“å‰ç´¢å¼•å·²ç»åˆ°è¾¾æˆ–è¶…è¿‡ç¬¬ä¸€ä¸ª HtmlMarkdownï¼Œåœæ­¢æ”¶é›†ç‹¬ç«‹è¯„è®º
      if (firstHtmlMarkdownIndex !== null && index >= firstHtmlMarkdownIndex) {
        break;
      }
      
      const comment = note.MNComments[index];
      if (!comment) continue;
      
      // è·³è¿‡ HtmlCommentï¼ˆå­—æ®µï¼‰
      if (comment.text && comment.text.includes('<!-- ') && comment.text.includes(' -->')) {
        continue;
      }
      
      structure.independentComments.push({
        index: index,
        comment: comment,
        displayText: this.formatCommentForDisplay(comment, index, note)
      });
    }
    
    // ç¬¬ä¸‰æ­¥ï¼šåˆ›å»º HtmlMarkdown åŒºå—
    for (let i = 0; i < htmlMarkdownIndices.length; i++) {
      const { index, htmlMarkdownObj } = htmlMarkdownIndices[i];
      const icon = HtmlMarkdownUtils.icons[htmlMarkdownObj.type] || 'ğŸ“„';
      
      let endIndex;
      if (i < htmlMarkdownIndices.length - 1) {
        // ä¸æ˜¯æœ€åä¸€ä¸ªï¼Œç»“æŸäºä¸‹ä¸€ä¸ª HtmlMarkdown ä¹‹å‰
        endIndex = htmlMarkdownIndices[i + 1].index - 1;
      } else {
        // æ˜¯æœ€åä¸€ä¸ªï¼Œç»“æŸäºå­—æ®µæœ«å°¾
        endIndex = fieldIndices[fieldIndices.length - 1] || index;
      }
      
      structure.htmlMarkdownSections.push({
        index: index,
        htmlMarkdownObj: htmlMarkdownObj,
        displayText: `[${icon}] ${htmlMarkdownObj.content || ''}`,
        startIndex: index,
        endIndex: endIndex
      });
    }
    
    return structure;
  }

  /**
   * è§£æå­—æ®µå†…çš„æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬ HtmlMarkdown å’Œæ™®é€šè¯„è®ºï¼‰
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Object} fieldObj - å­—æ®µå¯¹è±¡
   * @returns {Array} è¿”å›åŒ…å«ç±»å‹ä¿¡æ¯çš„å†…å®¹æ•°ç»„
   */
  static parseFieldAllContents(note, fieldObj) {
    const contents = [];
    const fieldIndices = fieldObj.excludingFieldBlockIndexArr;
    const parsedComments = this.parseNoteComments(note);
    
    for (const index of fieldIndices) {
      const comment = note.MNComments[index];
      if (!comment) continue;
      
      // æ£€æŸ¥æ˜¯å¦ä¸º HtmlCommentï¼ˆå­—æ®µï¼‰ï¼Œå¦‚æœæ˜¯åˆ™è·³è¿‡
      if (comment.text && comment.text.includes('<!-- ') && comment.text.includes(' -->')) {
        continue;
      }
      
      // æ£€æŸ¥æ˜¯å¦ä¸º HtmlMarkdown è¯„è®º
      const htmlMarkdownObj = parsedComments.htmlMarkdownCommentsObjArr.find(obj => obj.index === index);
      
      if (htmlMarkdownObj) {
        // HtmlMarkdown è¯„è®º
        const icon = HtmlMarkdownUtils.icons[htmlMarkdownObj.type] || 'ğŸ“„';
        contents.push({
          type: 'htmlMarkdown',
          index: index,
          comment: comment,
          displayText: `â—† [${icon}] ${htmlMarkdownObj.content || ''}`,
          htmlMarkdownObj: htmlMarkdownObj
        });
      } else {
        // æ™®é€šè¯„è®º
        contents.push({
          type: 'normal',
          index: index,
          comment: comment,
          displayText: this.formatCommentForDisplay(comment, index, note)
        });
      }
    }
    
    return contents;
  }

  /**
   * æ˜¾ç¤ºå­—æ®µå†…éƒ¨ä½ç½®é€‰æ‹©å¯¹è¯æ¡†ï¼ˆç¬¬ä¸‰å±‚ï¼‰
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} fieldName - å­—æ®µåç§°
   * @param {Function} callback - å›è°ƒå‡½æ•°ï¼Œå‚æ•°ä¸ºé€‰ä¸­çš„ç´¢å¼•ä½ç½®
   */
  static showFieldInternalPositionDialog(note, fieldName, callback, previousDialog = null) {
    const fieldObj = this.parseNoteComments(note).htmlCommentsObjArr.find(obj => obj.text.includes(fieldName));
    if (!fieldObj) {
      callback(null);
      return;
    }
    
    const structure = this.parseFieldTopLevelStructure(note, fieldObj);
    
    // æ£€æŸ¥å­—æ®µæ˜¯å¦ä¸ºç©º
    if (structure.independentComments.length === 0 && structure.htmlMarkdownSections.length === 0) {
      // å­—æ®µå†…æ²¡æœ‰å†…å®¹ï¼Œç›´æ¥è¿”å›å­—æ®µåº•éƒ¨
      callback(fieldObj.index + 1);
      return;
    }
    
    let options = [];
    let optionActions = []; // è®°å½•æ¯ä¸ªé€‰é¡¹çš„åŠ¨ä½œ
    
    // å¦‚æœæœ‰ä¸Šä¸€å±‚ï¼Œæ·»åŠ è¿”å›é€‰é¡¹
    if (previousDialog) {
      options.push("â¬…ï¸ è¿”å›ä¸Šä¸€å±‚");
      optionActions.push({type: 'return'});
    }
    
    options.push(`ã€${fieldName}ã€‘å­—æ®µé¡¶éƒ¨`);
    optionActions.push({type: 'fieldTop'});
    
    // åˆå¹¶å¹¶æ’åºæ‰€æœ‰å…ƒç´ 
    let allElements = [];
    
    // æ·»åŠ ç‹¬ç«‹è¯„è®º
    structure.independentComments.forEach(comment => {
      allElements.push({
        type: 'independentComment',
        index: comment.index,
        data: comment
      });
    });
    
    // æ·»åŠ  HtmlMarkdown åŒºå—
    structure.htmlMarkdownSections.forEach(section => {
      allElements.push({
        type: 'htmlMarkdown',
        index: section.index,
        data: section
      });
    });
    
    // æŒ‰ç´¢å¼•æ’åº
    allElements.sort((a, b) => a.index - b.index);
    
    // ç”Ÿæˆé€‰é¡¹
    for (const element of allElements) {
      if (element.type === 'independentComment') {
        // ç‹¬ç«‹è¯„è®ºæ˜¾ç¤ºä¸Šæ–¹å’Œä¸‹æ–¹é€‰é¡¹
        const comment = element.data;
        options.push(`${comment.displayText} â†‘ ä¸Šæ–¹`);
        optionActions.push({type: 'position', index: comment.index, isAfter: false});
        
        options.push(`${comment.displayText} â†“ ä¸‹æ–¹`);
        optionActions.push({type: 'position', index: comment.index, isAfter: true});
        
      } else if (element.type === 'htmlMarkdown') {
        // HtmlMarkdown æ˜¾ç¤ºæ ‡é¢˜ï¼ˆå¯ç‚¹å‡»ï¼‰å’Œ Top/Bottom
        const section = element.data;
        
        // æ ‡é¢˜ï¼ˆå¯ç‚¹å‡»è¿›å…¥ï¼‰
        options.push(`â—† ${section.displayText}`);
        optionActions.push({type: 'htmlMarkdownDetail', section: section});
        
        // Top å’Œ Bottom
        options.push(`ğŸ” ${section.displayText} Top ğŸ”`);
        optionActions.push({type: 'position', index: section.index + 1, isAfter: false});
        
        options.push(`â¬‡ï¸ ${section.displayText} Bottom â¬‡ï¸`);
        optionActions.push({type: 'htmlMarkdownBottom', section: section});
      }
    }
    
    options.push(`ã€${fieldName}ã€‘å­—æ®µåº•éƒ¨`);
    optionActions.push({type: 'fieldBottom'});
    
    // æ˜¾ç¤ºé€‰æ‹©å¯¹è¯æ¡†
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      `é€‰æ‹©ã€${fieldName}ã€‘å†…çš„å…·ä½“ä½ç½®`,
      "ç‚¹å‡»å¸¦ â—† çš„é¡¹ç›®å¯è¿›å…¥æ›´ç²¾ç¡®çš„ä½ç½®é€‰æ‹©",
      0,
      "å–æ¶ˆ",
      options,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          callback(null);
          return;
        }
        
        const action = optionActions[buttonIndex - 1];
        
        if (action.type === 'return') {
          // è¿”å›ä¸Šä¸€å±‚
          previousDialog();
          return;
          
        } else if (action.type === 'fieldTop') {
          // å­—æ®µé¡¶éƒ¨
          callback(fieldObj.index + 1);
          
        } else if (action.type === 'fieldBottom') {
          // å­—æ®µåº•éƒ¨
          const lastIndex = fieldObj.excludingFieldBlockIndexArr[fieldObj.excludingFieldBlockIndexArr.length - 1] || fieldObj.index;
          callback(lastIndex + 1);
          
        } else if (action.type === 'position') {
          // ç›´æ¥ä½ç½®
          if (action.isAfter) {
            callback(action.index + 1);  // ä¸‹æ–¹ä½ç½®
          } else {
            callback(action.index);      // ä¸Šæ–¹ä½ç½®
          }
          
        } else if (action.type === 'htmlMarkdownDetail') {
          // ç”¨æˆ·ç‚¹å‡»äº† HtmlMarkdown æ ‡é¢˜ï¼Œæ˜¾ç¤ºå…¶å†…éƒ¨ä½ç½®é€‰æ‹©
          this.showHtmlMarkdownInternalPositionDialog(note, action.section.htmlMarkdownObj, fieldObj, callback, () => {
            // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºå½“å‰å¯¹è¯æ¡†
            this.showFieldInternalPositionDialog(note, fieldName, callback, previousDialog);
          });
          
        } else if (action.type === 'htmlMarkdownBottom') {
          // HtmlMarkdown çš„ Bottom
          // éœ€è¦æ‰¾åˆ°è¿™ä¸ª HtmlMarkdown åŒºå—çš„ç»“æŸä½ç½®
          const endIndex = action.section.endIndex;
          if (endIndex !== null && endIndex >= action.section.startIndex) {
            callback(endIndex + 1);
          } else {
            // å¦‚æœæ²¡æœ‰å†…å®¹ï¼Œå°±æ˜¯ HtmlMarkdown çš„ä¸‹ä¸€ä¸ªä½ç½®
            callback(action.section.startIndex + 1);
          }
        }
      }
    );
  }

  /**
   * æ˜¾ç¤ºå¤šé€‰è¯„è®ºå¯¹è¯æ¡†
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡  
   * @param {Array} commentOptions - è¯„è®ºé€‰é¡¹æ•°ç»„
   * @param {Set} selectedIndices - å·²é€‰ä¸­çš„ç´¢å¼•é›†åˆ
   * @param {Function} callback - å›è°ƒå‡½æ•°ï¼Œå‚æ•°ä¸ºé€‰ä¸­çš„ç´¢å¼•æ•°ç»„
   * @param {Function} previousDialog - è¿”å›ä¸Šä¸€å±‚çš„å‡½æ•°
   */
  static showCommentMultiSelectDialog(note, commentOptions, selectedIndices, callback, previousDialog = null) {
    // æ„å»ºæ˜¾ç¤ºé€‰é¡¹
    let displayOptions = commentOptions.map(item => {
      let prefix = selectedIndices.has(item.index) ? "âœ… " : "";
      return prefix + item.display;
    });
    
    // æ·»åŠ å…¨é€‰/å–æ¶ˆå…¨é€‰é€‰é¡¹
    let allSelected = selectedIndices.size === commentOptions.length;
    let selectAllText = allSelected ? "â¬œ å–æ¶ˆå…¨é€‰" : "â˜‘ï¸ å…¨é€‰æ‰€æœ‰å†…å®¹";
    displayOptions.unshift(selectAllText);
    
    // æ·»åŠ èŒƒå›´é€‰æ‹©é€‰é¡¹
    displayOptions.splice(1, 0, "ğŸ“ é€‰æ‹©èŒƒå›´");
    
    // æ·»åŠ åé€‰é€‰é¡¹
    displayOptions.splice(2, 0, "ğŸ”„ åé€‰");
    
    // æ·»åŠ åˆ†éš”çº¿å’Œæ“ä½œé€‰é¡¹
    if (previousDialog) {
      displayOptions.push("â¬…ï¸ è¿”å›ä¸Šä¸€å±‚");
    }
    displayOptions.push("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    displayOptions.push("â¡ï¸ ç§»åŠ¨é€‰ä¸­é¡¹");
    displayOptions.push("ğŸ“¤ æå–é€‰ä¸­é¡¹");
    displayOptions.push("ğŸ—‘ï¸ åˆ é™¤é€‰ä¸­é¡¹");
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©è¦ç§»åŠ¨çš„å†…å®¹",
      `å·²é€‰ä¸­ ${selectedIndices.size}/${commentOptions.length} é¡¹`,
      0,
      "å–æ¶ˆ",
      displayOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          callback(null); // ç”¨æˆ·å–æ¶ˆ
          return;
        }
        
        if (buttonIndex === 1) {
          // ç”¨æˆ·é€‰æ‹©äº†å…¨é€‰/å–æ¶ˆå…¨é€‰
          if (allSelected) {
            // å–æ¶ˆå…¨é€‰
            selectedIndices.clear();
          } else {
            // å…¨é€‰
            commentOptions.forEach(item => {
              selectedIndices.add(item.index);
            });
          }
          
          // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
          this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
          
        } else if (buttonIndex === 2) {
          // ç”¨æˆ·é€‰æ‹©äº†èŒƒå›´é€‰æ‹©
          this.showRangeSelectDialog(note, commentOptions, selectedIndices, previousDialog);
          
        } else if (buttonIndex === 3) {
          // ç”¨æˆ·é€‰æ‹©äº†åé€‰
          const newSelectedIndices = new Set();
          commentOptions.forEach(item => {
            if (!selectedIndices.has(item.index)) {
              newSelectedIndices.add(item.index);
            }
          });
          
          // æ¸…ç©ºåŸé›†åˆå¹¶æ·»åŠ åé€‰çš„é¡¹
          selectedIndices.clear();
          newSelectedIndices.forEach(index => selectedIndices.add(index));
          
          // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
          this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
          
        } else if (buttonIndex === displayOptions.length) {
          // ç”¨æˆ·é€‰æ‹©äº†"åˆ é™¤é€‰ä¸­é¡¹"
          if (selectedIndices.size === 0) {
            MNUtil.showHUD("æ²¡æœ‰é€‰ä¸­ä»»ä½•å†…å®¹");
            this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
            return;
          }
          
          // ç›´æ¥è°ƒç”¨åˆ é™¤ç¡®è®¤å¯¹è¯æ¡†
          const selectedIndicesArray = Array.from(selectedIndices).sort((a, b) => a - b);
          this.showDeleteConfirmDialog(note, selectedIndicesArray, () => {
            // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºå½“å‰å¯¹è¯æ¡†
            this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
          });
          
        } else if (buttonIndex === displayOptions.length - 1) {
          // ç”¨æˆ·é€‰æ‹©äº†"æå–é€‰ä¸­é¡¹"
          if (selectedIndices.size === 0) {
            MNUtil.showHUD("æ²¡æœ‰é€‰ä¸­ä»»ä½•å†…å®¹");
            this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
            return;
          }
          
          // è°ƒç”¨æå–æ“ä½œ
          const selectedIndicesArray = Array.from(selectedIndices).sort((a, b) => a - b);
          this.performExtract(note, selectedIndicesArray);
          
        } else if (buttonIndex === displayOptions.length - 2) {
          // ç”¨æˆ·é€‰æ‹©äº†"ç§»åŠ¨é€‰ä¸­é¡¹"
          if (selectedIndices.size === 0) {
            MNUtil.showHUD("æ²¡æœ‰é€‰ä¸­ä»»ä½•å†…å®¹");
            this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
            return;
          }
          
          // ç›´æ¥è°ƒç”¨ç§»åŠ¨ç›®æ ‡é€‰æ‹©å¯¹è¯æ¡†
          const selectedIndicesArray = Array.from(selectedIndices).sort((a, b) => a - b);
          this.showMoveTargetSelectionDialog(note, selectedIndicesArray, () => {
            // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºå½“å‰å¯¹è¯æ¡†
            this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
          });
          
        } else if (buttonIndex === displayOptions.length - 3) {
          // ç”¨æˆ·é€‰æ‹©äº†åˆ†éš”çº¿ï¼Œå¿½ç•¥å¹¶é‡æ–°æ˜¾ç¤º
          this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
          
        } else {
          // éœ€è¦æ£€æŸ¥æ˜¯å¦é€‰æ‹©äº†è¿”å›é€‰é¡¹
          const returnIndex = previousDialog ? displayOptions.indexOf("â¬…ï¸ è¿”å›ä¸Šä¸€å±‚") : -1;
          if (previousDialog && buttonIndex - 1 === returnIndex) {
            // ç”¨æˆ·é€‰æ‹©äº†è¿”å›ä¸Šä¸€å±‚
            previousDialog();
            return;
          }
          
          // ç”¨æˆ·é€‰æ‹©äº†æŸä¸ªè¯„è®ºï¼Œåˆ‡æ¢é€‰ä¸­çŠ¶æ€
          let selectedComment = commentOptions[buttonIndex - 4]; // å› ä¸ºåŠ äº†å…¨é€‰ã€èŒƒå›´é€‰æ‹©å’Œåé€‰é€‰é¡¹ï¼Œæ‰€ä»¥ç´¢å¼•è¦å‡4
          
          if (selectedIndices.has(selectedComment.index)) {
            selectedIndices.delete(selectedComment.index);
          } else {
            selectedIndices.add(selectedComment.index);
          }
          
          // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
          this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
        }
      }
    );
  }

  /**
   * æ˜¾ç¤ºèŒƒå›´é€‰æ‹©å¯¹è¯æ¡†
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Array} commentOptions - æ‰€æœ‰è¯„è®ºé€‰é¡¹
   * @param {Set} selectedIndices - å½“å‰å·²é€‰ä¸­çš„ç´¢å¼•é›†åˆ
   * @param {Function} previousDialog - è¿”å›ä¸Šä¸€å±‚çš„å‡½æ•°
   */
  static showRangeSelectDialog(note, commentOptions, selectedIndices, previousDialog) {
    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„è¯„è®ºè¿›è¡ŒèŒƒå›´é€‰æ‹©
    if (commentOptions.length < 2) {
      MNUtil.showHUD("è¯„è®ºæ•°é‡ä¸è¶³ï¼Œè‡³å°‘éœ€è¦2ä¸ªè¯„è®ºæ‰èƒ½è¿›è¡ŒèŒƒå›´é€‰æ‹©");
      this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
      return;
    }
    
    // ç¬¬ä¸€é˜¶æ®µï¼šé€‰æ‹©èµ·å§‹ä½ç½®
    this.showStartPositionDialog(note, commentOptions, selectedIndices, previousDialog);
  }

  /**
   * æ˜¾ç¤ºèµ·å§‹ä½ç½®é€‰æ‹©å¯¹è¯æ¡†
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Array} commentOptions - æ‰€æœ‰è¯„è®ºé€‰é¡¹
   * @param {Set} selectedIndices - å½“å‰å·²é€‰ä¸­çš„ç´¢å¼•é›†åˆ
   * @param {Function} previousDialog - è¿”å›ä¸Šä¸€å±‚çš„å‡½æ•°
   */
  static showStartPositionDialog(note, commentOptions, selectedIndices, previousDialog) {
    // æ„å»ºæ˜¾ç¤ºé€‰é¡¹
    let displayOptions = commentOptions.map((item) => {
      return item.display;
    });
    
    // æ·»åŠ è¿”å›é€‰é¡¹
    displayOptions.push("â¬…ï¸ è¿”å›å¤šé€‰");
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "èŒƒå›´é€‰æ‹© - ç¬¬1æ­¥",
      "è¯·é€‰æ‹©èµ·å§‹è¯„è®º",
      0,
      "å–æ¶ˆ",
      displayOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          // å–æ¶ˆï¼Œè¿”å›å¤šé€‰å¯¹è¯æ¡†
          this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
          return;
        }
        
        if (buttonIndex === displayOptions.length) {
          // è¿”å›å¤šé€‰
          this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
          return;
        }
        
        // ç”¨æˆ·é€‰æ‹©äº†èµ·å§‹ä½ç½®
        const startIndex = buttonIndex - 1;
        const startComment = commentOptions[startIndex];
        
        // è¿›å…¥ç¬¬äºŒé˜¶æ®µï¼šé€‰æ‹©ç»“æŸä½ç½®
        this.showEndPositionDialog(note, commentOptions, selectedIndices, startComment, previousDialog);
      }
    );
  }

  /**
   * æ˜¾ç¤ºç»“æŸä½ç½®é€‰æ‹©å¯¹è¯æ¡†
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Array} commentOptions - æ‰€æœ‰è¯„è®ºé€‰é¡¹
   * @param {Set} selectedIndices - å½“å‰å·²é€‰ä¸­çš„ç´¢å¼•é›†åˆ
   * @param {Object} startComment - èµ·å§‹è¯„è®ºå¯¹è±¡
   * @param {Function} previousDialog - è¿”å›ä¸Šä¸€å±‚çš„å‡½æ•°
   */
  static showEndPositionDialog(note, commentOptions, selectedIndices, startComment, previousDialog) {
    // æ„å»ºæ˜¾ç¤ºé€‰é¡¹ï¼Œé«˜äº®èµ·å§‹ä½ç½®å’Œæä¾›èŒƒå›´é¢„è§ˆ
    let displayOptions = commentOptions.map((item) => {
      let prefix = "";
      if (item.index === startComment.index) {
        prefix = "ğŸŸ¢ ";  // èµ·å§‹ä½ç½®æ ‡è®°
      } else if (item.index < startComment.index) {
        // æ˜¾ç¤ºå‘ä¸ŠèŒƒå›´çš„å¤§å°
        const rangeSize = startComment.index - item.index + 1;
        prefix = `â¬†ï¸${rangeSize} `;
      } else if (item.index > startComment.index) {
        // æ˜¾ç¤ºå‘ä¸‹èŒƒå›´çš„å¤§å°
        const rangeSize = item.index - startComment.index + 1;
        prefix = `â¬‡ï¸${rangeSize} `;
      }
      return `${prefix}${item.display}`;
    });
    
    // æ·»åŠ è¿”å›é€‰é¡¹
    displayOptions.push("â¬…ï¸ è¿”å›ç¬¬1æ­¥");
    displayOptions.push("â¬…ï¸ è¿”å›å¤šé€‰");
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "èŒƒå›´é€‰æ‹© - ç¬¬2æ­¥",
      `è¯·é€‰æ‹©ç»“æŸè¯„è®º\nå·²é€‰æ‹©èµ·å§‹: #${startComment.index + 1}`,
      0,
      "å–æ¶ˆ",
      displayOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          // å–æ¶ˆï¼Œè¿”å›å¤šé€‰å¯¹è¯æ¡†
          this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
          return;
        }
        
        if (buttonIndex === displayOptions.length) {
          // è¿”å›å¤šé€‰
          this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
          return;
        }
        
        if (buttonIndex === displayOptions.length - 1) {
          // è¿”å›ç¬¬1æ­¥
          this.showStartPositionDialog(note, commentOptions, selectedIndices, previousDialog);
          return;
        }
        
        // ç”¨æˆ·é€‰æ‹©äº†ç»“æŸä½ç½®
        const endIndex = buttonIndex - 1;
        const endComment = commentOptions[endIndex];
        
        // æ‰§è¡ŒèŒƒå›´é€‰æ‹©
        this.selectCommentRange(selectedIndices, startComment.index, endComment.index);
        
        // æ˜¾ç¤ºæˆåŠŸæç¤ºå¹¶è¿”å›å¤šé€‰å¯¹è¯æ¡†
        const rangeSize = Math.abs(endComment.index - startComment.index) + 1;
        MNUtil.showHUD(`å·²é€‰æ‹©èŒƒå›´ï¼š#${Math.min(startComment.index, endComment.index) + 1} åˆ° #${Math.max(startComment.index, endComment.index) + 1}ï¼Œå…± ${rangeSize} ä¸ªè¯„è®º`);
        
        this.showCommentMultiSelectDialog(note, commentOptions, selectedIndices, null, previousDialog);
      }
    );
  }

  /**
   * é€‰æ‹©è¯„è®ºèŒƒå›´
   * 
   * @param {Set} selectedIndices - å·²é€‰ä¸­çš„ç´¢å¼•é›†åˆ
   * @param {number} startIndex - èµ·å§‹ç´¢å¼•
   * @param {number} endIndex - ç»“æŸç´¢å¼•
   */
  static selectCommentRange(selectedIndices, startIndex, endIndex) {
    // ç¡®ä¿èµ·å§‹ç´¢å¼•å°äºç»“æŸç´¢å¼•
    const minIndex = Math.min(startIndex, endIndex);
    const maxIndex = Math.max(startIndex, endIndex);
    
    // å°†èŒƒå›´å†…çš„æ‰€æœ‰ç´¢å¼•æ·»åŠ åˆ°é€‰ä¸­é›†åˆ
    for (let i = minIndex; i <= maxIndex; i++) {
      selectedIndices.add(i);
    }
  }

  /**
   * è·å–æ‰€æœ‰å¯é€‰æ‹©çš„è¯„è®ºé€‰é¡¹
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @returns {Array} è¯„è®ºé€‰é¡¹æ•°ç»„
   */
  static getAllCommentOptionsForMove(note) {
    const options = [];
    const comments = note.MNComments;
    
    // æ„å»ºæ‰€æœ‰è¯„è®ºçš„é€‰é¡¹
    for (let i = 0; i < comments.length; i++) {
      const comment = comments[i];
      const displayText = this.formatCommentForDisplay(comment, i, note);
      options.push({
        index: i,
        display: displayText,
        comment: comment
      });
    }
    
    return options;
  }

  /**
   * é€šè¿‡å¼¹çª—ç®¡ç†è¯„è®ºï¼ˆç§»åŠ¨æˆ–åˆ é™¤ï¼‰
   */
  static manageCommentsByPopup(note) {
    // å®šä¹‰é€‰é¡¹å’Œå¯¹åº”çš„å¤„ç†å‡½æ•°
    const optionHandlers = {
      "ğŸ“ æ‰‹åŠ¨è¾“å…¥ Index": () => {
        this.showCommentIndexInputDialog(note, (indices) => {
          if (indices && indices.length > 0) {
            this.showActionSelectionDialog(note, indices, () => {
              // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºä¸»èœå•
              this.manageCommentsByPopup(note);
            });
          }
        }, () => {
          // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºä¸»èœå•
          this.manageCommentsByPopup(note);
        });
      },
      
      "âœ… å¤šé€‰è¯„è®ºå†…å®¹": () => {
        const allOptions = this.getAllCommentOptionsForMove(note);
        const selectedIndices = new Set();
        this.showCommentMultiSelectDialog(note, allOptions, selectedIndices, null, () => {
          // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºä¸»èœå•
          this.manageCommentsByPopup(note);
        });
      },
      
      "ğŸ”„ è‡ªåŠ¨è·å–æ–°å†…å®¹": () => {
        const moveCommentIndexArr = this.autoGetNewContentToMoveIndexArr(note);
        if (moveCommentIndexArr.length === 0) {
          MNUtil.showHUD("æ²¡æœ‰æ£€æµ‹åˆ°æ–°å†…å®¹");
          return;
        }
        this.showActionSelectionDialog(note, moveCommentIndexArr, () => {
          // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºä¸»èœå•
          this.manageCommentsByPopup(note);
        });
      },
      
      "Zï¸âƒ£ æœ€åä¸€æ¡è¯„è®º": () => {
        const moveCommentIndexArr = [note.comments.length - 1];
        this.showActionSelectionDialog(note, moveCommentIndexArr, () => {
          // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºä¸»èœå•
          this.manageCommentsByPopup(note);
        });
      },
      
      "YZ æœ€åä¸¤æ¡è¯„è®º": () => {
        const moveCommentIndexArr = [note.comments.length - 2, note.comments.length - 1];
        this.showActionSelectionDialog(note, moveCommentIndexArr, () => {
          // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºä¸»èœå•
          this.manageCommentsByPopup(note);
        });
      },
      
      "ğŸ“¦ é€‰æ‹©å­—æ®µåŒºåŸŸ": () => {
        this.showFieldSelectionForMove(note, (indices) => {
          if (indices && indices.length > 0) {
            this.showActionSelectionDialog(note, indices, () => {
              // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºä¸»èœå•
              this.manageCommentsByPopup(note);
            });
          }
        }, () => {
          // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºä¸»èœå•
          this.manageCommentsByPopup(note);
        });
      }
    };
    
    // æå–é€‰é¡¹åˆ—è¡¨
    const firstOptions = Object.keys(optionHandlers);
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©è¦ç®¡ç†çš„è¯„è®º",
      "é€‰æ‹©è·å–è¯„è®ºçš„æ–¹å¼",
      0,
      "å–æ¶ˆ",
      firstOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) return; // å–æ¶ˆ
        
        // æ ¹æ®é€‰é¡¹æ‰§è¡Œå¯¹åº”çš„å¤„ç†å‡½æ•°
        const selectedOption = firstOptions[buttonIndex - 1];
        const handler = optionHandlers[selectedOption];
        if (handler) {
          handler();
        }
      }
    );
  }

  /**
   * æ˜¾ç¤ºæ‰‹åŠ¨è¾“å…¥å¯¹è¯æ¡†
   */
  static showCommentIndexInputDialog(note, callback, previousDialog = null) {
    // æ„å»ºé€‰é¡¹æ•°ç»„
    const options = ["ç¡®å®š"];
    if (previousDialog) {
      options.unshift("â¬…ï¸ è¿”å›ä¸Šä¸€å±‚");
    }
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "è¾“å…¥è¦ç§»åŠ¨çš„è¯„è®º Index",
      "â—ï¸ä» 1 å¼€å§‹\næ”¯æŒ:\n- å•ä¸ªåºå·: 1,2,3\n- èŒƒå›´: 1-4 \n- ç‰¹æ®Šå­—ç¬¦: X(å€’æ•°ç¬¬3æ¡), Y(å€’æ•°ç¬¬2æ¡), Z(æœ€åä¸€æ¡)\n- ç»„åˆä½¿ç”¨: 1,3-5,Y,Z",
      2,
      "å–æ¶ˆ",
      options,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          callback(null);
          return;
        }
        
        // å¦‚æœæœ‰è¿”å›é€‰é¡¹ï¼Œå¤„ç†è¿”å›
        if (previousDialog && buttonIndex === 1) {
          previousDialog();
          return;
        }
        
        // ç¡®å®šæŒ‰é’®çš„ç´¢å¼•æ ¹æ®æ˜¯å¦æœ‰è¿”å›é€‰é¡¹è€Œä¸åŒ
        const confirmIndex = previousDialog ? 2 : 1;
        if (buttonIndex === confirmIndex) {
          const userInput = alert.textFieldAtIndex(0).text;
          if (!userInput) {
            MNUtil.showHUD("è¯·è¾“å…¥æœ‰æ•ˆçš„ç´¢å¼•");
            callback(null);
            return;
          }
          
          const indices = userInput.parseCommentIndices(note.comments.length);
          callback(indices);
        }
      }
    );
  }

  /**
   * æ˜¾ç¤ºå­—æ®µé€‰æ‹©å¯¹è¯æ¡†
   */
  static showFieldSelectionForMove(note, callback, previousDialog = null) {
    const htmlCommentsTextArr = this.parseNoteComments(note).htmlCommentsTextArr;
    
    if (htmlCommentsTextArr.length === 0) {
      MNUtil.showHUD("å½“å‰ç¬”è®°æ²¡æœ‰å­—æ®µ");
      callback(null);
      return;
    }
    
    // æ„å»ºé€‰é¡¹æ•°ç»„
    let options = [...htmlCommentsTextArr];
    if (previousDialog) {
      options.unshift("â¬…ï¸ è¿”å›ä¸Šä¸€å±‚");
    }
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©å­—æ®µåŒºåŸŸ",
      "é€‰æ‹©è¦ç§»åŠ¨çš„å­—æ®µå†…å®¹",
      0,
      "å–æ¶ˆ",
      options,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          callback(null);
          return;
        }
        
        // å¦‚æœæœ‰è¿”å›é€‰é¡¹ï¼Œå¤„ç†è¿”å›
        if (previousDialog && buttonIndex === 1) {
          previousDialog();
          return;
        }
        
        // è®¡ç®—å®é™…çš„å­—æ®µç´¢å¼•
        const fieldIndex = previousDialog ? buttonIndex - 2 : buttonIndex - 1;
        const selectedField = htmlCommentsTextArr[fieldIndex];
        const indices = this.getHtmlCommentExcludingFieldBlockIndexArr(note, selectedField);
        
        if (indices.length === 0) {
          MNUtil.showHUD(`å­—æ®µ"${selectedField}"ä¸‹æ²¡æœ‰å†…å®¹`);
          callback(null);
          return;
        }
        
        callback(indices);
      }
    );
  }

  /**
   * æ˜¾ç¤ºæ“ä½œé€‰æ‹©å¯¹è¯æ¡†ï¼ˆç§»åŠ¨ã€æå–æˆ–åˆ é™¤ï¼‰
   */
  static showActionSelectionDialog(note, moveCommentIndexArr, previousDialog = null) {
    // å…ˆè®©ç”¨æˆ·é€‰æ‹©æ“ä½œç±»å‹
    const actionOptions = [
      "â¡ï¸ ç§»åŠ¨è¯„è®º",
      "ğŸ“¤ æå–è¯„è®º",
      "ğŸ—‘ï¸ åˆ é™¤è¯„è®º"
    ];
    
    // å¦‚æœæœ‰ä¸Šä¸€å±‚ï¼Œæ·»åŠ è¿”å›é€‰é¡¹
    if (previousDialog) {
      actionOptions.unshift("â¬…ï¸ è¿”å›ä¸Šä¸€å±‚");
    }
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©æ“ä½œç±»å‹",
      `å·²é€‰æ‹© ${moveCommentIndexArr.length} é¡¹å†…å®¹`,
      0,
      "å–æ¶ˆ",
      actionOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) return; // å–æ¶ˆ
        
        // å¦‚æœæœ‰è¿”å›é€‰é¡¹ï¼Œå¤„ç†è¿”å›
        if (previousDialog && buttonIndex === 1) {
          previousDialog();
          return;
        }
        
        // æ ¹æ®æ˜¯å¦æœ‰è¿”å›é€‰é¡¹è°ƒæ•´ç´¢å¼•
        const offset = previousDialog ? 1 : 0;
        
        if (buttonIndex === 1 + offset) {
          // ç§»åŠ¨è¯„è®º
          this.showMoveTargetSelectionDialog(note, moveCommentIndexArr, () => {
            // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºå½“å‰å¯¹è¯æ¡†
            this.showActionSelectionDialog(note, moveCommentIndexArr, previousDialog);
          });
        } else if (buttonIndex === 2 + offset) {
          // æå–è¯„è®º
          this.performExtract(note, moveCommentIndexArr);
        } else if (buttonIndex === 3 + offset) {
          // åˆ é™¤è¯„è®º
          this.showDeleteConfirmDialog(note, moveCommentIndexArr, () => {
            // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºå½“å‰å¯¹è¯æ¡†
            this.showActionSelectionDialog(note, moveCommentIndexArr, previousDialog);
          });
        }
      }
    );
  }
  
  /**
   * æ˜¾ç¤ºç§»åŠ¨ç›®æ ‡é€‰æ‹©å¯¹è¯æ¡†ï¼ˆç¬¬äºŒå±‚ï¼‰
   */
  static showMoveTargetSelectionDialog(note, moveCommentIndexArr, previousDialog = null) {
    const targetOptions = this.getHtmlCommentsTextArrForPopup(note);
    
    // å¦‚æœæœ‰ä¸Šä¸€å±‚ï¼Œæ·»åŠ è¿”å›é€‰é¡¹
    let options = [...targetOptions];
    if (previousDialog) {
      options.unshift("â¬…ï¸ è¿”å›ä¸Šä¸€å±‚");
    }
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©ç§»åŠ¨çš„ä½ç½®",
      `å°†ç§»åŠ¨ ${moveCommentIndexArr.length} é¡¹å†…å®¹\nç‚¹å‡»å­—æ®µæˆ–å¸¦ â—† çš„é¡¹ç›®å¯é€‰æ‹©æ›´ç²¾ç¡®çš„ä½ç½®`,
      0,
      "å–æ¶ˆ",
      options,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) return; // å–æ¶ˆ
        
        // å¦‚æœæœ‰è¿”å›é€‰é¡¹ï¼Œå¤„ç†è¿”å›
        if (previousDialog && buttonIndex === 1) {
          previousDialog();
          return;
        }
        
        // æ ¹æ®æ˜¯å¦æœ‰è¿”å›é€‰é¡¹è°ƒæ•´ç´¢å¼•
        const optionIndex = previousDialog ? buttonIndex - 2 : buttonIndex - 1;
        const selectedOption = targetOptions[optionIndex];
        
        // åˆ¤æ–­æ˜¯å¦ç‚¹å‡»äº†å­—æ®µåŒºåŸŸ
        if (selectedOption && selectedOption.includes("åŒºã€‘----------") && !selectedOption.includes("æ‘˜å½•åŒº")) {
          // æå–å­—æ®µå
          const matches = selectedOption.match(/ã€(.+?)åŒºã€‘/);
          if (matches && matches[1]) {
            const fieldName = matches[1];
            
            // æ˜¾ç¤ºç¬¬ä¸‰å±‚å¯¹è¯æ¡†
            this.showFieldInternalPositionDialog(note, fieldName, (targetIndex) => {
              if (targetIndex !== null) {
                this.performMove(note, moveCommentIndexArr, targetIndex);
              }
            }, () => {
              // è¿”å›å‡½æ•°ï¼šé‡æ–°æ˜¾ç¤ºå½“å‰å¯¹è¯æ¡†
              this.showMoveTargetSelectionDialog(note, moveCommentIndexArr, previousDialog);
            });
            return;
          }
        }
        
        // ç›´æ¥ç§»åŠ¨åˆ°é€‰å®šä½ç½®
        const targetIndex = this.getCommentsIndexArrToMoveForPopup(note)[optionIndex];
        if (targetIndex !== null) {
          this.performMove(note, moveCommentIndexArr, targetIndex);
        }
      }
    );
  }

  /**
   * æ‰§è¡Œç§»åŠ¨æ“ä½œ
   */
  static performMove(note, moveCommentIndexArr, targetIndex) {
    MNUtil.undoGrouping(() => {
      try {
        note.moveCommentsByIndexArr(moveCommentIndexArr, targetIndex);
        note.refresh();
        // MNUtil.showHUD(`æˆåŠŸç§»åŠ¨ ${moveCommentIndexArr.length} é¡¹å†…å®¹`);
      } catch (error) {
        MNUtil.showHUD("ç§»åŠ¨å¤±è´¥: " + error.message);
        MNUtil.addErrorLog(error, "performMove", {noteId: note.noteId});
      }
    });
  }
  
  /**
   * æ˜¾ç¤ºåˆ é™¤ç¡®è®¤å¯¹è¯æ¡†
   */
  static showDeleteConfirmDialog(note, deleteCommentIndexArr, previousDialog = null) {
    // æ„å»ºè¦åˆ é™¤çš„è¯„è®ºåˆ—è¡¨
    let deleteList = [];
    let isLinkComment = false;
    let linkUrl = null;
    
    deleteCommentIndexArr.forEach(index => {
      const comment = note.MNComments[index];
      if (comment) {
        const displayText = this.formatCommentForDisplay(comment, index, note);
        deleteList.push(`â€¢ ${displayText}`);
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºé“¾æ¥è¯„è®ºï¼ˆä»…å½“åªé€‰ä¸­ä¸€æ¡æ—¶ï¼‰
        if (deleteCommentIndexArr.length === 1 && comment.type === "linkComment") {
          isLinkComment = true;
          linkUrl = comment.text;
        }
      }
    });
    
    const message = `ç¡®å®šè¦åˆ é™¤ä»¥ä¸‹ ${deleteCommentIndexArr.length} é¡¹è¯„è®ºå—ï¼Ÿ\n\n${deleteList.join('\n')}`;
    
    // æ„å»ºé€‰é¡¹æ•°ç»„
    const options = [];
    if (previousDialog) {
      options.push("â¬…ï¸ è¿”å›ä¸Šä¸€å±‚");
    }
    options.push("ğŸ—‘ï¸ ç¡®è®¤åˆ é™¤");
    
    // å¦‚æœæ˜¯å•ä¸ªé“¾æ¥è¯„è®ºï¼Œå¢åŠ å¤åˆ¶é€‰é¡¹
    if (isLinkComment) {
      options.push("ğŸ—‘ï¸ğŸ“‹ ç¡®è®¤å¹¶å¤åˆ¶è¡Œå†…é“¾æ¥");
    }
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "ç¡®è®¤åˆ é™¤",
      message,
      0,
      "å–æ¶ˆ",
      options,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          return; // å–æ¶ˆ
        }
        
        // å¤„ç†è¿”å›é€‰é¡¹
        if (previousDialog && options[buttonIndex - 1] === "â¬…ï¸ è¿”å›ä¸Šä¸€å±‚") {
          previousDialog();
          return;
        }
        
        // å¤„ç†ç¡®è®¤åˆ é™¤
        if (options[buttonIndex - 1] === "ğŸ—‘ï¸ ç¡®è®¤åˆ é™¤") {
          this.performDelete(note, deleteCommentIndexArr);
          return;
        }
        
        // å¤„ç†ç¡®è®¤å¹¶å¤åˆ¶è¡Œå†…é“¾æ¥
        if (options[buttonIndex - 1] === "ğŸ—‘ï¸ğŸ“‹ ç¡®è®¤å¹¶å¤åˆ¶è¡Œå†…é“¾æ¥") {
          // å…ˆæ˜¾ç¤ºè¾“å…¥å¼•ç”¨è¯çš„å¯¹è¯æ¡†
          UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
            "å¤åˆ¶ Markdown ç±»å‹é“¾æ¥",
            "è¾“å…¥å¼•ç”¨è¯",
            2,
            "å–æ¶ˆ",
            ["ç¡®å®š"],
            (inputAlert, inputButtonIndex) => {
              if (inputButtonIndex === 1) {
                // è·å–é“¾æ¥æŒ‡å‘çš„ç¬”è®°
                const linkedNote = MNNote.new(linkUrl);
                let refContent = inputAlert.textFieldAtIndex(0).text;
                
                // å¦‚æœç”¨æˆ·æ²¡æœ‰è¾“å…¥ï¼Œå°è¯•è·å–é“¾æ¥ç¬”è®°çš„æ ‡é¢˜
                if (!refContent && linkedNote) {
                  // å°è¯•ä»é“¾æ¥çš„ç¬”è®°è·å–æ ‡é¢˜
                  const titleParts = KnowledgeBaseTemplate.parseNoteTitle(linkedNote);
                  refContent = titleParts.content || linkedNote.noteTitle || "é“¾æ¥";
                  // å»é™¤å¯èƒ½çš„ "; " å‰ç¼€
                  if (refContent.startsWith("; ")) {
                    refContent = refContent.substring(2).trim();
                  }
                } else if (!refContent) {
                  refContent = "é“¾æ¥";
                }
                
                // ç”Ÿæˆ Markdown é“¾æ¥
                const mdLink = `[${refContent}](${linkUrl})`;
                MNUtil.copy(mdLink);
                MNUtil.showHUD(`å·²å¤åˆ¶: ${mdLink}`);
                
                // ç„¶åæ‰§è¡Œåˆ é™¤æ“ä½œ
                this.performDelete(note, deleteCommentIndexArr);
              }
            }
          );
        }
      }
    );
  }
  
  /**
   * æ‰§è¡Œåˆ é™¤æ“ä½œ
   */
  static performDelete(note, deleteCommentIndexArr) {
    MNUtil.undoGrouping(() => {
      try {
        // ä½¿ç”¨æ‰¹é‡åˆ é™¤ API
        note.removeCommentsByIndexArr(deleteCommentIndexArr);
        
        note.refresh();
        MNUtil.showHUD(`æˆåŠŸåˆ é™¤ ${deleteCommentIndexArr.length} é¡¹è¯„è®º`);
      } catch (error) {
        MNUtil.showHUD("åˆ é™¤å¤±è´¥: " + error.message);
        MNUtil.addErrorLog(error, "performDelete", {noteId: note.noteId});
      }
    });
  }

  /**
   * æ‰§è¡Œæå–æ“ä½œ
   * å°†é€‰ä¸­çš„è¯„è®ºæå–ä¸ºæ–°çš„å­å¡ç‰‡
   */
  static performExtract(note, extractCommentIndexArr) {
    let extractResultNote
    // ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºå­å¡ç‰‡
    MNUtil.undoGrouping(() => {
      try {
        extractResultNote = this.extractComments(note, extractCommentIndexArr)
        
        // åˆ·æ–°æ˜¾ç¤º
        extractResultNote.refresh();
        note.refresh();
        
        MNUtil.showHUD(`æˆåŠŸæå– ${extractCommentIndexArr.length} é¡¹è¯„è®ºä¸ºæ–°å¡ç‰‡`);
        
        // åœ¨è„‘å›¾ä¸­èšç„¦æ–°åˆ›å»ºçš„å¡ç‰‡
        MNUtil.focusNoteInMindMapById(extractResultNote.noteId, 0.5);
        
      } catch (error) {
        MNUtil.showHUD("æå–å¤±è´¥: " + error.message);
        MNUtil.addErrorLog(error, "performExtract", {noteId: note.noteId});
        return; // å‡ºé”™åˆ™ä¸æ˜¾ç¤ºåç»­å¯¹è¯æ¡†
      }
    });
    
    // ç¬¬äºŒæ­¥ï¼šè¯¢é—®æ˜¯å¦åˆ é™¤åŸè¯„è®º
    if (extractResultNote) {
      // å»¶è¿Ÿæ˜¾ç¤ºå¯¹è¯æ¡†ï¼Œç¡®ä¿å‰é¢çš„æ“ä½œå®Œæˆ
      MNUtil.delay(0.5).then(() => {
        UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
          "æå–å®Œæˆ",
          `å·²æˆåŠŸæå– ${extractCommentIndexArr.length} é¡¹è¯„è®ºåˆ°æ–°å¡ç‰‡ã€‚\n\næ˜¯å¦ä»åŸå¡ç‰‡ä¸­åˆ é™¤è¿™äº›è¯„è®ºï¼Ÿ`,
          0,
          "ä¿ç•™åŸè¯„è®º",
          ["åˆ é™¤åŸè¯„è®º"],
          (alert, buttonIndex) => {
            if (buttonIndex === 1) {
              // ç”¨æˆ·é€‰æ‹©åˆ é™¤åŸè¯„è®º
              MNUtil.undoGrouping(() => {
                try {
                  // å…ˆæ¸…ç†è¢«æå–å†…å®¹ä¸­é“¾æ¥å¯¹åº”å¡ç‰‡çš„åå‘é“¾æ¥ï¼ˆå¿…é¡»åœ¨åˆ é™¤å‰æ‰§è¡Œï¼‰
                  this.cleanupExtractedContentLinks(note, extractCommentIndexArr);
                  
                  // ç„¶åä½¿ç”¨æ‰¹é‡åˆ é™¤ API
                  note.removeCommentsByIndexArr(extractCommentIndexArr);
                  
                  note.refresh();
                  MNUtil.showHUD("å·²åˆ é™¤åŸå¡ç‰‡ä¸­çš„è¯„è®ºå¹¶æ¸…ç†ç›¸å…³é“¾æ¥");
                  
                } catch (error) {
                  MNUtil.showHUD("åˆ é™¤åŸè¯„è®ºå¤±è´¥: " + error.message);
                  MNUtil.addErrorLog(error, "performExtract.deleteOriginal", {noteId: note.noteId});
                }
              });
              
              // è¯¢é—®æ˜¯å¦åˆ¶å¡
              this.showMakeNoteDialog(extractResultNote);
            } else {
              // ç”¨æˆ·é€‰æ‹©"ä¿ç•™åŸè¯„è®º"
              // è¯¢é—®æ˜¯å¦åˆ¶å¡
              this.showMakeNoteDialog(extractResultNote);
            }
          }
        );
      });
    }
  }

  static extractComments(note, extractCommentIndexArr) {
    try {
      let clonedNote = note.clone();
      clonedNote.title = ""
      
      // åˆ é™¤å…‹éš†å¡ç‰‡çš„æ‰€æœ‰å­å¡ç‰‡
      if (clonedNote.childNotes && clonedNote.childNotes.length > 0) {
        // ä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–
        for (let i = clonedNote.childNotes.length - 1; i >= 0; i--) {
          clonedNote.childNotes[i].removeFromParent();
        }
      }
      
      // å°†å…‹éš†çš„ç¬”è®°æ·»åŠ ä¸ºåŸç¬”è®°çš„å­å¡ç‰‡
      note.addChild(clonedNote);
      
      // è·å–æ‰€æœ‰è¯„è®ºçš„ç´¢å¼•ï¼Œå¹¶æ’é™¤è¦æå–çš„è¯„è®º
      const allIndices = Array.from({length: clonedNote.comments.length}, (_, i) => i);
      const indicesToDelete = allIndices.filter(i => !extractCommentIndexArr.includes(i));
      
      // ä»å¤§åˆ°å°æ’åºï¼Œé¿å…åˆ é™¤æ—¶ç´¢å¼•å˜åŒ–
      indicesToDelete.sort((a, b) => b - a);
      
      // åˆ é™¤æœªé€‰ä¸­çš„è¯„è®º
      clonedNote.removeCommentsByIndexArr(indicesToDelete);
      
      // å¤„ç†é“¾æ¥å…³ç³»ç»§æ‰¿
      this.handleExtractedNoteLinks(note, clonedNote, extractCommentIndexArr);

      return clonedNote;
    } catch (error) {
      KnowledgeBaseUtils.addErrorLog(error, "extractComments");
    }
  }

  static extractCommentsAndSeparate(note, extractCommentIndexArr) {
    MNUtil.undoGrouping(()=>{
      try {
        let extractedNote = this.extractComments(note, extractCommentIndexArr);
        this.cleanupExtractedContentLinks(note, extractCommentIndexArr);
        note.removeCommentsByIndexArr(extractCommentIndexArr);
        this.splitComments(extractedNote);
      } catch (error) {
        MNUtil.showHUD(error);
        KnowledgeBaseUtils.addErrorLog(error, "extractCommentsAndSeparate");
      }
    })
  }

  /**
   * æ˜¾ç¤ºåˆ¶å¡ç¡®è®¤å¯¹è¯æ¡†
   * @param {MNNote} extractedNote - æå–å‡ºçš„å¡ç‰‡
   */
  static showMakeNoteDialog(extractedNote) {
    // å»¶è¿Ÿæ˜¾ç¤ºå¯¹è¯æ¡†ï¼Œç¡®ä¿å‰é¢çš„æ“ä½œå®Œæˆ
    MNUtil.delay(0.3).then(() => {
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        "åˆ¶å¡ç¡®è®¤",
        "æ˜¯å¦å¯¹æå–çš„å¡ç‰‡è¿›è¡Œåˆ¶å¡å¤„ç†ï¼Ÿ",
        0,
        "å–æ¶ˆ",
        ["åˆ¶å¡"],
        (alert, buttonIndex) => {
          if (buttonIndex === 1) {
            // ç”¨æˆ·é€‰æ‹©åˆ¶å¡
            MNUtil.undoGrouping(() => {
              try {
                // è°ƒç”¨ KnowledgeBaseTemplate.makeNote è¿›è¡Œåˆ¶å¡
                KnowledgeBaseTemplate.makeNote(extractedNote, false);
                MNUtil.showHUD("åˆ¶å¡å®Œæˆ");
              } catch (error) {
                MNUtil.showHUD("åˆ¶å¡å¤±è´¥: " + error.message);
                MNUtil.addErrorLog(error, "showMakeNoteDialog", {noteId: extractedNote.noteId});
              }
            });
          }
          // å¦‚æœé€‰æ‹©å–æ¶ˆï¼Œåˆ™ä¸åšä»»ä½•æ“ä½œ
        }
      );
    });
  }

  /**
   * å¤„ç†æå–å¡ç‰‡çš„é“¾æ¥å…³ç³»ç»§æ‰¿
   * @param {MNNote} originalNote - åŸå¡ç‰‡ A
   * @param {MNNote} extractedNote - æå–å‡ºçš„å¡ç‰‡ B
   * @param {number[]} extractCommentIndexArr - è¢«æå–çš„è¯„è®ºç´¢å¼•æ•°ç»„
   */
  static handleExtractedNoteLinks(originalNote, extractedNote, extractCommentIndexArr) {
    try {
      // 1. è§£ææå–å¡ç‰‡ B ä¸­çš„æ‰€æœ‰è¯„è®º
      const extractedComments = extractedNote.MNComments;
      
      // 2. éå†æ‰€æœ‰è¯„è®ºï¼ŒæŸ¥æ‰¾é“¾æ¥ç±»å‹çš„è¯„è®º
      for (let i = 0; i < extractedComments.length; i++) {
        const comment = extractedComments[i];
        
        if (comment && comment.type === "linkComment") {
          // è·å–é“¾æ¥åˆ°çš„å¡ç‰‡ C
          const linkedNote = MNNote.new(comment.text);
          
          if (linkedNote) {
            // 3. æ£€æŸ¥ C ä¸­æ˜¯å¦æœ‰ A çš„é“¾æ¥
            const linkedNoteComments = linkedNote.MNComments;
            let aLinkIndexInC = -1;
            
            for (let j = 0; j < linkedNoteComments.length; j++) {
              const cComment = linkedNoteComments[j];
              if (cComment && cComment.type === "linkComment") {
                const cLinkedNote = MNNote.new(cComment.text);
                if (cLinkedNote && cLinkedNote.noteId === originalNote.noteId) {
                  aLinkIndexInC = j;
                  break;
                }
              }
            }
            
            // 4. å¦‚æœ C ä¸­æœ‰ A çš„é“¾æ¥
            if (aLinkIndexInC !== -1) {
              // åœ¨ C ä¸­åˆ›å»ºæŒ‡å‘ B çš„å•å‘é“¾æ¥
              linkedNote.appendNoteLink(extractedNote, "To");
              
              // è·å–æ–°åˆ›å»ºçš„é“¾æ¥ç´¢å¼•ï¼ˆåº”è¯¥æ˜¯æœ€åä¸€ä¸ªï¼‰
              const newLinkIndex = linkedNote.comments.length - 1;
              
              // å°†æ–°é“¾æ¥ç§»åŠ¨åˆ° A é“¾æ¥çš„ä¸‹æ–¹
              if (newLinkIndex !== aLinkIndexInC + 1) {
                linkedNote.moveComment(newLinkIndex, aLinkIndexInC + 1);
              }
            }
          }
        }
      }
    } catch (error) {
      MNUtil.addErrorLog(error, "handleExtractedNoteLinks", {
        originalNoteId: originalNote.noteId,
        extractedNoteId: extractedNote.noteId
      });
      // ä¸æŠ›å‡ºé”™è¯¯ï¼Œè®©æå–æ“ä½œç»§ç»­å®Œæˆ
    }
  }

  /**
   * æ¸…ç†è¢«æå–å†…å®¹ä¸­é“¾æ¥å¯¹åº”å¡ç‰‡çš„åå‘é“¾æ¥
   * å½“ç”¨æˆ·é€‰æ‹©åˆ é™¤åŸè¯„è®ºæ—¶è°ƒç”¨ï¼Œç”¨äºä¿æŒé“¾æ¥å…³ç³»çš„ä¸€è‡´æ€§
   * 
   * @param {MNNote} originalNote - åŸå§‹å¡ç‰‡ A
   * @param {number[]} extractCommentIndexArr - è¢«æå–çš„è¯„è®ºç´¢å¼•æ•°ç»„
   */
  static cleanupExtractedContentLinks(originalNote, extractCommentIndexArr) {
    try {
      const originalComments = originalNote.MNComments;
      
      // éå†è¢«æå–çš„è¯„è®ºç´¢å¼•
      for (const index of extractCommentIndexArr) {
        const comment = originalComments[index];
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºé“¾æ¥è¯„è®º
        if (comment && comment.type === "linkComment") {
          // è·å–é“¾æ¥æŒ‡å‘çš„å¡ç‰‡
          const linkedNote = MNNote.new(comment.text);
          
          if (linkedNote) {
            // è§£æé“¾æ¥å¡ç‰‡çš„ç»“æ„
            const commentsObj = this.parseNoteComments(linkedNote);
            const htmlCommentsArr = commentsObj.htmlCommentsObjArr;
            
            if (htmlCommentsArr.length > 0) {
              // è·å–æœ€åä¸€ä¸ªå­—æ®µ
              const lastField = htmlCommentsArr[htmlCommentsArr.length - 1];
              const fieldIndices = lastField.excludingFieldBlockIndexArr;
              
              // å‡†å¤‡è¦åˆ é™¤çš„ç´¢å¼•
              const indicesToRemove = [];
              const originalNoteUrl = originalNote.noteId.toNoteURL();
              
              // æ£€æŸ¥æœ€åå­—æ®µä¸­çš„æ¯ä¸ªè¯„è®º
              for (const fieldIndex of fieldIndices) {
                const fieldComment = linkedNote.MNComments[fieldIndex];
                
                if (fieldComment && fieldComment.type === "linkComment") {
                  // æ£€æŸ¥æ˜¯å¦æŒ‡å‘åŸå¡ç‰‡ A
                  const linkedNoteInField = MNNote.new(fieldComment.text);
                  if (linkedNoteInField && linkedNoteInField.noteId === originalNote.noteId) {
                    indicesToRemove.push(fieldIndex);
                  }
                }
              }
              
              // ä»å¤§åˆ°å°æ’åºå¹¶åˆ é™¤
              if (indicesToRemove.length > 0) {
                indicesToRemove.sort((a, b) => b - a);
                for (const indexToRemove of indicesToRemove) {
                  linkedNote.removeCommentByIndex(indexToRemove);
                }
                linkedNote.refresh();
              }
            }
          }
        }
      }
    } catch (error) {
      MNUtil.addErrorLog(error, "cleanupExtractedContentLinks", {
        originalNoteId: originalNote.noteId
      });
      // ä¸æŠ›å‡ºé”™è¯¯ï¼Œè®©ä¸»æµç¨‹ç»§ç»­
    }
  }

  /**
   * æ‹†åˆ†è¯„è®ºä¸ºç‹¬ç«‹å¡ç‰‡
   * å°†åŒ…å«å¤šæ¡è¯„è®ºçš„å¡ç‰‡æ‹†åˆ†æˆå¤šå¼ ç‹¬ç«‹å¡ç‰‡ï¼Œæ¯å¼ å¡ç‰‡åªä¿ç•™ä¸€æ¡è¯„è®º
   * @param {MNNote} note - è¦æ‹†åˆ†çš„å¡ç‰‡
   */
  static splitComments(note) {
    // æ£€æŸ¥è¯„è®ºæ•°é‡
    if (!note || note.comments.length < 2) {
      MNUtil.showHUD("å¡ç‰‡è¯„è®ºå°‘äº2æ¡ï¼Œæ— éœ€æ‹†åˆ†");
      return;
    }
    
    const parentNote = note.parentNote;
    const commentCount = note.comments.length;
    
    MNUtil.undoGrouping(() => {
      try {
        // å…‹éš† n-1 å¼ å¡ç‰‡
        const clonedNotes = [];
        for (let i = 1; i < commentCount; i++) {
          const clonedNote = note.clone();
          clonedNote.title = "";
          
          // åˆ é™¤å…‹éš†å¡ç‰‡çš„å­å¡ç‰‡
          if (clonedNote.childNotes && clonedNote.childNotes.length > 0) {
            for (let j = clonedNote.childNotes.length - 1; j >= 0; j--) {
              clonedNote.childNotes[j].removeFromParent();
            }
          }
          
          // åªä¿ç•™ç¬¬ i æ¡è¯„è®º
          const indicesToDelete = [];
          for (let j = 0; j < clonedNote.comments.length; j++) {
            if (j !== i) {
              indicesToDelete.push(j);
            }
          }
          indicesToDelete.sort((a, b) => b - a);
          clonedNote.removeCommentsByIndexArr(indicesToDelete);
          
          // æ·»åŠ åˆ°çˆ¶å¡ç‰‡ï¼ˆå¦‚æœæœ‰çˆ¶å¡ç‰‡ï¼‰æˆ–ä½œä¸ºåŸå¡ç‰‡çš„å…„å¼ŸèŠ‚ç‚¹
          if (parentNote) {
            parentNote.addChild(clonedNote);
          } else {
            note.addChild(clonedNote);
          }
          
          this.handleExtractedNoteLinks(note, clonedNote, [i]);
          
          clonedNotes.push(clonedNote);
        }
        
        // åŸå¡ç‰‡åªä¿ç•™ç¬¬ä¸€æ¡è¯„è®º
        const originalIndicesToDelete = [];
        for (let i = 1; i < note.comments.length; i++) {
          originalIndicesToDelete.push(i);
        }
        
        if (originalIndicesToDelete.length > 0) {
          this.cleanupExtractedContentLinks(note, originalIndicesToDelete);
        }
        
        originalIndicesToDelete.sort((a, b) => b - a);
        note.removeCommentsByIndexArr(originalIndicesToDelete);
        
        // åˆ·æ–°æ˜¾ç¤º
        note.refresh();
        clonedNotes.forEach(n => n.refresh());
        
        MNUtil.showHUD(`âœ… æˆåŠŸæ‹†åˆ†ä¸º ${commentCount} å¼ å¡ç‰‡`);
        
        // èšç„¦ç¬¬ä¸€å¼ å…‹éš†çš„å¡ç‰‡ï¼ˆå¯é€‰ï¼‰
        if (clonedNotes.length > 0) {
          MNUtil.delay(0.3).then(() => {
            MNUtil.focusNoteInMindMapById(clonedNotes[0].noteId, 0.3);
          });
        }
        
      } catch (error) {
        MNUtil.showHUD("æ‹†åˆ†å¤±è´¥: " + error.message);
        MNUtil.addErrorLog(error, "splitComments", {noteId: note.noteId});
      }
    });
  }

  /**
   * è·å¾—ä¸€ä¸ªåŸºäº htmlCommentsTextArr çš„æ•°ç»„ä¸“é—¨ç”¨äºç§»åŠ¨è¯„è®º
   * 
   * æ‘˜å½•åŒºä¹Ÿæ˜¯æ”¾åœ¨è¿™ä¸ªåœ°æ–¹å¤„ç†
   * è¿‡æ»¤æ‰åŒ…å«"å…³é”®è¯"çš„å­—æ®µ
   * åŒ…å« HtmlMarkdown è¯„è®ºä½œä¸ºå¯å±•å¼€é€‰é¡¹
   */
  static getHtmlCommentsTextArrForPopup(note) {
    const parsedComments = this.parseNoteComments(note);
    const htmlCommentsObjArr = parsedComments.htmlCommentsObjArr;
    const htmlMarkdownCommentsObjArr = parsedComments.htmlMarkdownCommentsObjArr;
    
    let htmlCommentsTextArrForMove = [
      "ğŸ”ğŸ”ğŸ”ğŸ”å¡ç‰‡æœ€é¡¶ç«¯ğŸ”ğŸ”ğŸ”ğŸ”",
      "----------ã€æ‘˜å½•åŒºã€‘----------",
    ];
    
    // è¿‡æ»¤æ‰åŒ…å«"å…³é”®è¯"çš„å­—æ®µ
    let filteredHtmlCommentsObjArr = htmlCommentsObjArr.filter(obj => !obj.text.includes("å…³é”®è¯"));
    
    // æ„å»ºä¸€ä¸ªåŒ…å«å­—æ®µå’Œ HtmlMarkdown è¯„è®ºçš„ç»¼åˆæ•°ç»„ï¼ŒæŒ‰ç´¢å¼•æ’åº
    let allStructuralElements = [];
    
    // æ·»åŠ å­—æ®µ
    filteredHtmlCommentsObjArr.forEach(field => {
      allStructuralElements.push({
        type: 'field',
        index: field.index,
        text: field.text,
        obj: field
      });
    });
    
    // æ·»åŠ  HtmlMarkdown è¯„è®º
    htmlMarkdownCommentsObjArr.forEach(mdComment => {
      allStructuralElements.push({
        type: 'htmlMarkdown',
        index: mdComment.index,
        obj: mdComment
      });
    });
    
    // æŒ‰ç´¢å¼•æ’åº
    allStructuralElements.sort((a, b) => a.index - b.index);
    
    // æ„å»ºæ˜¾ç¤ºé€‰é¡¹
    for (let i = 0; i < allStructuralElements.length; i++) {
      const element = allStructuralElements[i];
      
      if (element.type === 'field') {
        // å¦‚æœæ˜¯åŸå§‹åˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå­—æ®µï¼Œè·³è¿‡
        let originalIndex = htmlCommentsObjArr.findIndex(obj => obj.index === element.obj.index);
        let lastOriginalIndex = htmlCommentsObjArr.length - 1;
        if (originalIndex === lastOriginalIndex) continue;
        
        let text = element.text.trim();
        htmlCommentsTextArrForMove.push(
          "----------ã€"+ text +"åŒºã€‘----------"
        );
        htmlCommentsTextArrForMove.push("ğŸ” Top ğŸ”");
        htmlCommentsTextArrForMove.push("â¬‡ï¸ Bottom â¬‡ï¸");
        
      } else if (element.type === 'htmlMarkdown') {
        // HtmlMarkdown è¯„è®ºä¸åœ¨ç¬¬äºŒå±‚æ˜¾ç¤º
        // å®ƒä»¬ä¼šåœ¨ç‚¹å‡»å­—æ®µåŒºåŸŸåçš„ç¬¬ä¸‰å±‚æ˜¾ç¤º
        continue;
      }
    }

    htmlCommentsTextArrForMove.push("â¬‡ï¸â¬‡ï¸â¬‡ï¸â¬‡ï¸ å¡ç‰‡æœ€åº•ç«¯ â¬‡ï¸â¬‡ï¸â¬‡ï¸â¬‡ï¸");

    return htmlCommentsTextArrForMove;
  }
  /**
   * è·å– getHtmlCommentsTextArrForPopup è·å¾—çš„æ•°ç»„æ‰€å¯¹åº”è¦ç§»åŠ¨çš„ Index æ„æˆçš„æ•°ç»„
   * 
   * å¿…é¡»ä¸ getHtmlCommentsTextArrForPopup çš„é€»è¾‘å®Œå…¨å¯¹åº”
   */
  static getCommentsIndexArrToMoveForPopup(note) {
    const parsedComments = this.parseNoteComments(note);
    const htmlCommentsObjArr = parsedComments.htmlCommentsObjArr;
    const htmlMarkdownCommentsObjArr = parsedComments.htmlMarkdownCommentsObjArr;
    
    let commentsIndexArrToMove = [
      0,  // å¯¹åº”ï¼š"ğŸ”ğŸ”ğŸ”ğŸ”å¡ç‰‡æœ€é¡¶ç«¯ ğŸ”ğŸ”ğŸ”ğŸ”"
    ];
    
    // æ‘˜å½•åŒº
    let excerptBlockIndexArr = this.getExcerptBlockIndexArr(note);
    if (excerptBlockIndexArr.length == 0) {
      commentsIndexArrToMove.push(0); // å¯¹åº”ï¼š"----------ã€æ‘˜å½•åŒºã€‘----------"
    } else {
      commentsIndexArrToMove.push(excerptBlockIndexArr[excerptBlockIndexArr.length - 1] + 1);
    }
    
    // è¿‡æ»¤æ‰åŒ…å«"å…³é”®è¯"çš„å­—æ®µ
    let filteredHtmlCommentsObjArr = htmlCommentsObjArr.filter(obj => !obj.text.includes("å…³é”®è¯"));
    
    // æ„å»ºç»¼åˆæ•°ç»„ï¼ˆä¸ getHtmlCommentsTextArrForPopup ä¿æŒä¸€è‡´ï¼‰
    let allStructuralElements = [];
    
    filteredHtmlCommentsObjArr.forEach(field => {
      allStructuralElements.push({
        type: 'field',
        index: field.index,
        text: field.text,
        obj: field
      });
    });
    
    htmlMarkdownCommentsObjArr.forEach(mdComment => {
      allStructuralElements.push({
        type: 'htmlMarkdown',
        index: mdComment.index,
        obj: mdComment
      });
    });
    
    allStructuralElements.sort((a, b) => a.index - b.index);
    
    // æ„å»ºç´¢å¼•æ•°ç»„
    for (let i = 0; i < allStructuralElements.length; i++) {
      const element = allStructuralElements[i];
      
      if (element.type === 'field') {
        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€åä¸€ä¸ªå­—æ®µ
        let originalIndex = htmlCommentsObjArr.findIndex(obj => obj.index === element.obj.index);
        let lastOriginalIndex = htmlCommentsObjArr.length - 1;
        if (originalIndex === lastOriginalIndex) continue;
        
        // æ‰¾åˆ°ä¸‹ä¸€ä¸ªå­—æ®µçš„ç´¢å¼•
        let nextFieldIndex;
        if (originalIndex + 1 < htmlCommentsObjArr.length) {
          nextFieldIndex = htmlCommentsObjArr[originalIndex + 1].index;
        } else {
          nextFieldIndex = note.comments.length;
        }
        
        commentsIndexArrToMove.push(nextFieldIndex); // å¯¹åº”ï¼š"----------ã€xxxåŒºã€‘----------"
        commentsIndexArrToMove.push(element.obj.index + 1); // å¯¹åº”ï¼š"ğŸ” Top ğŸ”"
        commentsIndexArrToMove.push(nextFieldIndex); // å¯¹åº”ï¼š"â¬‡ï¸ Bottom â¬‡ï¸"
        
      } else if (element.type === 'htmlMarkdown') {
        // HtmlMarkdown è¯„è®ºä¸åœ¨ç¬¬äºŒå±‚æ˜¾ç¤ºï¼Œä¸éœ€è¦æ·»åŠ ç´¢å¼•
        continue;
      }
    }

    commentsIndexArrToMove.push(note.comments.length); // å¯¹åº”ï¼š"â¬‡ï¸â¬‡ï¸â¬‡ï¸â¬‡ï¸ å¡ç‰‡æœ€åº•ç«¯ â¬‡ï¸â¬‡ï¸â¬‡ï¸â¬‡ï¸"

    return commentsIndexArrToMove;
  }

  /**
   * è‡ªåŠ¨è·å–æ–°å†…å®¹å¹¶ç§»åŠ¨åˆ°æŒ‡å®šå­—æ®µ
   * 
   * æ­¤å‡½æ•°æ˜¯ moveCommentsArrToField çš„ä¼˜åŒ–ç‰ˆæœ¬ï¼Œè‡ªåŠ¨è·å–è¦ç§»åŠ¨çš„å†…å®¹ç´¢å¼•
   * å¹¶å°†å…¶ç§»åŠ¨åˆ°æŒ‡å®šå­—æ®µä¸‹ã€‚é€‚ç”¨äºå¿«é€Ÿæ•´ç†æ–°æ·»åŠ çš„å†…å®¹ã€‚
   * 
   * @param {MNNote} note - è¦æ“ä½œçš„ç¬”è®°å¯¹è±¡
   * @param {string} field - ç›®æ ‡å­—æ®µåç§°ï¼ˆæ”¯æŒ"æ‘˜å½•"/"æ‘˜å½•åŒº"ä½œä¸ºç‰¹æ®Šå­—æ®µï¼‰
   * @param {boolean} [toBottom=true] - æ˜¯å¦ç§»åŠ¨åˆ°å­—æ®µåº•éƒ¨ï¼Œfalse åˆ™ç§»åŠ¨åˆ°å­—æ®µé¡¶éƒ¨
   * @param {boolean} [showEmptyHUD=true] - å½“æ²¡æœ‰å¯ç§»åŠ¨å†…å®¹æ—¶æ˜¯å¦æ˜¾ç¤ºæç¤º
   * @returns {Array<number>} è¿”å›å·²ç§»åŠ¨çš„è¯„è®ºç´¢å¼•æ•°ç»„
   * 
   * @example
   * // å°†æ–°å†…å®¹ç§»åŠ¨åˆ°"è¯æ˜"å­—æ®µåº•éƒ¨
   * KnowledgeBaseTemplate.autoMoveNewContentToField(note, "è¯æ˜");
   * 
   * @example
   * // å°†æ–°å†…å®¹ç§»åŠ¨åˆ°"ç›¸å…³æ€è€ƒ"å­—æ®µé¡¶éƒ¨ï¼Œä¸æ˜¾ç¤ºç©ºå†…å®¹æç¤º
   * let movedIndices = KnowledgeBaseTemplate.autoMoveNewContentToField(note, "ç›¸å…³æ€è€ƒ", false, false);
   * if (movedIndices.length > 0) {
   *   MNUtil.showHUD(`æˆåŠŸç§»åŠ¨ ${movedIndices.length} æ¡å†…å®¹`);
   * }
   * 
   * @example
   * // å°†æ–°å†…å®¹ç§»åŠ¨åˆ°æ‘˜å½•åŒº
   * KnowledgeBaseTemplate.autoMoveNewContentToField(note, "æ‘˜å½•åŒº");
   */
  static autoMoveNewContentToField(note, field, toBottom = true, handleInlineLink = true, showEmptyHUD = false) {
    // è‡ªåŠ¨è·å–è¦ç§»åŠ¨çš„å†…å®¹ç´¢å¼•
    let indexArr = this.autoGetNewContentToMoveIndexArr(note);
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å†…å®¹éœ€è¦ç§»åŠ¨
    if (indexArr.length === 0) {
      if (showEmptyHUD) {
        MNUtil.showHUD("æ²¡æœ‰æ£€æµ‹åˆ°å¯ç§»åŠ¨çš„æ–°å†…å®¹");
      }
      return [];
    }
    
    // æ£€æŸ¥ç›®æ ‡å­—æ®µæ˜¯å¦å­˜åœ¨
    let fieldExists = false;
    
    // ç‰¹æ®Šå¤„ç†æ‘˜å½•åŒº
    if (field === "æ‘˜å½•" || field === "æ‘˜å½•åŒº") {
      fieldExists = true;  // æ‘˜å½•åŒºå§‹ç»ˆå­˜åœ¨
    } else {
      // æ£€æŸ¥ HTML å­—æ®µ
      let htmlCommentsTextArr = this.parseNoteComments(note).htmlCommentsTextArr;
      fieldExists = htmlCommentsTextArr.some(text => text.includes(field));
    }
    
    if (!fieldExists) {
      MNUtil.showHUD(`æœªæ‰¾åˆ°å­—æ®µ"${field}"ï¼Œè¯·æ£€æŸ¥å­—æ®µåç§°`);
      return [];
    }

    // åœ¨ç§»åŠ¨ä¹‹å‰å…ˆæå– markdown é“¾æ¥
    let marginNoteLinks = this.extractMarginNoteLinksFromComments(note, indexArr);
    
    // æ‰§è¡Œç§»åŠ¨æ“ä½œ
    this.moveCommentsArrToField(note, indexArr, field, toBottom);

    if (!["è¯æ˜", "åä¾‹", "åŸç†"].includes(this.normalizeFieldName(field))) {
      return
    }

    // å¤„ç†ä¹‹å‰æå–çš„ MarginNote é“¾æ¥
    if (marginNoteLinks.length > 0 && handleInlineLink) {  // å®šä¹‰ç±»å‹ä¸å¤„ç†
      this.processExtractedMarginNoteLinks(note, marginNoteLinks);
    }
    
    return indexArr;
  }

  /**
   * æ ¹æ®å¡ç‰‡ç±»å‹è‡ªåŠ¨è·å–æ–°å†…å®¹å¹¶ç§»åŠ¨åˆ°ç›¸åº”å­—æ®µ
   * 
   * æ­¤å‡½æ•°åŸºäº autoMoveNewContentToFieldï¼Œä¼šæ ¹æ®å¡ç‰‡ç±»å‹è‡ªåŠ¨ç¡®å®šç›®æ ‡å­—æ®µã€‚
   * æ˜¯æœ€æ™ºèƒ½çš„å†…å®¹æ•´ç†æ–¹æ³•ï¼Œæ— éœ€æ‰‹åŠ¨æŒ‡å®šå­—æ®µã€‚
   * 
   * @param {MNNote} note - è¦æ“ä½œçš„ç¬”è®°å¯¹è±¡  
   * @param {boolean} [toBottom=true] - æ˜¯å¦ç§»åŠ¨åˆ°å­—æ®µåº•éƒ¨ï¼Œfalse åˆ™ç§»åŠ¨åˆ°å­—æ®µé¡¶éƒ¨
   * @param {boolean} [showEmptyHUD=true] - å½“æ²¡æœ‰å¯ç§»åŠ¨å†…å®¹æ—¶æ˜¯å¦æ˜¾ç¤ºæç¤º
   * @returns {{field: string, indices: Array<number>}} è¿”å›ç›®æ ‡å­—æ®µå’Œå·²ç§»åŠ¨çš„è¯„è®ºç´¢å¼•æ•°ç»„
   * 
   * @example
   * // è‡ªåŠ¨æ ¹æ®å¡ç‰‡ç±»å‹ç§»åŠ¨å†…å®¹
   * let result = KnowledgeBaseTemplate.autoMoveNewContentByType(note);
   * if (result.indices.length > 0) {
   *   MNUtil.showHUD(`å·²å°† ${result.indices.length} æ¡å†…å®¹ç§»åŠ¨åˆ°"${result.field}"å­—æ®µ`);
   * }
   * 
   * @example  
   * // ç§»åŠ¨åˆ°å­—æ®µé¡¶éƒ¨ï¼Œä¸æ˜¾ç¤ºç©ºå†…å®¹æç¤º
   * KnowledgeBaseTemplate.autoMoveNewContentByType(note, false, false);
   */
  static autoMoveNewContentByType(note, toBottom = true, showEmptyHUD = true) {
    // æ ¹æ®å¡ç‰‡ç±»å‹ç¡®å®šç›®æ ‡å­—æ®µ
    let noteType = this.getNoteType(note);
    let field = this.getDefaultFieldForType(noteType);
    
    if (!field) {
      if (showEmptyHUD) {
        MNUtil.showHUD(`æœªè¯†åˆ«çš„å¡ç‰‡ç±»å‹ï¼š${noteType || "ç©º"}`);
      }
      return {field: "", indices: []};
    }
    
    // æ‰§è¡Œç§»åŠ¨æ“ä½œ
    let indices = this.autoMoveNewContentToField(note, field, toBottom, showEmptyHUD);
    
    return {field: field, indices: indices};
  }

  /**
   * ç§»åŠ¨å†…å®¹åˆ°æ‘˜å½•åŒº
   * 
   * ä¸“é—¨ç”¨äºå°†å†…å®¹ç§»åŠ¨åˆ°å¡ç‰‡æœ€ä¸Šæ–¹çš„æ‘˜å½•åŒºåŸŸçš„ä¾¿æ·æ–¹æ³•
   * 
   * @param {MNNote} note - è¦æ“ä½œçš„ç¬”è®°å¯¹è±¡
   * @param {Array|string} indexArr - è¦ç§»åŠ¨çš„è¯„è®ºç´¢å¼•æ•°ç»„æˆ–å­—ç¬¦ä¸²
   * @returns {boolean} æ˜¯å¦æˆåŠŸç§»åŠ¨
   * 
   * @example
   * // ç§»åŠ¨æŒ‡å®šç´¢å¼•çš„å†…å®¹åˆ°æ‘˜å½•åŒº
   * KnowledgeBaseTemplate.moveToExcerptArea(note, [1,2,3]);
   * 
   * @example
   * // ä½¿ç”¨å­—ç¬¦ä¸²æ ¼å¼
   * KnowledgeBaseTemplate.moveToExcerptArea(note, "1-3,5");
   */
  static moveToExcerptArea(note, indexArr) {
    try {
      this.moveCommentsArrToField(note, indexArr, "æ‘˜å½•åŒº", true);
      return true;
    } catch (error) {
      MNUtil.showHUD(`ç§»åŠ¨åˆ°æ‘˜å½•åŒºå¤±è´¥: ${error.message || error}`);
      return false;
    }
  }

  /**
   * ç§»åŠ¨è¯„è®ºåˆ°æŒ‡å®šå­—æ®µ
   *
   * **æ”¯æŒå­—æ®µåˆ«å**ï¼šä¼šæ ¹æ®å¡ç‰‡ç±»å‹è‡ªåŠ¨è§£æé€»è¾‘å­—æ®µååˆ°å®é™…å­—æ®µå
   * ä¾‹å¦‚ï¼Œä½¿ç”¨ "è¯æ˜" ä½œä¸ºå­—æ®µåæ—¶ï¼š
   * - å‘½é¢˜/ä¾‹å­å¡ç‰‡ â†’ å®é™…ç§»åŠ¨åˆ° "è¯æ˜" å­—æ®µ
   * - åä¾‹å¡ç‰‡ â†’ å®é™…ç§»åŠ¨åˆ° "åä¾‹" å­—æ®µ
   * - æ€æƒ³æ–¹æ³•å¡ç‰‡ â†’ å®é™…ç§»åŠ¨åˆ° "åŸç†" å­—æ®µ
   *
   * @param {MNNote} note - è¦æ“ä½œçš„ç¬”è®°å¯¹è±¡
   * @param {Array|string} indexArr - è¦ç§»åŠ¨çš„è¯„è®ºç´¢å¼•æ•°ç»„æˆ–å­—ç¬¦ä¸²ï¼ˆæ”¯æŒ "1,3-5,Y,Z" æ ¼å¼ï¼‰
   * @param {string} field - ç›®æ ‡å­—æ®µåç§°ï¼ˆæ”¯æŒé€»è¾‘å­—æ®µåï¼‰ã€‚ç‰¹æ®Šå­—æ®µï¼š
   *                         - "æ‘˜å½•" æˆ– "æ‘˜å½•åŒº" - ç§»åŠ¨åˆ°å¡ç‰‡æœ€ä¸Šæ–¹çš„æ‘˜å½•åŒºåŸŸ
   *                         - "è¯æ˜" - æ ¹æ®å¡ç‰‡ç±»å‹è‡ªåŠ¨è§£æä¸º "è¯æ˜"/"åä¾‹"/"åŸç†"
   *                         - å…¶ä»–å­—æ®µå - ç§»åŠ¨åˆ°å¯¹åº”çš„ HTML å­—æ®µä¸‹
   * @param {boolean} [toBottom=true] - æ˜¯å¦ç§»åŠ¨åˆ°å­—æ®µåº•éƒ¨ï¼Œfalse åˆ™ç§»åŠ¨åˆ°å­—æ®µé¡¶éƒ¨ï¼ˆæ‘˜å½•åŒºé™¤å¤–ï¼‰
   *
   * @example
   * // ç§»åŠ¨åˆ°æ‘˜å½•åŒº
   * KnowledgeBaseTemplate.moveCommentsArrToField(note, [1,2,3], "æ‘˜å½•åŒº");
   *
   * @example
   * // ä½¿ç”¨å­—æ®µåˆ«å - ç»Ÿä¸€ä½¿ç”¨ "è¯æ˜"ï¼Œä¼šè‡ªåŠ¨æ ¹æ®å¡ç‰‡ç±»å‹è§£æ
   * KnowledgeBaseTemplate.moveCommentsArrToField(åä¾‹Note, "1-3", "è¯æ˜");  // å®é™…ç§»åŠ¨åˆ° "åä¾‹" å­—æ®µ
   * KnowledgeBaseTemplate.moveCommentsArrToField(å‘½é¢˜Note, "1-3", "è¯æ˜");  // å®é™…ç§»åŠ¨åˆ° "è¯æ˜" å­—æ®µ
   */
  static moveCommentsArrToField(note, indexArr, field, toBottom = true) {
    // ã€æ–°å¢ã€‘æ ¹æ®å¡ç‰‡ç±»å‹è§£æå®é™…å­—æ®µåï¼ˆæ”¯æŒå­—æ®µåˆ«åï¼‰
    const noteType = this.getNoteType(note);
    const resolvedField = this.resolveFieldName(field, noteType);

    let getHtmlCommentsTextArrForPopup = this.getHtmlCommentsTextArrForPopup(note);
    let commentsIndexArrToMove = this.getCommentsIndexArrToMoveForPopup(note);

    let targetIndex = -1

    // æ ‡å‡†åŒ–å­—æ®µåç§°ï¼Œæ”¯æŒ"æ‘˜å½•"å’Œ"æ‘˜å½•åŒº"çš„ç®€å†™
    let normalizedField = resolvedField;  // ã€ä¿®æ”¹ã€‘ä½¿ç”¨è§£æåçš„å­—æ®µå
    if (resolvedField === "æ‘˜å½•" || resolvedField === "æ‘˜å½•åŒº") {
      normalizedField = "æ‘˜å½•åŒº";  // ç»Ÿä¸€ä¸º"æ‘˜å½•åŒº"ä»¥åŒ¹é…"----------ã€æ‘˜å½•åŒºã€‘----------"
    }
    
    getHtmlCommentsTextArrForPopup.forEach((text, index) => {
      if (text.includes(normalizedField)) {
        if (toBottom) {
          targetIndex = commentsIndexArrToMove[index]
        } else {
          targetIndex = commentsIndexArrToMove[index+1]  // æ³¨æ„è¿™é‡Œçš„ Arr æ˜¯å› ä¸º commentsIndexArrToMove é‡Œçš„å†…å®¹æ˜¯ xx åŒº+top+bottom ç»„åˆ
        }
      }
    })

    if (targetIndex === -1) {
      // æ­¤æ—¶è¦åˆ¤æ–­æ˜¯å¦æ˜¯æœ€åä¸€ä¸ªå­—æ®µï¼Œå› ä¸ºæœ€åä¸€ä¸ªå­—æ®µæ²¡æœ‰å¼„åˆ°å¼¹çª—é‡Œï¼Œæ‰€ä»¥ä¸Šé¢çš„å¤„ç†æ’é™¤äº†æœ€åä¸€ä¸ªå­—æ®µ
      let htmlCommentsTextArr = this.parseNoteComments(note).htmlCommentsTextArr;
      if (htmlCommentsTextArr.length>0) {
        if (htmlCommentsTextArr[htmlCommentsTextArr.length - 1].includes(normalizedField)) {  // ã€ä¿®æ”¹ã€‘ä½¿ç”¨ normalizedField è€Œä¸æ˜¯ field
          if (toBottom) {
            targetIndex = note.comments.length; // ç§»åŠ¨åˆ°å¡ç‰‡æœ€åº•ç«¯
          } else {
            // è·å–æœ€åä¸€ä¸ªå­—æ®µçš„ index
            let htmlCommentsObjArr = this.parseNoteComments(note).htmlCommentsObjArr;
            targetIndex = htmlCommentsObjArr[htmlCommentsObjArr.length - 1].index + 1; // ç§»åŠ¨åˆ°æœ€åä¸€ä¸ªå­—æ®µçš„ä¸‹æ–¹
          }
        }
      }
    }
    let arr = []
    if (targetIndex !== -1) {
      // å¦‚æœæ˜¯å­—ç¬¦ä¸²å°±å¤„ç†ä¸ºæ•°ç»„
      if (typeof indexArr === "string") {
        arr = indexArr.parseCommentIndices(note.comments.length);
      } else {
        arr = indexArr;
      }
      note.moveCommentsByIndexArr(arr, targetIndex)
    }
  }


  /**
   * é€šè¿‡å¼¹çª—é€‰æ‹©å¹¶æ›¿æ¢å­—æ®µå†…å®¹
   * åˆ é™¤å­—æ®µAä¸‹çš„å†…å®¹ï¼Œå¹¶å°†å­—æ®µBä¸‹çš„å†…å®¹æˆ–è‡ªåŠ¨è·å–çš„æ–°å†…å®¹ç§»åŠ¨åˆ°å­—æ®µAä¸‹æ–¹
   */
  static replaceFieldContentByPopup(note) {
    let htmlCommentsTextArr = this.parseNoteComments(note).htmlCommentsTextArr;
    
    if (htmlCommentsTextArr.length < 1) {
      MNUtil.showHUD("éœ€è¦è‡³å°‘ä¸€ä¸ªå­—æ®µæ‰èƒ½æ‰§è¡Œæ›¿æ¢æ“ä½œ");
      return;
    }

    // åˆ›å»ºå­—æ®µé€‰æ‹©èœå•
    let fieldOptions = htmlCommentsTextArr.map(text => text.trim());
    
    // ç¬¬ä¸€ä¸ªå¼¹çª—ï¼šé€‰æ‹©ç›®æ ‡å­—æ®µ
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©ç›®æ ‡å­—æ®µ",
      "é€‰æ‹©è¦è¢«æ›¿æ¢å†…å®¹çš„å­—æ®µ",
      0,  // æ™®é€šæ ·å¼
      "å–æ¶ˆ",
      fieldOptions,
      (_, buttonIndex) => {
        if (buttonIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
        
        let fieldA = fieldOptions[buttonIndex - 1]; // buttonIndexä»1å¼€å§‹
        
        // åˆ›å»ºå†…å®¹æ¥æºé€‰æ‹©èœå•
        let sourceOptions = ["è‡ªåŠ¨è·å–æ–°å†…å®¹"];
        
        // æ·»åŠ å…¶ä»–å­—æ®µä½œä¸ºé€‰é¡¹ï¼ˆæ’é™¤å·²é€‰çš„ç›®æ ‡å­—æ®µï¼‰
        let otherFields = fieldOptions.filter((_, index) => index !== buttonIndex - 1);
        sourceOptions = sourceOptions.concat(otherFields.map(field => `æ¥è‡ªå­—æ®µï¼š${field}`));
        
        // ç¬¬äºŒä¸ªå¼¹çª—ï¼šé€‰æ‹©å†…å®¹æ¥æº
        UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
          "é€‰æ‹©å†…å®¹æ¥æº",
          `é€‰æ‹©è¦ç§»åŠ¨åˆ°"${fieldA}"å­—æ®µä¸‹çš„å†…å®¹æ¥æº`,
          0,  // æ™®é€šæ ·å¼
          "å–æ¶ˆ",
          sourceOptions,
          (_, buttonIndexB) => {
            if (buttonIndexB === 0) return; // ç”¨æˆ·å–æ¶ˆ
            
            if (buttonIndexB === 1) {
              // é€‰æ‹©äº†"è‡ªåŠ¨è·å–æ–°å†…å®¹"
              this.replaceFieldContentWithAutoContent(note, fieldA);
            } else {
              // é€‰æ‹©äº†æŸä¸ªå­—æ®µ
              let fieldB = otherFields[buttonIndexB - 2]; // å‡å»"è‡ªåŠ¨è·å–æ–°å†…å®¹"é€‰é¡¹
              this.replaceFieldContent(note, fieldA, fieldB);
            }
          }
        );
      }
    );
  }

  /**
   * ä½¿ç”¨è‡ªåŠ¨è·å–çš„æ–°å†…å®¹æ›¿æ¢å­—æ®µå†…å®¹
   * @param {MNNote} note - ç›®æ ‡ç¬”è®°
   * @param {string} fieldA - ç›®æ ‡å­—æ®µåç§°
   */
  static replaceFieldContentWithAutoContent(note, fieldA) {
    let commentsObj = this.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    
    if (htmlCommentsObjArr.length === 0) {
      MNUtil.showHUD("æœªæ‰¾åˆ°å­—æ®µç»“æ„");
      return;
    }

    // é€šè¿‡å­—æ®µåç§°æ‰¾åˆ°å¯¹åº”çš„å­—æ®µå¯¹è±¡
    let fieldAObj = htmlCommentsObjArr.find(obj => obj.text.includes(fieldA));
    
    if (!fieldAObj) {
      MNUtil.showHUD(`æ— æ³•æ‰¾åˆ°å­—æ®µ"${fieldA}"`);
      return;
    }
    
    // è·å–è‡ªåŠ¨è¯†åˆ«çš„æ–°å†…å®¹ç´¢å¼•
    let autoContentIndices = this.autoGetNewContentToMoveIndexArr(note);
    
    if (autoContentIndices.length === 0) {
      // MNUtil.showHUD("æ²¡æœ‰æ£€æµ‹åˆ°å¯ç§»åŠ¨çš„æ–°å†…å®¹");
      return;
    }
    
    // è·å–å­—æ®µAä¸‹çš„å†…å®¹ç´¢å¼•ï¼ˆä¸åŒ…æ‹¬å­—æ®µæ ‡é¢˜æœ¬èº«ï¼‰
    let fieldAContentIndices = fieldAObj.excludingFieldBlockIndexArr;
    
    MNUtil.undoGrouping(() => {
      // å…ˆå¤„ç†å­—æ®µAä¸­è¦åˆ é™¤çš„åŒå‘é“¾æ¥
      if (fieldAContentIndices.length > 0) {
        for (const index of fieldAContentIndices) {
          const comment = note.MNComments[index];
          
          // æ£€æŸ¥æ˜¯å¦ä¸ºé“¾æ¥ç±»å‹çš„è¯„è®º
          if (comment && comment.type === "linkComment" && comment.text) {
            const linkUrl = comment.text.trim();
            
            // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ç¬”è®°é“¾æ¥
            if (linkUrl.isValidNoteURL()) {
              try {
                // ç›´æ¥ä½¿ç”¨ URL åˆ›å»º MNNote
                const targetNote = MNNote.new(linkUrl);
                if (targetNote) {
                  // åˆ é™¤ç›®æ ‡ç¬”è®°ä¸­çš„åå‘é“¾æ¥
                  const removed = this.removeReverseLink(targetNote, note.noteId);
                  if (removed) {
                    MNUtil.log(`å·²åˆ é™¤åŒå‘é“¾æ¥: ${linkUrl}`);
                  }
                }
              } catch (error) {
                MNUtil.log(`å¤„ç†åŒå‘é“¾æ¥æ—¶å‡ºé”™: ${error}`);
              }
            }
          }
        }
        
        // åˆ é™¤å­—æ®µAä¸‹çš„å†…å®¹ï¼ˆä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–ï¼‰
        let sortedFieldAIndices = fieldAContentIndices.sort((a, b) => b - a);
        sortedFieldAIndices.forEach(index => {
          note.removeCommentByIndex(index);
        });
      }
      
      // é‡æ–°è§£æè¯„è®ºç»“æ„ï¼ˆå› ä¸ºåˆ é™¤æ“ä½œæ”¹å˜äº†ç´¢å¼•ï¼‰
      commentsObj = this.parseNoteComments(note);
      htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
      
      // é‡æ–°è·å–è‡ªåŠ¨å†…å®¹ç´¢å¼•ï¼ˆç´¢å¼•å¯èƒ½å·²ç»æ”¹å˜ï¼‰
      autoContentIndices = this.autoGetNewContentToMoveIndexArr(note);
      
      if (autoContentIndices.length === 0) {
        MNUtil.showHUD("åˆ é™¤åŸå†…å®¹åï¼Œæ²¡æœ‰æ£€æµ‹åˆ°å¯ç§»åŠ¨çš„æ–°å†…å®¹");
        return;
      }
      
      // ç§»åŠ¨è‡ªåŠ¨è·å–çš„å†…å®¹åˆ°å­—æ®µAä¸‹æ–¹
      this.moveCommentsArrToField(note, autoContentIndices, fieldA, true);
      
      // åˆ·æ–°å¡ç‰‡æ˜¾ç¤º
      note.refresh();
    });
    
    // MNUtil.showHUD(`å·²å°†è‡ªåŠ¨è·å–çš„æ–°å†…å®¹ç§»åŠ¨åˆ°"${fieldA}"å­—æ®µä¸‹ï¼Œå¹¶åˆ é™¤äº†åŸæœ‰å†…å®¹`);
  }

  /**
   * æ›¿æ¢å­—æ®µå†…å®¹çš„æ ¸å¿ƒæ–¹æ³•
   * @param {MNNote} note - ç›®æ ‡ç¬”è®°
   * @param {string} fieldA - ç›®æ ‡å­—æ®µåç§°
   * @param {string} fieldB - æºå­—æ®µåç§°
   */
  /**
   * åˆ é™¤ç›®æ ‡ç¬”è®°ä¸­æŒ‡å‘æºç¬”è®°çš„åå‘é“¾æ¥
   * @param {Object} targetNote - ç›®æ ‡ç¬”è®°å¯¹è±¡ï¼ˆå¯ä»¥æ˜¯åŸç”Ÿnoteæˆ–MNNoteï¼‰
   * @param {String} sourceNoteId - æºç¬”è®°çš„ID
   * @returns {Boolean} æ˜¯å¦æˆåŠŸåˆ é™¤äº†åå‘é“¾æ¥
   */
  static removeReverseLink(targetNote, sourceNoteId) {
    try {
      const targetMNNote = MNNote.new(targetNote);
      const commentsObj = this.parseNoteComments(targetMNNote);
      
      // ä¼˜å…ˆåœ¨"åº”ç”¨"å­—æ®µæŸ¥æ‰¾
      const appField = commentsObj.htmlCommentsObjArr.find(field => {
        const fieldText = field.text.trim();
        return fieldText === "åº”ç”¨" || fieldText === "åº”ç”¨:" || fieldText === "åº”ç”¨ï¼š";
      });
      
      if (appField) {
        // åœ¨åº”ç”¨å­—æ®µä¸‹æŸ¥æ‰¾å¹¶åˆ é™¤åå‘é“¾æ¥
        const fieldIndices = appField.excludingFieldBlockIndexArr;
        
        for (let i = fieldIndices.length - 1; i >= 0; i--) {
          const index = fieldIndices[i];
          const comment = targetMNNote.MNComments[index];
          
          if (comment && comment.type === "linkComment" && comment.text) {
            const commentText = comment.text.trim();
            // ä½¿ç”¨ includes è¿›è¡Œçµæ´»åŒ¹é…
            if (commentText.isValidNoteURL() && commentText.includes(sourceNoteId)) {
              targetMNNote.removeCommentByIndex(index);
              return true; // æ‰¾åˆ°å¹¶åˆ é™¤
            }
          }
        }
      }
      
      // å¦‚æœåº”ç”¨å­—æ®µæ²¡æ‰¾åˆ°ï¼Œéå†æ‰€æœ‰å­—æ®µæŸ¥æ‰¾åå‘é“¾æ¥
      for (const field of commentsObj.htmlCommentsObjArr) {
        const fieldIndices = field.excludingFieldBlockIndexArr;
        
        for (let i = fieldIndices.length - 1; i >= 0; i--) {
          const index = fieldIndices[i];
          const comment = targetMNNote.MNComments[index];
          
          if (comment && comment.type === "linkComment" && comment.text) {
            const commentText = comment.text.trim();
            // ä½¿ç”¨ includes è¿›è¡Œæ›´çµæ´»çš„åŒ¹é…
            if (commentText.isValidNoteURL() && commentText.includes(sourceNoteId)) {
              targetMNNote.removeCommentByIndex(index);
              return true; // æ‰¾åˆ°å¹¶åˆ é™¤
            }
          }
        }
      }
      
      // å¦‚æœåœ¨å­—æ®µä¸­æ²¡æ‰¾åˆ°ï¼ˆæˆ–æ ¹æœ¬æ²¡æœ‰HTMLå­—æ®µï¼‰ï¼Œéå†æ‰€æœ‰è¯„è®ºæŸ¥æ‰¾é“¾æ¥
      const allComments = targetMNNote.MNComments;
      for (let i = allComments.length - 1; i >= 0; i--) {
        const comment = allComments[i];
        
        // è·³è¿‡ HTML å­—æ®µæœ¬èº«
        if (comment && comment.type === "HtmlComment") {
          continue;
        }
        
        // åªå¤„ç†é“¾æ¥ç±»å‹çš„è¯„è®º
        if (comment && comment.type === "linkComment" && comment.text) {
          const commentText = comment.text.trim();
          
          // ä½¿ç”¨çµæ´»åŒ¹é…ï¼šæ£€æŸ¥é“¾æ¥æ˜¯å¦æŒ‡å‘æºç¬”è®°
          if (commentText.isValidNoteURL()) {
            const linkNoteId = commentText.toNoteId();
            if (linkNoteId === sourceNoteId) {
              targetMNNote.removeCommentByIndex(i);
              return true; // æ‰¾åˆ°å¹¶åˆ é™¤
            }
          }
        }
      }
      
      return false; // æœªæ‰¾åˆ°åå‘é“¾æ¥
      
    } catch (error) {
      MNUtil.log("removeReverseLink å‡ºé”™: " + error.toString());
      return false;
    }
  }

  static replaceFieldContent(note, fieldA, fieldB) {
    let commentsObj = this.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    
    if (htmlCommentsObjArr.length === 0) {
      MNUtil.showHUD("æœªæ‰¾åˆ°å­—æ®µç»“æ„");
      return;
    }

    // é€šè¿‡å­—æ®µåç§°æ‰¾åˆ°å¯¹åº”çš„å­—æ®µå¯¹è±¡
    let fieldAObj = htmlCommentsObjArr.find(obj => obj.text.includes(fieldA));
    let fieldBObj = htmlCommentsObjArr.find(obj => obj.text.includes(fieldB));
    
    if (!fieldAObj) {
      MNUtil.showHUD(`æ— æ³•æ‰¾åˆ°å­—æ®µ"${fieldA}"`);
      return;
    }
    
    if (!fieldBObj) {
      MNUtil.showHUD(`æ— æ³•æ‰¾åˆ°å­—æ®µ"${fieldB}"`);
      return;
    }
    
    // è·å–å­—æ®µAä¸‹çš„å†…å®¹ç´¢å¼•ï¼ˆä¸åŒ…æ‹¬å­—æ®µæ ‡é¢˜æœ¬èº«ï¼‰
    let fieldAContentIndices = fieldAObj.excludingFieldBlockIndexArr;
    
    // è·å–å­—æ®µBä¸‹çš„å†…å®¹ç´¢å¼•ï¼ˆä¸åŒ…æ‹¬å­—æ®µæ ‡é¢˜æœ¬èº«ï¼‰
    let fieldBContentIndices = fieldBObj.excludingFieldBlockIndexArr;
    
    if (fieldBContentIndices.length === 0) {
      MNUtil.showHUD(`å­—æ®µ"${fieldB}"ä¸‹æ²¡æœ‰å†…å®¹å¯ç§»åŠ¨`);
      return;
    }
    
    MNUtil.undoGrouping(() => {
      // å…ˆå¤„ç†å­—æ®µAä¸­è¦åˆ é™¤çš„åŒå‘é“¾æ¥
      if (fieldAContentIndices.length > 0) {
        for (const index of fieldAContentIndices) {
          const comment = note.MNComments[index];
          
          // æ£€æŸ¥æ˜¯å¦ä¸ºé“¾æ¥ç±»å‹çš„è¯„è®º
          if (comment && comment.type === "linkComment" && comment.text) {
            const linkUrl = comment.text.trim();
            
            // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ç¬”è®°é“¾æ¥
            if (linkUrl.isValidNoteURL()) {
              try {
                // ç›´æ¥ä½¿ç”¨ URL åˆ›å»º MNNote
                const targetNote = MNNote.new(linkUrl);
                if (targetNote) {
                  // åˆ é™¤ç›®æ ‡ç¬”è®°ä¸­çš„åå‘é“¾æ¥
                  const removed = this.removeReverseLink(targetNote, note.noteId);
                  if (removed) {
                    MNUtil.log(`å·²åˆ é™¤åŒå‘é“¾æ¥: ${linkUrl}`);
                  }
                }
              } catch (error) {
                MNUtil.log(`å¤„ç†åŒå‘é“¾æ¥æ—¶å‡ºé”™: ${error}`);
              }
            }
          }
        }
        
        // åˆ é™¤å­—æ®µAä¸‹çš„å†…å®¹ï¼ˆä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–ï¼‰
        let sortedFieldAIndices = fieldAContentIndices.sort((a, b) => b - a);
        sortedFieldAIndices.forEach(index => {
          note.removeCommentByIndex(index);
        });
      }
      
      // é‡æ–°è§£æè¯„è®ºç»“æ„ï¼ˆå› ä¸ºåˆ é™¤æ“ä½œæ”¹å˜äº†ç´¢å¼•ï¼‰
      commentsObj = this.parseNoteComments(note);
      htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
      
      // é‡æ–°è·å–å­—æ®µBçš„å†…å®¹ï¼ˆç´¢å¼•å¯èƒ½å·²ç»æ”¹å˜ï¼‰
      fieldBObj = htmlCommentsObjArr.find(obj => obj.text.includes(fieldB));
      if (!fieldBObj) {
        MNUtil.showHUD(`æ— æ³•æ‰¾åˆ°å­—æ®µ"${fieldB}"`);
        return;
      }
      
      fieldBContentIndices = fieldBObj.excludingFieldBlockIndexArr;
      
      if (fieldBContentIndices.length === 0) {
        MNUtil.showHUD(`å­—æ®µ"${fieldB}"ä¸‹æ²¡æœ‰å†…å®¹å¯ç§»åŠ¨`);
        return;
      }
      
      // ç§»åŠ¨å­—æ®µBçš„å†…å®¹åˆ°å­—æ®µAä¸‹æ–¹
      this.moveCommentsArrToField(note, fieldBContentIndices, fieldA, true);
      
      // åˆ·æ–°å¡ç‰‡æ˜¾ç¤º
      note.refresh();
    });
    
    // MNUtil.showHUD(`å·²å°†"${fieldB}"å­—æ®µçš„å†…å®¹ç§»åŠ¨åˆ°"${fieldA}"å­—æ®µä¸‹ï¼Œå¹¶åˆ é™¤äº†"${fieldA}"åŸæœ‰å†…å®¹`);
  }
  
  /**
   * åˆ é™¤æ ¹å¡ç‰‡ä¸‹æ‰€æœ‰å½’ç±»å¡ç‰‡ï¼Œä¿ç•™éå½’ç±»å¡ç‰‡
   * 
   * è¯¥å‡½æ•°ä¼šéå†æ ¹å¡ç‰‡çš„æ‰€æœ‰å­å­™å¡ç‰‡ï¼Œå°†å½’ç±»å¡ç‰‡åˆ é™¤ï¼Œ
   * åŒæ—¶å°†å½’ç±»å¡ç‰‡ä¸‹çš„éå½’ç±»å­å­™å¡ç‰‡æå‡åˆ°æ ¹å¡ç‰‡ä¸‹ã€‚
   * 
   * å·¥ä½œæµç¨‹ï¼š
   * 1. éå†æ ¹å¡ç‰‡çš„æ¯ä¸ªç›´æ¥å­å¡ç‰‡
   * 2. å¦‚æœæ˜¯å½’ç±»å¡ç‰‡ï¼Œæ·±åº¦ä¼˜å…ˆæœç´¢å…¶å­å­™å¡ç‰‡
   * 3. æ‰¾åˆ°ç¬¬ä¸€ä¸ªéå½’ç±»å¡ç‰‡åï¼Œå°†å…¶ç§»åŠ¨åˆ°æ ¹å¡ç‰‡ä¸‹
   * 4. æœ€ååˆ é™¤æ‰€æœ‰å½’ç±»å¡ç‰‡é“¾
   * 
   * @param {MNNote} rootNote - æ ¹å¡ç‰‡ï¼Œå…¶å­å­™ä¸­çš„å½’ç±»å¡ç‰‡å°†è¢«åˆ é™¤
   * @returns {void}
   * 
   * @example
   * // å‡è®¾æœ‰å¦‚ä¸‹ç»“æ„ï¼š
   * // A (æ ¹å¡ç‰‡)
   * // â”œâ”€â”€ å½’ç±»1
   * // â”‚   â”œâ”€â”€ å½’ç±»1.1
   * // â”‚   â”‚   â””â”€â”€ çŸ¥è¯†ç‚¹1
   * // â”‚   â””â”€â”€ çŸ¥è¯†ç‚¹2
   * // â””â”€â”€ å½’ç±»2
   * //     â””â”€â”€ çŸ¥è¯†ç‚¹3
   * 
   * let rootNote = MNNote.getFocusNote();
   * KnowledgeBaseTemplate.removeAllClassificationNotes(rootNote);
   * 
   * // æ‰§è¡Œåç»“æ„å˜ä¸ºï¼š
   * // A (æ ¹å¡ç‰‡)
   * // â”œâ”€â”€ çŸ¥è¯†ç‚¹1
   * // â”œâ”€â”€ çŸ¥è¯†ç‚¹2
   * // â””â”€â”€ çŸ¥è¯†ç‚¹3
   */
  static removeAllClassificationNotes(rootNote) {
    // å‚æ•°æ£€æŸ¥
    if (!rootNote) {
      MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ ¹å¡ç‰‡", 2);
      return;
    }
    
    // è·å–æ‰€æœ‰ç›´æ¥å­å¡ç‰‡
    const childNotes = rootNote.childNotes || [];
    if (childNotes.length === 0) {
      MNUtil.showHUD("æ ¹å¡ç‰‡æ²¡æœ‰å­å¡ç‰‡", 2);
      return;
    }
    
    // è®°å½•éœ€è¦åˆ é™¤çš„å½’ç±»å¡ç‰‡å’Œéœ€è¦ä¿ç•™çš„éå½’ç±»å¡ç‰‡
    const classificationNotesToDelete = [];
    const nonClassificationNotesToKeep = [];
    
    /**
     * æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œæ‰¾åˆ°å½’ç±»å¡ç‰‡é“¾ä¸­çš„æ‰€æœ‰éå½’ç±»å¡ç‰‡
     * @param {MNNote} note - å½“å‰å¤„ç†çš„å¡ç‰‡
     * @param {Array} result - æ”¶é›†çš„éå½’ç±»å¡ç‰‡æ•°ç»„
     */
    function findNonClassificationNotes(note, result) {
      if (!note || !note.childNotes) return;
      
      for (const child of note.childNotes) {
        if (KnowledgeBaseTemplate.isClassificationNote(child)) {
          // å¦‚æœæ˜¯å½’ç±»å¡ç‰‡ï¼Œç»§ç»­é€’å½’æœç´¢
          findNonClassificationNotes(child, result);
        } else {
          // æ‰¾åˆ°éå½’ç±»å¡ç‰‡ï¼Œæ·»åŠ åˆ°ç»“æœä¸­
          // æ³¨æ„ï¼šè¿™é‡Œåªæ·»åŠ å¡ç‰‡æœ¬èº«ï¼Œå…¶å­å­™ä¼šè·Ÿç€ä¸€èµ·ç§»åŠ¨
          result.push(child);
        }
      }
    }
    
    // ç¬¬ä¸€æ­¥ï¼šåˆ†ææ¯ä¸ªç›´æ¥å­å¡ç‰‡
    for (const childNote of childNotes) {
      if (KnowledgeBaseTemplate.isClassificationNote(childNote)) {
        // è®°å½•å½’ç±»å¡ç‰‡ä»¥ä¾¿åç»­åˆ é™¤
        classificationNotesToDelete.push(childNote);
        
        // æœç´¢è¯¥å½’ç±»å¡ç‰‡ä¸‹çš„æ‰€æœ‰éå½’ç±»å¡ç‰‡
        const nonClassificationInBranch = [];
        findNonClassificationNotes(childNote, nonClassificationInBranch);
        
        // è®°å½•æ‰¾åˆ°çš„éå½’ç±»å¡ç‰‡
        nonClassificationNotesToKeep.push(...nonClassificationInBranch);
      }
      // å¦‚æœä¸æ˜¯å½’ç±»å¡ç‰‡ï¼Œä¿æŒåŸæ ·ï¼ˆå·²ç»æ˜¯æ ¹å¡ç‰‡çš„å­å¡ç‰‡ï¼‰
    }
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•å½’ç±»å¡ç‰‡
    if (classificationNotesToDelete.length === 0) {
      MNUtil.showHUD("æ²¡æœ‰æ‰¾åˆ°å½’ç±»å¡ç‰‡", 2);
      return;
    }
    
    // ä½¿ç”¨ undoGrouping åŒ…è£…æ‰€æœ‰æ“ä½œï¼Œä½¿å…¶å¯ä»¥ä¸€æ¬¡æ’¤é”€
    MNUtil.undoGrouping(() => {
      try {
        // ç¬¬äºŒæ­¥ï¼šå°†æ‰€æœ‰éå½’ç±»å¡ç‰‡ç§»åŠ¨åˆ°æ ¹å¡ç‰‡ä¸‹
        for (const note of nonClassificationNotesToKeep) {
          // ä½¿ç”¨ addChild å°†å¡ç‰‡ç§»åŠ¨åˆ°æ ¹å¡ç‰‡ä¸‹
          // è¿™ä¼šè‡ªåŠ¨å¤„ç†ä»åŸçˆ¶å¡ç‰‡ç§»é™¤çš„æ“ä½œ
          rootNote.addChild(note);
        }
        
        // ç¬¬ä¸‰æ­¥ï¼šåˆ é™¤æ‰€æœ‰å½’ç±»å¡ç‰‡ï¼ˆåŠå…¶å‰©ä½™çš„å­å­™å½’ç±»å¡ç‰‡ï¼‰
        for (const classificationNote of classificationNotesToDelete) {
          // ä½¿ç”¨ delete(true) åˆ é™¤æ•´ä¸ªå­æ ‘
          classificationNote.delete(true);
        }
        
        // åˆ·æ–°æ ¹å¡ç‰‡æ˜¾ç¤º
        rootNote.refresh();
        
        // æ˜¾ç¤ºæ“ä½œç»“æœ
        const message = `å·²åˆ é™¤ ${classificationNotesToDelete.length} ä¸ªå½’ç±»å¡ç‰‡ï¼Œä¿ç•™äº† ${nonClassificationNotesToKeep.length} ä¸ªçŸ¥è¯†ç‚¹å¡ç‰‡`;
        MNUtil.showHUD(message, 2);
        
      } catch (error) {
        MNUtil.copyJSON(error);
        MNUtil.showHUD("æ“ä½œå¤±è´¥ï¼š" + error.message, 3);
      }
    });
  }
  
  /**
   * è·å– Note çš„æ‘˜å½•åŒºçš„ indexArr
   * 
   * all: æ˜¯å¦æ˜¯æ‰€æœ‰ï¼ŒåŒ…æ‹¬å¯èƒ½å­˜åœ¨çš„æ–‡æœ¬è¯„è®º
   */
  static getExcerptBlockIndexArr(note, all = false) {
    let indexArr = []
    let endIndex = this.parseNoteComments(note).htmlCommentsObjArr[0]?.index? this.parseNoteComments(note).htmlCommentsObjArr[0].index : -1;
    switch (endIndex) {
      case 0:
        break;
      case -1: // æ­¤æ—¶æ²¡æœ‰ html è¯„è®º
        if (all) {
          indexArr = Array.from({length: note.comments.length}, (_, i) => i)
          break;
        }
        for (let i = 0; i < note.comments.length-1; i++) {
          let comment = note.MNComments[i]
          if (i == 0) {
            if (comment.type == "mergedImageComment") {
              indexArr.push(i)
            } else {
              return []
            }
          } else {
            // è¦ä¿æŒè¿ç»­
            if (comment.type == "mergedImageComment" && note.MNComments[i-1].type == "mergedImageComment") {
              indexArr.push(i)
            }
          }
        }
        break;
      default:
        if (all)  {
          indexArr = Array.from({length: endIndex}, (_, i) => i)
          break;
        }
        for (let i = 0; i < endIndex; i++) {
          let comment = note.MNComments[i]
          if (comment.type == "mergedImageComment") {
            indexArr.push(i)
          }
        }
        break;
    }

    return indexArr
  }

  /**
   * è·å– Note çš„â€œæ‘˜å½•åŒºâ€çš„é“¾æ¥ indexArr
   */
  static getLinksIndexArrInExcerptBlock(note) {
    let indexArr = []
    let endIndex = this.parseNoteComments(note).htmlCommentsObjArr[0]?.index? this.parseNoteComments(note).htmlCommentsObjArr[0].index : -1;
    switch (endIndex) {
      case 0:
      case -1: // æ­¤æ—¶æ²¡æœ‰ html è¯„è®º
        break;
      default:
        for (let i = 0; i < endIndex; i++) {
          let comment = note.MNComments[i]
          if (comment.type == "linkComment") {
            indexArr.push(i)
          }
        }
        break;
    }

    return indexArr
  }
  /**
   * è·å–åŒ…å«æŸæ®µæ–‡æœ¬çš„ HtmlComment çš„ Block
   */
  static getHtmlCommentIncludingFieldBlockIndexArr(note, text) {
    let commentsObj = this.parseNoteComments(note);
    let indexArr = []
    commentsObj.htmlCommentsObjArr.forEach(htmlComment => {
      if (htmlComment.text.includes(text)) {
        indexArr = htmlComment.includingFieldBlockIndexArr;
      }
    })
    return indexArr
  }
  static getHtmlCommentExcludingFieldBlockIndexArr(note, text) {
    let commentsObj = this.parseNoteComments(note);
    let indexArr = []
    commentsObj.htmlCommentsObjArr.forEach(htmlComment => {
      if (htmlComment.text.includes(text)) {
        indexArr = htmlComment.excludingFieldBlockIndexArr;
      }
    })
    return indexArr
  }

  /**
   * è·å¾— Block ä¸‹æ–¹çš„ç¬¬ä¸€ä¸ªéé“¾æ¥åˆ°ç»“å°¾çš„ IndexArr
   */
  static getHtmlBlockNonLinkContentIndexArr (note, text) {
    let indexArr = this.getHtmlCommentExcludingFieldBlockIndexArr(note, text)  // è¿™é‡Œä¸èƒ½ç”¨ includingï¼Œå¦åˆ™å­—æ®µçš„ htmlComment æœ¬èº«å°±ä¸æ˜¯é“¾æ¥ï¼Œå°±ä¼šè¢«è¯†åˆ«åˆ°
    let findNonLink = false
    if (indexArr.length !== 0) {
      // ä»å¤´å¼€å§‹éå†ï¼Œæ£€æµ‹æ˜¯å¦æ˜¯é“¾æ¥ï¼Œç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªéé“¾æ¥å°±åœæ­¢
      for (let i = 0; i < indexArr.length; i++) {
        let index = indexArr[i]
        let comment = note.MNComments[index]
        if (
          comment.type !== "linkComment"
        ) {
          // ä¸å¤„ç† # å¼€å¤´çš„æ–‡æœ¬ï¼Œå› ä¸ºè¿™ç§æ–‡æœ¬ä¸€èˆ¬æ˜¯ç”¨ä½œæ ‡é¢˜é“¾æ¥ï¼Œä¸èƒ½è¢«è¯†åˆ«ä¸ºæ–°å†…å®¹
          if (comment.text && comment.text.startsWith("#")) {
            continue
          }
          indexArr = indexArr.slice(i)
          findNonLink = true
          break
        }
      }
      if (!findNonLink) {
        // åªæœ‰é“¾æ¥æ—¶ï¼Œä»ç„¶è¿”å›æ•°ç»„
        return []
      }
    }
    return indexArr
  }

  static async addTemplate(note, focusLastNote = true) {
    let type, noteType, intelligentType, titleType, finalType
    let defaultType = this.parseNoteTitle(note).type  // é»˜è®¤ç±»å‹
    let parentNote, lastNote
    let templateNoteId
    let lastClassificationNote, newClassificationNote
    let titleParts = this.parseNoteTitle(note)
    let typeArr = ["å®šä¹‰", "å‘½é¢˜", "ä¾‹å­", "åä¾‹", "æ€æƒ³æ–¹æ³•", "é—®é¢˜"]
    let titlesArray = []
    let contentInTitle
    let childNotes = note.childNotes
    switch (this.getNoteType(note)) {
      case "å½’ç±»":
        contentInTitle = titleParts.content
        break;
      default:
        contentInTitle = titleParts.prefixContent + "ï½œ" + titleParts.titleLinkWordsArr[0];
        break;
    }
    MNUtil.copy(contentInTitle)
    try {
      let userInputRes = await MNUtil.userInput(
        "å¢åŠ æ¨¡æ¿",
        "è¯·è¾“å…¥æ ‡é¢˜å¹¶é€‰æ‹©ç±»å‹",
        [
          "å–æ¶ˆ",
          "è¿ç»­å‘ä¸‹ã€Œé¡ºåºã€å¢åŠ æ¨¡æ¿",  // 1
          "è¿ç»­å‘ä¸‹ã€Œå€’åºã€å¢åŠ æ¨¡æ¿",  // 2
          "å¢åŠ å…„å¼Ÿå±‚çº§æ¨¡æ¿",  // 3
          "å‘ä¸Šå±‚å¢åŠ æ¨¡æ¿",  // 4
        ],
        { default: contentInTitle }
      )
      let userInputTitle = userInputRes.input
      // åˆ†å‰²è¾“å…¥ï¼Œæ”¯æŒé€šè¿‡//åˆ›å»ºå¤šä¸ªå…„å¼Ÿå¡ç‰‡é“¾
      let titlePartsArray = userInputTitle.split("//")
      let previousTitle = titlePartsArray[0]  // è®°å½•ä¸Šä¸€ä¸ªæ ‡é¢˜
      let changedTitlePart = titlePartsArray[titlePartsArray.length-1]
      switch (userInputRes.button) {
        case 4:
          try {
            /* å‘ä¸Šå¢åŠ æ¨¡æ¿ */
            
            // è·å–å½“å‰å¡ç‰‡ç±»å‹å’Œçˆ¶å¡ç‰‡
            noteType = this.parseNoteTitle(note).type
            parentNote = note.parentNote
            
            if (!noteType) {
              MNUtil.showHUD("æ— æ³•è¯†åˆ«å½“å‰å¡ç‰‡ç±»å‹");
              return;
            }
            
            // æ™ºèƒ½è¯†åˆ«ç±»å‹ï¼ˆä»…ç”¨äºæ ‡é¢˜ï¼‰
            intelligentType = this.getTypeFromInputText(userInputTitle);
            titleType = intelligentType || noteType;  // æ ‡é¢˜ä¸­æ˜¾ç¤ºçš„ç±»å‹
            templateNoteId = this.types["å½’ç±»"].templateNoteId;  // å§‹ç»ˆä½¿ç”¨å½’ç±»æ¨¡æ¿
            
            // 1. åˆ›å»ºæ–°çš„å½’ç±»å¡ç‰‡
            newClassificationNote = MNNote.clone(templateNoteId);
            newClassificationNote.note.noteTitle = `â€œ${userInputTitle}â€ç›¸å…³${titleType}`;
            
            // 3. å»ºç«‹å±‚çº§å…³ç³»ï¼šæ–°å¡ç‰‡ä½œä¸ºçˆ¶å¡ç‰‡çš„å­å¡ç‰‡
            parentNote.addChild(newClassificationNote);

            newClassificationNote.moveTo(note.indexInBrotherNotes + 1)
            
            // 4. ç§»åŠ¨é€‰ä¸­å¡ç‰‡ï¼šä»åŸä½ç½®ç§»åŠ¨åˆ°æ–°å¡ç‰‡ä¸‹
            newClassificationNote.addChild(note);
            
            // 5. ä½¿ç”¨ this API å¤„ç†é“¾æ¥å…³ç³»
            this.linkParentNote(newClassificationNote);
            this.linkParentNote(note);

            // 5.1 æ·»åŠ åˆ°å¢é‡ç´¢å¼•
            KnowledgeBaseIndexer.addToIncrementalIndex(newClassificationNote);

            // 6. èšç„¦åˆ°æ–°åˆ›å»ºçš„å¡ç‰‡
            if (focusLastNote) {
              newClassificationNote.focusInMindMap(0.5);
            }

            lastClassificationNote = newClassificationNote;
            
          } catch (error) {
            MNUtil.showHUD(`å‘ä¸Šå¢åŠ æ¨¡æ¿å¤±è´¥: ${error.message || error}`);
          }
          break;
        case 3:
          // å¢åŠ å…„å¼Ÿå±‚çº§æ¨¡æ¿
          type = this.parseNoteTitle(note).type
          if (type) {
            // æ™ºèƒ½è¯†åˆ«ç±»å‹ï¼ˆä»…ç”¨äºæ ‡é¢˜ï¼‰
            intelligentType = this.getTypeFromInputText(userInputTitle);
            titleType = intelligentType || type;  // æ ‡é¢˜ä¸­æ˜¾ç¤ºçš„ç±»å‹

            MNUtil.undoGrouping(()=>{
              let lastNote = null
              
              // åˆ›å»ºç¬¬ä¸€ä¸ªå…„å¼Ÿå¡ç‰‡ï¼ˆå§‹ç»ˆä½¿ç”¨å½’ç±»æ¨¡æ¿ï¼‰
              let firstNote = MNNote.clone(this.types["å½’ç±»"].templateNoteId)
              firstNote.noteTitle = "â€œ" + titlePartsArray[0] + "â€ç›¸å…³" + titleType
              note.parentNote.addChild(firstNote)
              this.linkParentNote(firstNote)
              KnowledgeBaseIndexer.addToIncrementalIndex(firstNote)
              lastNote = firstNote
              firstNote.moveTo(note.indexInBrotherNotes + 1)

              // å¦‚æœæœ‰æ›´å¤šéƒ¨åˆ†ï¼Œåˆ›å»ºå­å¡ç‰‡é“¾
              for (let i = 1; i < titlePartsArray.length; i++) {
                let childNote = MNNote.clone(this.types["å½’ç±»"].templateNoteId)
                // ç´¯ç§¯æ ‡é¢˜ï¼šä¸Šä¸€ä¸ªæ ‡é¢˜ + å½“å‰éƒ¨åˆ†
                let accumulatedTitle = previousTitle + titlePartsArray[i]
                childNote.noteTitle = "â€œ" + accumulatedTitle + "â€ç›¸å…³" + titleType
                lastNote.addChild(childNote.note)
                this.linkParentNote(childNote)
                KnowledgeBaseIndexer.addToIncrementalIndex(childNote)
                lastNote = childNote
                previousTitle = accumulatedTitle  // æ›´æ–°ä¸Šä¸€ä¸ªæ ‡é¢˜
              }
              
              // èšç„¦æœ€ååˆ›å»ºçš„å¡ç‰‡
              if (focusLastNote && lastNote) {
                lastNote.focusInMindMap(0.5)
              }
              lastClassificationNote = lastNote
            })
          }
          break
        case 2: // è¿ç»­å‘ä¸‹ã€Œå€’åºã€å¢åŠ æ¨¡æ¿
          /**
           * é€šè¿‡//æ¥åˆ†å‰²æ ‡é¢˜ï¼Œå¢åŠ ä¸€è¿ä¸²çš„å½’ç±»å¡ç‰‡
           * æ¯”å¦‚ï¼šèµ‹èŒƒç©ºé—´ä¸Šçš„//æœ‰ç•Œ//çº¿æ€§//ç®—å­
           * ä¾æ¬¡å¢åŠ ï¼šèµ‹èŒƒç©ºé—´ä¸Šçš„ç®—å­ã€èµ‹èŒƒç©ºé—´ä¸Šçš„çº¿æ€§ç®—å­ã€èµ‹èŒƒç©ºé—´ä¸Šçš„æœ‰ç•Œçº¿æ€§ç®—å­
           */
          try {
            if (titlePartsArray.length > 1) {
              // ç”Ÿæˆå€’åºç»„åˆ
              // æŠŠ item1+itemn, item1+itemn-1+itemn, item1+itemn-2+itemn-1+itemn, ... , item1+item2+item3+...+itemn ä¾æ¬¡åŠ å…¥æ•°ç»„
              // æ¯”å¦‚ "èµ‹èŒƒç©ºé—´ä¸Šçš„//æœ‰ç•Œ//çº¿æ€§//ç®—å­" å¾—åˆ°çš„ titlePartsArray æ˜¯
              // ["èµ‹èŒƒç©ºé—´ä¸Šçš„", "æœ‰ç•Œ", "çº¿æ€§", "ç®—å­"]
              // åˆ™ titleArray = ["èµ‹èŒƒç©ºé—´ä¸Šçš„ç®—å­", "èµ‹èŒƒç©ºé—´ä¸Šçš„çº¿æ€§ç®—å­", "èµ‹èŒƒç©ºé—´ä¸Šçš„æœ‰ç•Œçº¿æ€§ç®—å­"]
              
              for (let i = titlePartsArray.length-1 ; i >= 1 ; i--) {
                if  (i < titlePartsArray.length-1) {
                  changedTitlePart = titlePartsArray[i] + changedTitlePart
                }
                titlesArray.push(previousTitle + changedTitlePart)
              }
            }
            lastNote = note
            switch (this.getNoteType(note)) {
              case "å½’ç±»":
                MNUtil.undoGrouping(()=>{
                  titlesArray.forEach(title => {
                    // å¯¹æ¯ä¸ªæ ‡é¢˜å°è¯•æ™ºèƒ½è¯†åˆ«
                    intelligentType = this.getTypeFromInputText(title);
                    finalType = intelligentType || defaultType;  // ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½è¯†åˆ«çš„ç±»å‹
                    newClassificationNote = this.createClassificationNoteAsChildNote(lastNote, title, finalType)
                    KnowledgeBaseIndexer.addToIncrementalIndex(newClassificationNote)
                    lastNote = newClassificationNote
                  })
                  if (focusLastNote) {
                    lastNote.focusInMindMap(0.3)
                  }
                  lastClassificationNote =  lastNote
                })
                break;
              default:
                // æ™ºèƒ½è¯†åˆ«ç±»å‹
                intelligentType = this.getTypeFromInputText(userInputTitle);
                if (intelligentType) {
                  type = intelligentType;
                  // ç›´æ¥æ‰§è¡Œåˆ›å»ºé€»è¾‘ï¼Œæ— éœ€å¼¹çª—é€‰æ‹©
                  MNUtil.undoGrouping(() => {
                    titlesArray.forEach(title => {
                      newClassificationNote = this.createClassificationNoteAsChildNote(lastNote, title, type);
                      KnowledgeBaseIndexer.addToIncrementalIndex(newClassificationNote);
                      lastNote = newClassificationNote;
                    });
                    if (focusLastNote) {
                      lastNote.focusInMindMap(0.3);
                    }
                    lastClassificationNote = lastNote;
                  });
                } else {
                  userInputRes = await MNUtil.userSelect(
                    "å¢åŠ å½’ç±»å¡ç‰‡",
                    "é€‰æ‹©ç±»å‹",
                    typeArr
                  )
                  if (userInputRes === 0) { return; }
                  type = typeArr[userInputRes - 1]
                  titlesArray.forEach(title => {
                    newClassificationNote = this.createClassificationNoteAsChildNote(lastNote, title, type)
                    KnowledgeBaseIndexer.addToIncrementalIndex(newClassificationNote)
                    lastNote = newClassificationNote
                  })
                  if (focusLastNote) {
                    lastNote.focusInMindMap(0.3)
                  }
                  lastClassificationNote = lastNote
                }
                break;
            }
          } catch (error) {
            MNUtil.showHUD(`è¿ç»­å‘ä¸‹å€’åºå¢åŠ æ¨¡æ¿å¤±è´¥: ${error.message || error}`);
          }
          break;
        case 1: // è¿ç»­å‘ä¸‹ã€Œé¡ºåºã€å¢åŠ æ¨¡æ¿
          /**
           * é€šè¿‡//æ¥åˆ†å‰²æ ‡é¢˜ï¼Œå¢åŠ ä¸€è¿ä¸²çš„å½’ç±»å¡ç‰‡ï¼ˆé¡ºåºï¼Œä¸case2å€’åºä¸åŒï¼‰
           * æ¯”å¦‚ï¼šèµ‹èŒƒç©ºé—´ä¸Šçš„æœ‰ç•Œçº¿æ€§ç®—å­//çš„åˆ¤å®š//ï¼šå……åˆ†æ¡ä»¶
           * -> èµ‹èŒƒç©ºé—´ä¸Šçš„æœ‰ç•Œçº¿æ€§ç®—å­ã€èµ‹èŒƒç©ºé—´ä¸Šçš„æœ‰ç•Œçº¿æ€§ç®—å­çš„åˆ¤å®šã€èµ‹èŒƒç©ºé—´ä¸Šçš„æœ‰ç•Œçº¿æ€§ç®—å­çš„åˆ¤å®šï¼šå……åˆ†æ¡ä»¶
           */
          try {
            titlesArray.push(titlePartsArray[0]) // æ·»åŠ ç¬¬ä¸€ä¸ªéƒ¨åˆ†
            if (titlePartsArray.length > 1) {
              // ç”Ÿæˆé¡ºåºç»„åˆ
              for (let i = 1; i < titlePartsArray.length; i++) {
                titlesArray.push(titlesArray[i-1] + titlePartsArray[i])
              }
            }
            lastNote = note
            switch (this.getNoteType(note)) {
              case "å½’ç±»":
                titlesArray.forEach(title => {
                  // å¯¹æ¯ä¸ªæ ‡é¢˜å°è¯•æ™ºèƒ½è¯†åˆ«
                  intelligentType = this.getTypeFromInputText(title);
                  finalType = intelligentType || defaultType;  // ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½è¯†åˆ«çš„ç±»å‹
                  newClassificationNote = this.createClassificationNoteAsChildNote(lastNote, title, finalType)
                  KnowledgeBaseIndexer.addToIncrementalIndex(newClassificationNote)
                  lastNote = newClassificationNote
                })
                if (childNotes.length == 1 && this.getNoteType(childNotes[0]) !== "å½’ç±»") {  // ä¸æ˜¯å½’ç±»å¡ç‰‡çš„æœ€åä¸€å¼ ï¼Œè‡ªåŠ¨ç§»åŠ¨åˆ°æ–°çš„å½’ç±»å¡ç‰‡ä¸‹æ–¹
                  lastNote.addChild(childNotes[0])
                }
                if (focusLastNote) {
                  lastNote.focusInMindMap(0.3)
                }
                lastClassificationNote = lastNote
                break;
              default:
                // æ™ºèƒ½è¯†åˆ«ç±»å‹
                intelligentType = this.getTypeFromInputText(userInputTitle);
                if (intelligentType) {
                  type = intelligentType;
                  titlesArray.forEach(title => {
                    newClassificationNote = this.createClassificationNoteAsChildNote(lastNote, title, type);
                    KnowledgeBaseIndexer.addToIncrementalIndex(newClassificationNote);
                    lastNote = newClassificationNote;
                  });
                  if (focusLastNote) {
                    lastNote.focusInMindMap(0.3);
                  }
                  lastClassificationNote = lastNote;
                } else {
                  // åŸæœ‰çš„å¼¹çª—é€‰æ‹©é€»è¾‘
                  userInputRes = await MNUtil.userSelect(
                    "å¢åŠ å½’ç±»å¡ç‰‡",
                    "é€‰æ‹©ç±»å‹",
                    typeArr
                  )
                  // KnowledgeBaseUtils.log(typeArr, "addTemplate:typeArr")
                  // KnowledgeBaseUtils.log(userInputRes, "addTemplate:button")
                  if (userInputRes === 0) { return; }
                  type = typeArr[userInputRes - 1]
                  // KnowledgeBaseUtils.log(type, "addTemplate:type")
                  titlesArray.forEach(title => {
                    newClassificationNote = this.createClassificationNoteAsChildNote(lastNote, title, type)
                    KnowledgeBaseIndexer.addToIncrementalIndex(newClassificationNote)
                    lastNote = newClassificationNote
                  })
                  if (focusLastNote) {
                    lastNote.focusInMindMap(0.3)
                  }
                  lastClassificationNote = lastNote
                }
                break;
            }
          } catch (error) {
            MNUtil.showHUD(`è¿ç»­å‘ä¸‹é¡ºåºå¢åŠ æ¨¡æ¿å¤±è´¥: ${error.message || error}`);
          }
          break;
      }


      // åœ¨ undoGrouping å®Œæˆåå°† lastClassificationNote è¿”å›ç»™è°ƒç”¨è€…
      MNUtil.undoGrouping(() => {
        try {
          KnowledgeBaseUtils.log(
            "lastClassificationNote:" + (lastClassificationNote ? lastClassificationNote.title : ""),
            "addTemplate:lastClassificationNote",
          );
        } catch (e) {
          KnowledgeBaseUtils.log(e, "addTemplate:logError");
        }
      });
      // æ˜ç¡®è¿”å›åˆ›å»ºçš„åˆ†ç±»å¡ç‰‡ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œä»¥ä¾¿å¤–éƒ¨ await å¯ä»¥æ¥æ”¶åˆ°
      KnowledgeBaseConfig.config.lastClassificationNoteId = lastClassificationNote ? lastClassificationNote.noteId : null;
      return lastClassificationNote;
    } catch (error) {
      KnowledgeBaseUtils.log(error, "addTemplate")
      MNUtil.showHUD(error);
    }
  }


  /**
   * simpleTemplate: æ²¡æœ‰â€œç›¸å…³æ€è€ƒâ€å­—æ®µ
   */
  static createClassificationNoteAsChildNote(note, title, type, linkParentNote = true, simpleTemplate = false) {
    let templateNote = simpleTemplate?MNNote.clone("marginnote4app://note/14C17839-C256-4D3C-A611-726C5B6C1A04"):MNNote.clone(this.types["å½’ç±»"].templateNoteId);
    templateNote.noteTitle = `â€œ${title}â€ç›¸å…³${type}`;
    note.addChild(templateNote.note);
    if (linkParentNote) { this.linkParentNote(templateNote); }
    return templateNote;
  }

  /**
   * å°†é€‰ä¸­çš„å¡ç‰‡å˜æˆå½’ç±»å¡ç‰‡
   * 
   * directly: ç›´æ¥è½¬æ¢ï¼Œä¸å€ŸåŠ©å¼¹çª—å¤„ç†
   */
  static async convertNoteToClassificationNote(note, directly = true, linkParentNote = true, preprocessNote = true) {
    if (!note) { return undefined }
    // KnowledgeBaseUtils.log("å¤„ç†å‰æ ‡é¢˜ä¸ºï¼š" + note.title, "convertNoteToClassificationNote")
    let preprocessedNote
    if (preprocessNote) {
      preprocessedNote = this.toNoExcerptVersion(note)
    } else {
      preprocessedNote = note
    }
    // KnowledgeBaseUtils.log("å¤„ç†å¡ç‰‡åæ ‡é¢˜ä¸ºï¼š" + preprocessedNote.title, "convertNoteToClassificationNote")
    let titleContent = preprocessedNote.title
    // KnowledgeBaseUtils.log("å¤„ç†å¡ç‰‡å titleContent ä¸ºï¼š" + titleContent, "convertNoteToClassificationNote")
    let intelligentType = this.getTypeFromInputText(titleContent);
    let type = intelligentType || (
      this.parseNoteTitle(preprocessedNote.parentNote).type
    )

    if (!directly) {
      MNUtil.copy(
        (this.parseNoteTitle(preprocessedNote.parentNote).content || "")
        + 
        "ï½œ" + titleContent
      )
      let input = await MNUtil.userInput(
        "è¾“å…¥è¦ç”Ÿæˆçš„å½’ç±»å¡ç‰‡æ ‡é¢˜",
        "",
        [
          "å–æ¶ˆ",
          "ç¡®å®š"
        ]
      )
      switch (input.button) {
        case 0:
          break;
        case 1:
          titleContent = input.input
          break;
      }
    }

    // KnowledgeBaseUtils.log("å‡†å¤‡è®¾ç½®æ ‡é¢˜å‰ titleContent ä¸ºï¼š" + titleContent, "convertNoteToClassificationNote")
    let finalTitle = "â€œ" + titleContent + "â€ç›¸å…³" + type 
    let templateNote = MNNote.clone(this.types["å½’ç±»"].templateNoteId)
    MNUtil.undoGrouping(()=>{
      preprocessedNote.parentNote.addChild(templateNote)
      preprocessedNote.title = ""
      preprocessedNote.mergeInto(templateNote)
      this.autoMoveNewContentToField(templateNote, "æ‘˜å½•")
      templateNote.title = finalTitle
      this.changeNoteColor(templateNote, 'å½’ç±»')
      if (linkParentNote) {
        this.linkParentNote(templateNote)
      }
    })

    KnowledgeBaseIndexer.addToIncrementalIndex(templateNote)

    return templateNote
  }

  /**
   * è·å–ç¬¬ä¸€ä¸ªæ ‡é¢˜é“¾æ¥è¯
   */
  static getFirstTitleLinkWord(note) {
    let titleParts = this.parseNoteTitle(note);
    if (titleParts.titleLinkWordsArr.length > 0) {
      return titleParts.titleLinkWordsArr[0];
    }
    return "";
  }

  /**
   * å¤„ç†å¿«æ·çŸ­è¯­ä¸­çš„å ä½ç¬¦
   * @param {string} phrase - åŒ…å« {{}} å ä½ç¬¦çš„çŸ­è¯­
   * @param {string} inputText - ç”¨æˆ·è¾“å…¥çš„æ–‡æœ¬
   * @returns {string} - æ›¿æ¢åçš„çŸ­è¯­
   *
   * @example
   * processPhrasePlaceholder("ä½œä¸º{{}}ç‰¹ä¾‹", "åº¦é‡ç©ºé—´") // è¿”å› "ä½œä¸ºåº¦é‡ç©ºé—´ç‰¹ä¾‹"
   * processPhrasePlaceholder("ä½œä¸º{{}}ç‰¹ä¾‹", "") // è¿”å› "ä½œä¸ºç‰¹ä¾‹"
   * processPhrasePlaceholder("å› æ­¤", "ä»»æ„æ–‡æœ¬") // è¿”å› "å› æ­¤"
   */
  static processPhrasePlaceholder(phrase, inputText) {
    // å¦‚æœçŸ­è¯­ä¸åŒ…å«å ä½ç¬¦ï¼Œç›´æ¥è¿”å›
    if (!phrase.includes("{{}}")) {
      return phrase;
    }

    // è·å–å®é™…è¦å¡«å……çš„å†…å®¹ï¼ˆå»é™¤å‰åç©ºæ ¼ï¼‰
    const fillText = (inputText || "").trim();

    // å¦‚æœæ²¡æœ‰è¾“å…¥å†…å®¹ï¼Œç§»é™¤å ä½ç¬¦
    if (!fillText) {
      return phrase.replace(/{{}}/g, "");
    }

    // æ›¿æ¢å ä½ç¬¦ä¸ºè¾“å…¥å†…å®¹
    return phrase.replace(/{{}}/g, fillText);
  }

  /**
   * å¤åˆ¶ Markdown æ ¼å¼çš„å¡ç‰‡é“¾æ¥ï¼ˆå¸¦å¿«æ·çŸ­è¯­åŠŸèƒ½ï¼‰
   * @param {MNNote} note - è¦ç”Ÿæˆé“¾æ¥çš„å¡ç‰‡
   * @param {string|null} prefilledText - é¢„å¡«å……çš„æ–‡æœ¬
   */
  static copyMarkdownLinkWithQuickPhrases(note, prefilledText = null) {
    if (!note) {
      MNUtil.showHUD("âŒ è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¡ç‰‡");
      return;
    }

    // è·å–é»˜è®¤é“¾æ¥è¯ï¼ˆå¦‚æœæ²¡æœ‰é¢„å¡«å……æ–‡æœ¬ï¼‰
    const defaultLinkWord = prefilledText || "";

    // ä½¿ç”¨é™æ€é…ç½®çš„å¿«æ·çŸ­è¯­
    const phrases = this.inlineLinkPhrases;

    // æ„å»ºé€‰é¡¹åˆ—è¡¨
    let menuOptions = [];

    // ç¬¬ä¸€ä¸ªæŒ‰é’®ï¼šç¡®å®šï¼ˆä½¿ç”¨è¾“å…¥æ¡†å†…å®¹ï¼‰
    menuOptions.push("âœ… ç¡®å®š");

    // ç¬¬äºŒä¸ªæŒ‰é’®ï¼šä½¿ç”¨ç¬¬ä¸€ä¸ªæ ‡é¢˜é“¾æ¥è¯
    menuOptions.push("ğŸ”— ä½¿ç”¨ç¬¬ä¸€ä¸ªæ ‡é¢˜é“¾æ¥è¯");

    // æ·»åŠ æ‰€æœ‰å¿«æ·çŸ­è¯­é€‰é¡¹
    phrases.forEach(phrase => {
      menuOptions.push(`ğŸ“ ${phrase}`);
    });

    // æ˜¾ç¤ºå¸¦è¾“å…¥æ¡†çš„å¯¹è¯æ¡†
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "å¤åˆ¶ Markdown é“¾æ¥",
      "è¾“å…¥é“¾æ¥è¯æˆ–é€‰æ‹©å¿«æ·çŸ­è¯­",
      2, // è¾“å…¥æ¡†æ¨¡å¼
      "å–æ¶ˆ",
      menuOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) return; // å–æ¶ˆ

        const selectedIndex = buttonIndex - 1;
        const inputText = alert.textFieldAtIndex(0).text;

        if (selectedIndex === 0) {
          // ç‚¹å‡»"ç¡®å®š"æŒ‰é’®
          const linkWord = inputText && inputText.trim() ? inputText : defaultLinkWord;
          if (linkWord) {
            const mdLink = `[${linkWord}](${note.noteURL})`;
            MNUtil.copy(mdLink);
            MNUtil.showHUD(`âœ… å·²å¤åˆ¶: ${mdLink}`);
          } else {
            MNUtil.showHUD("âŒ è¯·è¾“å…¥é“¾æ¥è¯");
          }

        } else if (selectedIndex === 1) {
          // ä½¿ç”¨ç¬¬ä¸€ä¸ªæ ‡é¢˜é“¾æ¥è¯
          const firstLinkWord = this.getFirstTitleLinkWord(note);
          if (firstLinkWord) {
            const mdLink = `[${firstLinkWord}](${note.noteURL})`;
            MNUtil.copy(mdLink);
            MNUtil.showHUD(`âœ… å·²å¤åˆ¶: ${mdLink}`);
          } else {
            MNUtil.showHUD("âŒ è¯¥å¡ç‰‡æ²¡æœ‰æ ‡é¢˜é“¾æ¥è¯");
          }

        } else if (selectedIndex <= phrases.length + 1) {
          // é€‰æ‹©äº†å¿«æ·çŸ­è¯­
          const selectedPhrase = phrases[selectedIndex - 2];

          // å¤„ç†å ä½ç¬¦ï¼ˆæ–°å¢ï¼‰
          const processedPhrase = this.processPhrasePlaceholder(selectedPhrase, inputText);

          const mdLink = `[${processedPhrase}](${note.noteURL})`;
          MNUtil.copy(mdLink);
          MNUtil.showHUD(`âœ… å·²å¤åˆ¶: ${mdLink}`);
        }
      }
    );

    // è®¾ç½®è¾“å…¥æ¡†çš„é»˜è®¤å€¼
    MNUtil.delay(0.1).then(() => {
      if (UIAlertView.currentAlert) {
        UIAlertView.currentAlert.textFieldAtIndex(0).text = defaultLinkWord;
      }
    });
  }

  /**
   * æ ¹æ®å¡ç‰‡ç±»å‹è½¬æ¢éœ€è¦ï¼Œæ›¿æ¢ç¬¬ä¸€ä¸ª HtmlComment å­—æ®µ
   * å½“å¡ç‰‡è¢«ç§»åŠ¨åˆ°ä¸åŒçš„å½’ç±»å¡ç‰‡ä¸‹æ–¹æ—¶ï¼Œéœ€è¦æ›´æ–°ç¬¬ä¸€ä¸ªå­—æ®µä»¥åŒ¹é…æ–°ç±»å‹
   * 
   * éœ€è¦æ›¿æ¢çš„æƒ…å†µï¼š
   * 1. å‘½é¢˜/ä¾‹å­ â†” åä¾‹
   * 2. å‘½é¢˜/ä¾‹å­ â†” æ€æƒ³æ–¹æ³•
   * 3. åä¾‹ â†” æ€æƒ³æ–¹æ³•
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   */
  static replaceFirstFieldIfNeeded(note) {
    try {
      // è·å–æ ‡é¢˜ä¸­çš„ç±»å‹ï¼ˆå½“å‰ç±»å‹ï¼‰
      let titleType = this.getNoteType(note);
      
      // è·å–å½’ç±»å¡ç‰‡ï¼Œç¡®å®šç›®æ ‡ç±»å‹
      let classificationNote = this.getFirstClassificationParentNote(note);
      let targetType = null;
      
      if (classificationNote) {
        let classificationTitleParts = this.parseNoteTitle(classificationNote);
        targetType = classificationTitleParts.type;
      }
      
      // å¦‚æœæ²¡æœ‰å½’ç±»å¡ç‰‡ï¼Œæˆ–è€…ç›®æ ‡ç±»å‹ä¸æ ‡é¢˜ç±»å‹ç›¸åŒï¼Œä¸éœ€è¦å¤„ç†
      if (!targetType || targetType === titleType) {
        return;
      }
      
      // å¦‚æœä¸æ˜¯éœ€è¦å¤„ç†çš„ç±»å‹ï¼Œç›´æ¥è¿”å›
      let targetTypes = ["å‘½é¢˜", "ä¾‹å­", "åä¾‹", "æ€æƒ³æ–¹æ³•"];
      if (!targetTypes.includes(targetType) || !targetTypes.includes(titleType)) {
        return;
      }
      
      // ç¡®å®šéœ€è¦æ›¿æ¢çš„å­—æ®µå
      let fieldMapping = {
        "å‘½é¢˜": "è¯æ˜",
        "ä¾‹å­": "è¯æ˜", 
        "åä¾‹": "åä¾‹",
        "æ€æƒ³æ–¹æ³•": "åŸç†"
      };
      
      // è§£æè¯„è®ºï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ª HtmlComment å­—æ®µ
      let commentsObj = this.parseNoteComments(note);
      let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
      
      if (htmlCommentsObjArr.length === 0) {
        return; // æ²¡æœ‰å­—æ®µï¼Œä¸éœ€è¦å¤„ç†
      }
      
      // è·å–ç¬¬ä¸€ä¸ªå­—æ®µçš„ä¿¡æ¯
      let firstFieldObj = htmlCommentsObjArr[0];
      let firstFieldIndex = firstFieldObj.index; // ä½¿ç”¨ index è€Œä¸æ˜¯ fieldIndex
      let firstFieldText = firstFieldObj.text; // å­—æ®µçš„æ–‡æœ¬å†…å®¹
      
      // å‘½é¢˜å’Œä¾‹å­çš„å­—æ®µç›¸åŒï¼Œä¸éœ€è¦æ›¿æ¢
      if ((titleType === "å‘½é¢˜" && targetType === "ä¾‹å­") || 
          (titleType === "ä¾‹å­" && targetType === "å‘½é¢˜")) {
        return;
      }
      
      // æ£€æŸ¥ç¬¬ä¸€ä¸ªå­—æ®µæ˜¯å¦å·²ç»æ˜¯ç›®æ ‡å­—æ®µ
      if (firstFieldText === fieldMapping[targetType]) {
        return;
      }
      
      let currentField = fieldMapping[titleType];
      let targetField = fieldMapping[targetType];
      
      // å¦‚æœå­—æ®µç›¸åŒï¼Œä¸éœ€è¦æ›¿æ¢
      if (currentField === targetField) {
        return;
      }
      
      MNUtil.undoGrouping(() => {
        try {
          // è·å–æ–°å­—æ®µçš„æ¨¡æ¿å†…å®¹
          let templateNoteId = this.singleHtmlCommentTemplateNoteIds[targetField];
          if (!templateNoteId) {
            MNUtil.log("æœªæ‰¾åˆ°ç›®æ ‡å­—æ®µçš„æ¨¡æ¿å¡ç‰‡ ID: " + targetField);
            return;
          }
          
          // å…ˆåˆ é™¤åŸæ¥çš„ç¬¬ä¸€ä¸ªå­—æ®µ
          note.removeCommentByIndex(firstFieldIndex);
          
          // å…‹éš†å¹¶åˆå¹¶åªåŒ…å«æ–°å­—æ®µçš„æ¨¡æ¿å¡ç‰‡
          this.cloneAndMergeById(note, templateNoteId);
          
          // æ–°å­—æ®µè¢«æ·»åŠ åˆ°æœ€åï¼Œéœ€è¦ç§»åŠ¨åˆ°ç¬¬ä¸€ä¸ªä½ç½®ï¼ˆåŸå­—æ®µçš„ä½ç½®ï¼‰
          let newFieldIndex = note.comments.length - 1; // æ–°å­—æ®µåœ¨æœ€å
          note.moveComment(newFieldIndex, firstFieldIndex);
          
        } catch (error) {
          MNUtil.log("æ›¿æ¢å­—æ®µæ—¶å‡ºé”™: " + error.toString());
        }
      });
      
    } catch (error) {
      MNUtil.log("replaceFirstFieldIfNeeded å‡ºé”™: " + error.toString());
    }
  }

  /**
   * åˆ é™¤åŒå‘é“¾æ¥
   * è§£æç¬”è®°ä¸­çš„é“¾æ¥ï¼ˆå¯ä»¥åœ¨å­—æ®µä¸‹æˆ–ç›´æ¥åœ¨è¯„è®ºä¸­ï¼‰ï¼Œå¹¶æ”¯æŒåŒå‘åˆ é™¤ï¼ˆåŒæ—¶åˆ é™¤å¯¹æ–¹ç¬”è®°ä¸­çš„åå‘é“¾æ¥ï¼‰
   * @param {MNNote} note - è¦å¤„ç†çš„ç¬”è®°
   */
  static async removeBidirectionalLinks(note) {
    try {
      // 1. è§£æå½“å‰ç¬”è®°çš„æ‰€æœ‰å­—æ®µå’Œè¯„è®º
      const commentsObj = this.parseNoteComments(note);
      const htmlFields = commentsObj.htmlCommentsObjArr;
      
      let links = [];
      let selectedFieldText = null; // ç”¨äºè®°å½•é€‰ä¸­çš„å­—æ®µåç§°ï¼ˆå¦‚æœæœ‰ï¼‰
      
      // 2. æ ¹æ®æ˜¯å¦æœ‰å­—æ®µé‡‡ç”¨ä¸åŒçš„å¤„ç†ç­–ç•¥
      if (htmlFields.length > 0) {
        // æœ‰å­—æ®µçš„æƒ…å†µï¼šè®©ç”¨æˆ·é€‰æ‹©è¦å¤„ç†çš„å­—æ®µ
        const fieldNames = htmlFields.map(field => field.text);
        const selectedFieldIndex = await MNUtil.userSelect(
          "é€‰æ‹©è¦å¤„ç†é“¾æ¥çš„å­—æ®µ", 
          "", 
          fieldNames
        );
        
        if (selectedFieldIndex === 0) {
          return; // ç”¨æˆ·å–æ¶ˆ
        }
        
        const selectedField = htmlFields[selectedFieldIndex - 1];
        selectedFieldText = selectedField.text;
        
        // è·å–æ‰€é€‰å­—æ®µä¸‹çš„çº¯é“¾æ¥
        const fieldCommentIndices = selectedField.excludingFieldBlockIndexArr;
        
        for (const index of fieldCommentIndices) {
          const comment = note.MNComments[index];
          if (comment && comment.text) {
            const commentText = comment.text.trim();
            
            // ä½¿ç”¨å°è£…çš„ API åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ç¬”è®°é“¾æ¥
            if (commentText.isValidNoteURL()) {
              // æ£€æŸ¥æ˜¯å¦ä¸ºçº¯é“¾æ¥ï¼ˆä¸åœ¨ Markdown æ ¼å¼ä¸­ï¼‰
              if (!commentText.includes("](") && !commentText.includes("[")) {
                links.push({
                  index: index,
                  url: commentText,
                  noteId: commentText.toNoteId(),
                  type: comment.type
                });
              }
            }
          }
        }
        
        if (links.length === 0) {
          // è°ƒè¯•ä¿¡æ¯ï¼šæ˜¾ç¤ºå­—æ®µä¸‹çš„æ‰€æœ‰è¯„è®º
          MNUtil.log(`å­—æ®µ"${selectedField.text}"çš„è¯„è®ºç´¢å¼•: ${fieldCommentIndices.join(', ')}`);
          for (const index of fieldCommentIndices) {
            const comment = note.MNComments[index];
            if (comment) {
              MNUtil.log(`ç´¢å¼•${index}: ç±»å‹=${comment.type}, å†…å®¹="${comment.text}"`);
            }
          }
          MNUtil.showHUD(`å­—æ®µ"${selectedField.text}"ä¸‹æ²¡æœ‰æ‰¾åˆ°çº¯é“¾æ¥`);
          return;
        }
      } else {
        // æ²¡æœ‰å­—æ®µçš„æƒ…å†µï¼šæ‰«ææ‰€æœ‰è¯„è®ºæŸ¥æ‰¾é“¾æ¥
        const allComments = note.MNComments;
        
        for (let index = 0; index < allComments.length; index++) {
          const comment = allComments[index];
          if (comment && comment.text) {
            const commentText = comment.text.trim();
            
            // è·³è¿‡å­—æ®µæœ¬èº«ï¼ˆè™½ç„¶è¿™é‡Œåº”è¯¥æ²¡æœ‰å­—æ®µï¼‰
            if (comment.type === "HtmlComment") {
              continue;
            }
            
            // ä½¿ç”¨å°è£…çš„ API åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ç¬”è®°é“¾æ¥
            if (commentText.isValidNoteURL()) {
              // æ£€æŸ¥æ˜¯å¦ä¸ºçº¯é“¾æ¥ï¼ˆä¸åœ¨ Markdown æ ¼å¼ä¸­ï¼‰
              if (!commentText.includes("](") && !commentText.includes("[")) {
                links.push({
                  index: index,
                  url: commentText,
                  noteId: commentText.toNoteId(),
                  type: comment.type
                });
              }
            }
          }
        }
        
        if (links.length === 0) {
          MNUtil.showHUD("å½“å‰ç¬”è®°æ²¡æœ‰æ‰¾åˆ°ä»»ä½•çº¯é“¾æ¥");
          return;
        }
      }
      
      // 3. è·å–é“¾æ¥å¯¹åº”çš„ç¬”è®°æ ‡é¢˜
      const linkDisplayNames = [];
      for (const link of links) {
        try {
          const targetNote = MNNote.new(link.noteId);
          if (targetNote) {
            // ä½¿ç”¨ MNNote åŒ…è£…ä»¥ä¾¿ä½¿ç”¨ parseNoteTitle
            const targetMNNote = MNNote.new(targetNote);
            const titleParts = this.parseNoteTitle(targetMNNote);
            
            // è·å–å†…å®¹éƒ¨åˆ†ï¼Œå¹¶å»æ‰å¯èƒ½çš„ "; " å‰ç¼€
            let content = titleParts.content || targetNote.noteTitle || "[æ— æ ‡é¢˜]";
            if (content.startsWith("; ")) {
              content = content.substring(2).trim();
            }
            
            // æ ¼å¼åŒ–æ˜¾ç¤ºï¼š[ç±»å‹] å†…å®¹
            const type = titleParts.type || "";
            const displayTitle = type ? `[${type}] ${content}` : content;
            
            linkDisplayNames.push(displayTitle);
          } else {
            linkDisplayNames.push(`[ç¬”è®°ä¸å­˜åœ¨: ${link.noteId.substring(0, 8)}...]`);
          }
        } catch (error) {
          linkDisplayNames.push(`[è·å–å¤±è´¥: ${link.noteId.substring(0, 8)}...]`);
        }
      }
      
      // 4. è®©ç”¨æˆ·é€‰æ‹©è¦åˆ é™¤çš„é“¾æ¥
      const subtitle = selectedFieldText 
        ? `åœ¨"${selectedFieldText}"å­—æ®µä¸‹æ‰¾åˆ° ${links.length} ä¸ªé“¾æ¥`
        : `åœ¨ç¬”è®°ä¸­æ‰¾åˆ° ${links.length} ä¸ªé“¾æ¥`;
      
      const selectedLinkIndex = await MNUtil.userSelect(
        "é€‰æ‹©è¦åˆ é™¤çš„é“¾æ¥",
        subtitle,
        linkDisplayNames
      );
      
      if (selectedLinkIndex === 0) {
        return; // ç”¨æˆ·å–æ¶ˆ
      }
      
      const selectedLink = links[selectedLinkIndex - 1];
      
      // 5. æ‰§è¡ŒåŒå‘åˆ é™¤
      MNUtil.undoGrouping(() => {
        // åˆ é™¤å½“å‰ç¬”è®°ä¸­çš„é“¾æ¥
        note.removeCommentByIndex(selectedLink.index);
        
        // å°è¯•åˆ é™¤å¯¹æ–¹ç¬”è®°ä¸­çš„åå‘é“¾æ¥
        try {
          const targetNote = MNNote.new(selectedLink.noteId);
          if (targetNote) {
            const targetMNNote = MNNote.new(targetNote);
            const targetCommentsObj = this.parseNoteComments(targetMNNote);
            const currentNoteId = note.noteId;
            
            // ä¼˜å…ˆæŸ¥æ‰¾"åº”ç”¨"å­—æ®µï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
            const applicationField = targetCommentsObj.htmlCommentsObjArr.find(field => {
              const fieldText = field.text.trim();
              return fieldText === "åº”ç”¨" || fieldText === "åº”ç”¨:" || fieldText === "åº”ç”¨ï¼š";
            });
            
            if (applicationField) {
              // åœ¨åº”ç”¨å­—æ®µä¸‹æŸ¥æ‰¾åå‘é“¾æ¥
              const fieldIndices = applicationField.excludingFieldBlockIndexArr;
              
              for (let i = fieldIndices.length - 1; i >= 0; i--) {
                const index = fieldIndices[i];
                const comment = targetMNNote.MNComments[index];
                // æ·»åŠ ç±»å‹æ£€æŸ¥
                if (comment && comment.type === "linkComment" && comment.text) {
                  const commentText = comment.text.trim();
                  // ä½¿ç”¨ includes è€Œä¸æ˜¯å®Œå…¨åŒ¹é…
                  if (commentText.isValidNoteURL() && 
                      commentText.includes(currentNoteId)) {
                    targetMNNote.removeCommentByIndex(index);
                    MNUtil.showHUD("å·²åˆ é™¤åŒå‘é“¾æ¥");
                    return;
                  }
                }
              }
            }
            
            // å¦‚æœåº”ç”¨å­—æ®µæ²¡æ‰¾åˆ°ï¼Œéå†æ‰€æœ‰å­—æ®µæŸ¥æ‰¾åå‘é“¾æ¥
            let linkFound = false;
            for (const field of targetCommentsObj.htmlCommentsObjArr) {
              const fieldIndices = field.excludingFieldBlockIndexArr;
              
              for (let i = fieldIndices.length - 1; i >= 0; i--) {
                const index = fieldIndices[i];
                const comment = targetMNNote.MNComments[index];
                // æ·»åŠ ç±»å‹æ£€æŸ¥ï¼Œåªå¤„ç†é“¾æ¥ç±»å‹çš„è¯„è®º
                if (comment && comment.type === "linkComment" && comment.text) {
                  const commentText = comment.text.trim();
                  // ä½¿ç”¨ includes è¿›è¡Œæ›´çµæ´»çš„åŒ¹é…
                  if (commentText.isValidNoteURL() && 
                      commentText.includes(currentNoteId)) {
                    targetMNNote.removeCommentByIndex(index);
                    MNUtil.showHUD(`å·²åˆ é™¤åŒå‘é“¾æ¥ï¼ˆåœ¨"${field.text}"å­—æ®µä¸‹æ‰¾åˆ°ï¼‰`);
                    linkFound = true;
                    break;
                  }
                }
              }
              if (linkFound) break;
            }
            
            // å¦‚æœåœ¨å­—æ®µä¸­æ²¡æ‰¾åˆ°ï¼ˆæˆ–æ ¹æœ¬æ²¡æœ‰HTMLå­—æ®µï¼‰ï¼Œéå†æ‰€æœ‰è¯„è®ºæŸ¥æ‰¾é“¾æ¥
            if (!linkFound) {
              const allComments = targetMNNote.MNComments;
              for (let i = allComments.length - 1; i >= 0; i--) {
                const comment = allComments[i];
                
                // è·³è¿‡ HTML å­—æ®µæœ¬èº«
                if (comment && comment.type === "HtmlComment") {
                  continue;
                }
                
                // åªå¤„ç†é“¾æ¥ç±»å‹çš„è¯„è®º
                if (comment && comment.type === "linkComment" && comment.text) {
                  const commentText = comment.text.trim();
                  
                  // ä½¿ç”¨çµæ´»åŒ¹é…ï¼šæ£€æŸ¥é“¾æ¥æ˜¯å¦æŒ‡å‘å½“å‰ç¬”è®°
                  if (commentText.isValidNoteURL()) {
                    const linkNoteId = commentText.toNoteId();
                    if (linkNoteId === currentNoteId) {
                      targetMNNote.removeCommentByIndex(i);
                      MNUtil.showHUD("å·²åˆ é™¤åŒå‘é“¾æ¥");
                      linkFound = true;
                      break;
                    }
                  }
                }
              }
            }
            
            if (!linkFound) {
              MNUtil.showHUD("å·²åˆ é™¤é“¾æ¥ï¼ˆå¯¹æ–¹ç¬”è®°æœªæ‰¾åˆ°åå‘é“¾æ¥ï¼‰");
            }
          } else {
            MNUtil.showHUD("å·²åˆ é™¤é“¾æ¥ï¼ˆå¯¹æ–¹ç¬”è®°ä¸å­˜åœ¨ï¼‰");
          }
        } catch (error) {
          MNUtil.showHUD("å·²åˆ é™¤é“¾æ¥ï¼ˆå¤„ç†åå‘é“¾æ¥æ—¶å‡ºé”™ï¼‰");
          MNUtil.log("åˆ é™¤åå‘é“¾æ¥æ—¶å‡ºé”™: " + error.toString());
        }
      });
      
    } catch (error) {
      MNUtil.showHUD("æ“ä½œå¤±è´¥ï¼š" + error.toString());
      MNUtil.log("removeBidirectionalLinks å‡ºé”™: " + error.toString());
    }
  }

  /**
   * æ˜¾ç¤ºå­—æ®µä¸­çš„ Markdown æ ¼å¼å¡ç‰‡é“¾æ¥
   * è§£æå­—æ®µä¸‹ï¼ˆæˆ–æ‰€æœ‰è¯„è®ºä¸­ï¼‰çš„ Markdown æ ¼å¼å¡ç‰‡é“¾æ¥ [æ ‡é¢˜](noteId)ï¼Œå¹¶é€šè¿‡å¼¹çª—æ˜¾ç¤º
   * æ”¯æŒå¤åˆ¶ noteId å’Œå®šä½åˆ°ç›®æ ‡å¡ç‰‡
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„ç¬”è®°
   */
  static async showMarkdownLinksInField(note) {
    try {
      // 1. è§£æå­—æ®µ
      const commentsObj = this.parseNoteComments(note);
      const htmlFields = commentsObj.htmlCommentsObjArr;
      
      let links = [];
      let selectedFieldText = null;
      
      // 2. å­—æ®µé€‰æ‹©ï¼ˆå¦‚æœæœ‰å­—æ®µï¼‰
      if (htmlFields.length > 0) {
        const fieldNames = htmlFields.map(field => field.text);
        const selectedFieldIndex = await MNUtil.userSelect(
          "é€‰æ‹©è¦æŸ¥çœ‹é“¾æ¥çš„å­—æ®µ",
          "é€‰æ‹©ä¸€ä¸ªå­—æ®µæ¥æŸ¥çœ‹å…¶ä¸­çš„ Markdown é“¾æ¥",
          fieldNames
        );
        
        if (selectedFieldIndex === 0) return;
        
        const selectedField = htmlFields[selectedFieldIndex - 1];
        selectedFieldText = selectedField.text;
        links = this.extractMarkdownLinks(note, selectedField);
      } else {
        // æ²¡æœ‰å­—æ®µï¼Œæ‰«ææ‰€æœ‰è¯„è®º
        links = this.extractMarkdownLinks(note);
      }
      
      // 3. æ£€æŸ¥æ˜¯å¦æœ‰é“¾æ¥
      if (links.length === 0) {
        MNUtil.showHUD(selectedFieldText 
          ? `å­—æ®µ"${selectedFieldText}"ä¸‹æ²¡æœ‰æ‰¾åˆ° Markdown é“¾æ¥`
          : "ç¬”è®°ä¸­æ²¡æœ‰æ‰¾åˆ° Markdown é“¾æ¥");
        return;
      }
      
      // 4. æ ¼å¼åŒ–é“¾æ¥æ˜¾ç¤º
      const linkDisplayNames = await this.formatMarkdownLinks(links);
      
      // 5. ç¬¬ä¸€å±‚å¼¹çª—ï¼šé€‰æ‹©é“¾æ¥
      const subtitle = selectedFieldText 
        ? `åœ¨"${selectedFieldText}"å­—æ®µä¸‹æ‰¾åˆ° ${links.length} ä¸ªé“¾æ¥`
        : `åœ¨ç¬”è®°ä¸­æ‰¾åˆ° ${links.length} ä¸ªé“¾æ¥`;
        
      const selectedLinkIndex = await MNUtil.userSelect(
        "é€‰æ‹© Markdown é“¾æ¥",
        subtitle,
        linkDisplayNames
      );
      
      if (selectedLinkIndex === 0) return;
      
      const selectedLink = links[selectedLinkIndex - 1];
      
      // 6. ç¬¬äºŒå±‚å¼¹çª—ï¼šé€‰æ‹©æ“ä½œ
      await this.showLinkActions(selectedLink);
      
    } catch (error) {
      MNUtil.showHUD("æ“ä½œå¤±è´¥ï¼š" + error.message);
      MNUtil.addErrorLog(error, "showMarkdownLinksInField", { noteId: note.noteId });
    }
  }

  /**
   * æå– Markdown æ ¼å¼çš„å¡ç‰‡é“¾æ¥
   * ä»è¯„è®ºä¸­æå– [æ ‡é¢˜](marginnote4app://note/xxx) æ ¼å¼çš„é“¾æ¥
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Object} field - å­—æ®µå¯¹è±¡ï¼ˆå¯é€‰ï¼‰
   * @returns {Array} é“¾æ¥æ•°ç»„
   */
  static extractMarkdownLinks(note, field = null) {
    const links = [];
    // ä½¿ç”¨éè´ªå©ªåŒ¹é…ç¡®ä¿æ­£ç¡®æå–å¤šä¸ªé“¾æ¥
    const markdownLinkRegex = /\[([^\]]+?)\]\((marginnote4app:\/\/note\/[A-Z0-9-]+)\)/g;
    
    let comments;
    
    // ç¡®å®šè¦æ‰«æçš„è¯„è®ºèŒƒå›´
    if (field) {
      // å­—æ®µä¸‹çš„è¯„è®º
      comments = field.excludingFieldBlockIndexArr.map(idx => ({
        index: idx,
        comment: note.MNComments[idx]
      }));
    } else {
      // æ‰€æœ‰è¯„è®ºï¼ˆæ’é™¤å­—æ®µæœ¬èº«ï¼‰
      comments = note.MNComments.map((comment, idx) => ({
        index: idx,
        comment: comment
      })).filter(item => item.comment && item.comment.type !== "HtmlComment");
    }
    
    // éå†è¯„è®ºï¼Œæå–é“¾æ¥
    for (const {index, comment} of comments) {
      if (!comment || !comment.text) continue;
      
      // åªå¤„ç† markdownComment ç±»å‹
      if (comment.type === "markdownComment") {
        const text = comment.text;
        const matches = [...text.matchAll(markdownLinkRegex)];
        
        // ä¸€æ¡è¯„è®ºä¸­å¯èƒ½æœ‰å¤šä¸ªé“¾æ¥
        matches.forEach((match, linkIndex) => {
          links.push({
            displayText: match[1].trim(),     // é“¾æ¥æ˜¾ç¤ºæ–‡æœ¬
            url: match[2],                     // å®Œæ•´ URL
            noteId: match[2].toNoteId(),      // æå–çš„ noteId
            commentIndex: index,               // è¯„è®ºç´¢å¼•
            linkIndexInComment: linkIndex,     // åœ¨è¯¥è¯„è®ºä¸­çš„ç¬¬å‡ ä¸ªé“¾æ¥
            fullMatch: match[0],              // å®Œæ•´åŒ¹é…æ–‡æœ¬
            startPos: match.index             // åœ¨åŸæ–‡æœ¬ä¸­çš„èµ·å§‹ä½ç½®
          });
        });
      }
    }
    
    return links;
  }

  /**
   * æ ¼å¼åŒ– Markdown é“¾æ¥ç”¨äºæ˜¾ç¤º
   * 
   * @param {Array} links - é“¾æ¥æ•°ç»„
   * @returns {Array<string>} æ ¼å¼åŒ–çš„æ˜¾ç¤ºåç§°æ•°ç»„
   */
  static async formatMarkdownLinks(links) {
    const displayNames = [];
    
    for (let i = 0; i < links.length; i++) {
      const link = links[i];
      let displayName = `${i + 1}. [${link.displayText}]`;
      
      // å°è¯•è·å–ç›®æ ‡ç¬”è®°ä¿¡æ¯
      try {
        const targetNote = MNNote.new(link.noteId, false);
        if (targetNote) {
          const targetMNNote = MNNote.new(targetNote);
          const titleParts = this.parseNoteTitle(targetMNNote);
          let content = titleParts.content || targetNote.noteTitle || "";
          
          // å»æ‰å¯èƒ½çš„ "; " å‰ç¼€
          if (content.startsWith("; ")) {
            content = content.substring(2).trim();
          }
          
          // å¦‚æœå®é™…æ ‡é¢˜ä¸é“¾æ¥æ–‡æœ¬ä¸åŒï¼Œæ˜¾ç¤ºæ˜ å°„å…³ç³»
          if (content && content !== link.displayText) {
            displayName += ` â†’ ${content}`;
          }
        } else {
          displayName += " (ç¬”è®°ä¸å­˜åœ¨)";
        }
      } catch (e) {
        displayName += " (æ— æ³•è·å–)";
      }
      
      // å¦‚æœåŒä¸€è¯„è®ºæœ‰å¤šä¸ªé“¾æ¥ï¼Œæ·»åŠ æ ‡è¯†
      const samCommentLinks = links.filter(l => l.commentIndex === link.commentIndex);
      if (samCommentLinks.length > 1) {
        displayName += ` [è¯„è®º${link.commentIndex + 1}-é“¾æ¥${link.linkIndexInComment + 1}]`;
      }
      
      displayNames.push(displayName);
    }
    
    return displayNames;
  }

  /**
   * æ˜¾ç¤ºé“¾æ¥æ“ä½œé€‰é¡¹
   * 
   * @param {Object} link - é“¾æ¥å¯¹è±¡
   */
  static async showLinkActions(link) {
    const actions = [
      "ğŸ“‹ å¤åˆ¶ noteId",
      "ğŸ“ å®šä½åˆ°å¡ç‰‡åˆ°ä¸»è„‘å›¾",
      "ğŸ“ å®šä½åˆ°å¡ç‰‡åˆ°æµ®çª—",
      "ğŸ“„ å¤åˆ¶å®Œæ•´é“¾æ¥",
      "ğŸ“ å¤åˆ¶ Markdown é“¾æ¥",
      "âœ¨ é‡æ–°ç”Ÿæˆ Markdown é“¾æ¥"
    ];
    
    const actionIndex = await MNUtil.userSelect(
      "é€‰æ‹©æ“ä½œ",
      `é“¾æ¥ï¼š${link.displayText}`,
      actions
    );
    
    switch(actionIndex) {
      case 1: // å¤åˆ¶ noteId
        MNUtil.copy(link.noteId);
        MNUtil.showHUD("å·²å¤åˆ¶ noteId: " + link.noteId.substring(0, 8) + "...");
        break;
        
      case 2: // å®šä½å¡ç‰‡
        try {
          MNUtil.focusNoteInMindMapById(link.noteId);
        } catch (error) {
          MNUtil.showHUD("æ— æ³•å®šä½åˆ°å¡ç‰‡");
        }
        break;
      case 3: //  æµ®çª—å®šä½å¡ç‰‡
        try {
          MNUtil.focusNoteInFloatMindMapById(link.noteId);
        } catch (error) {
          MNUtil.showHUD("æ— æ³•å®šä½åˆ°å¡ç‰‡");
        }
        break;
      case 4: // å¤åˆ¶å®Œæ•´é“¾æ¥
        MNUtil.copy(link.url);
        MNUtil.showHUD("å·²å¤åˆ¶å®Œæ•´é“¾æ¥");
        break;
        
      case 5: // å¤åˆ¶ Markdown é“¾æ¥
        MNUtil.copy(link.fullMatch);
        MNUtil.showHUD("å·²å¤åˆ¶ Markdown é“¾æ¥");
        break;
        
      case 6: // é‡æ–°ç”Ÿæˆ Markdown é“¾æ¥
        try {
          const targetNote = MNNote.new(link.noteId, false);
          if (targetNote) {
            const targetMNNote = MNNote.new(targetNote);
            this.copyMarkdownLinkWithQuickPhrases(targetMNNote);
          } else {
            MNUtil.showHUD("æ— æ³•æ‰¾åˆ°å¯¹åº”å¡ç‰‡");
          }
        } catch (error) {
          MNUtil.showHUD("æ“ä½œå¤±è´¥: " + error.message);
        }
        break;
        
      default:
        break;
    }
  }

  /**
   * é€šè¿‡å¼¹çª—é€‰æ‹©å­—æ®µï¼Œç„¶åæ‰¹é‡åˆ é™¤è¯¥å­—æ®µä¸‹çš„è¯„è®º
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„ç¬”è®°
   */
  static deleteCommentsByFieldPopup(note) {
    try {
      // 1. è·å–æ‰€æœ‰å­—æ®µ
      let htmlCommentsTextArr = this.parseNoteComments(note).htmlCommentsTextArr;
      
      if (htmlCommentsTextArr.length === 0) {
        MNUtil.showHUD("å½“å‰ç¬”è®°æ²¡æœ‰å­—æ®µ");
        return;
      }
      
      // 2. è®©ç”¨æˆ·é€‰æ‹©å­—æ®µ
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        "é€‰æ‹©å­—æ®µ",
        "é€‰æ‹©è¦æŸ¥çœ‹å’Œåˆ é™¤è¯„è®ºçš„å­—æ®µ",
        0,
        "å–æ¶ˆ",
        htmlCommentsTextArr,
        (alert, buttonIndex) => {
          if (buttonIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
          
          let selectedField = htmlCommentsTextArr[buttonIndex - 1];
          
          // 3. è·å–è¯¥å­—æ®µä¸‹çš„æ‰€æœ‰è¯„è®º
          let fieldComments = this.getFieldCommentsForDeletion(note, selectedField);
          
          if (fieldComments.length === 0) {
            MNUtil.showHUD(`å­—æ®µ"${selectedField}"ä¸‹æ²¡æœ‰è¯„è®º`);
            return;
          }
          
          // 4. å¼€å§‹é€’å½’é€‰æ‹©æµç¨‹
          let selectedIndices = new Set();
          this.showCommentSelectionDialog(note, selectedField, fieldComments, selectedIndices);
        }
      );
      
    } catch (error) {
      MNUtil.showHUD("æ“ä½œå¤±è´¥ï¼š" + error.toString());
      MNUtil.log("deleteCommentsByFieldPopup å‡ºé”™: " + error.toString());
    }
  }

  /**
   * è·å–æŒ‡å®šå­—æ®µä¸‹çš„æ‰€æœ‰è¯„è®ºä¿¡æ¯
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} fieldName - å­—æ®µåç§°
   * @returns {Array} è¯„è®ºä¿¡æ¯æ•°ç»„ [{index, display, comment}]
   */
  static getFieldCommentsForDeletion(note, fieldName) {
    let commentsObj = this.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    
    // æ‰¾åˆ°å¯¹åº”å­—æ®µ
    let fieldObj = htmlCommentsObjArr.find(obj => obj.text === fieldName);
    if (!fieldObj) {
      return [];
    }
    
    // è·å–è¯¥å­—æ®µä¸‹çš„è¯„è®ºç´¢å¼•ï¼ˆä¸åŒ…æ‹¬å­—æ®µæœ¬èº«ï¼‰
    let fieldIndices = fieldObj.excludingFieldBlockIndexArr;
    
    // æ„å»ºè¯„è®ºä¿¡æ¯æ•°ç»„
    let fieldComments = [];
    for (let index of fieldIndices) {
      let comment = note.MNComments[index];
      if (comment) {
        let displayText = this.formatCommentForDisplay(comment, index, note);
        fieldComments.push({
          index: index,
          display: displayText,
          comment: comment
        });
      }
    }
    
    return fieldComments;
  }

  /**
   * æ ¼å¼åŒ–è¯„è®ºå†…å®¹ç”¨äºæ˜¾ç¤º
   * 
   * @param {MNComment} comment - è¯„è®ºå¯¹è±¡
   * @param {number} index - è¯„è®ºç´¢å¼•
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @returns {string} æ ¼å¼åŒ–åçš„æ˜¾ç¤ºæ–‡æœ¬
   */
  static formatCommentForDisplay(comment, index, note) {
    // comment å·²ç»æ˜¯ MNComment å¯¹è±¡ï¼Œç›´æ¥ä½¿ç”¨å®ƒçš„ type å±æ€§
    const commentType = comment.type;
    const maxTextLength = 30;
    
    switch (commentType) {
      // TextNote ç±»å‹
      case "textComment":
        return this.truncateText(comment.text, maxTextLength);
        
      case "markdownComment":
        // æ£€æŸ¥æ˜¯å¦æ˜¯ HtmlMarkdown æ ¼å¼
        let commentText = comment.text;
        // å»æ‰å¯èƒ½çš„ "- " å‰ç¼€
        if (commentText && commentText.startsWith("- ")) {
          commentText = commentText.substring(2);
        }
        
        if (commentText && HtmlMarkdownUtils.isHtmlMDComment(commentText)) {
          const type = HtmlMarkdownUtils.getSpanType(commentText);
          const content = HtmlMarkdownUtils.getSpanTextContent(commentText);
          const icon = HtmlMarkdownUtils.icons[type] || "";
          const prefix = HtmlMarkdownUtils.prefix[type] || "";
          // æ ¼å¼åŒ–æ˜¾ç¤ºï¼š[ç±»å‹å›¾æ ‡] å†…å®¹
          const displayText = `[${icon}] ${prefix}${content}`;
          return this.truncateText(displayText, maxTextLength);
        } else {
          // æ™®é€š Markdown è¯„è®º
          return "[Markdown] " + this.truncateText(comment.text, maxTextLength - 11);
        }
        
      case "tagComment":
        return "[æ ‡ç­¾] " + comment.text;
        
      case "linkComment":
        return this.formatLinkComment(comment.text, false);
        
      case "summaryComment":
        return this.formatLinkComment(comment.text, true);
        
      // HtmlNote ç±»å‹
      case "HtmlComment":
        return "[å­—æ®µ] " + comment.text;
        
      // LinkNote ç±»å‹ï¼ˆåˆå¹¶å†…å®¹ï¼‰
      case "mergedTextComment":
        return "[æ‘˜å½•-æ–‡æœ¬] " + this.truncateText(comment.text, maxTextLength - 12);
        
      case "mergedImageComment":
        return "[æ‘˜å½•-å›¾ç‰‡]";
        
      case "mergedImageCommentWithDrawing":
        return "[æ‘˜å½•-å›¾ç‰‡+æ‰‹å†™]";
        
      case "blankTextComment":
        return "[æ‘˜å½•-ç©ºç™½æ–‡æœ¬]";
        
      case "blankImageComment":
        return "[æ‘˜å½•-ç©ºç™½å›¾ç‰‡]";
        
      // PaintNote ç±»å‹
      case "imageComment":
        return "[å›¾ç‰‡]";
        
      case "imageCommentWithDrawing":
        return "[å›¾ç‰‡+æ‰‹å†™]";
        
      case "drawingComment":
        return "[çº¯æ‰‹å†™]";
        
      default:
        // æ£€æŸ¥æ˜¯å¦æ˜¯ HtmlMarkdown è¯„è®º
        if (comment.text) {
          let cleanText = comment.text;
          // å»æ‰å¯èƒ½çš„ "- " å‰ç¼€
          if (cleanText.startsWith("- ")) {
            cleanText = cleanText.substring(2);
          }
          
          if (HtmlMarkdownUtils.isHtmlMDComment(cleanText)) {
            const type = HtmlMarkdownUtils.getSpanType(cleanText);
            const content = HtmlMarkdownUtils.getSpanTextContent(cleanText);
            const icon = HtmlMarkdownUtils.icons[type] || "";
            const prefix = HtmlMarkdownUtils.prefix[type] || "";
            // æ ¼å¼åŒ–æ˜¾ç¤ºï¼š[ç±»å‹å›¾æ ‡] å†…å®¹
            const displayText = `[${icon}] ${prefix}${content}`;
            return this.truncateText(displayText, maxTextLength);
          }
        }
        return `[${commentType || 'æœªçŸ¥ç±»å‹'}]`;
    }
  }

  /**
   * æ ¼å¼åŒ–é“¾æ¥è¯„è®º
   * 
   * @param {string} linkUrl - é“¾æ¥URL
   * @param {boolean} isSummary - æ˜¯å¦æ˜¯æ¦‚è¦é“¾æ¥
   * @returns {string} æ ¼å¼åŒ–çš„é“¾æ¥æ˜¾ç¤º
   */
  static formatLinkComment(linkUrl, isSummary = false) {
    try {
      // æå– noteId
      let noteId = linkUrl.match(/marginnote[34]app:\/\/note\/([^\/]+)/)?.[1];
      if (!noteId) {
        return isSummary ? "[æ¦‚è¦é“¾æ¥] æ— æ•ˆé“¾æ¥" : "[é“¾æ¥] æ— æ•ˆé“¾æ¥";
      }
      
      // å°è¯•è·å–ç›®æ ‡ç¬”è®°
      let targetNote = MNNote.new(noteId, false);
      if (targetNote && targetNote.noteTitle) {
        // ä½¿ç”¨ parseNoteTitle è§£ææ ‡é¢˜
        const titleParts = this.parseNoteTitle(targetNote);
        
        // è·å–å†…å®¹éƒ¨åˆ†ï¼Œå¹¶å»æ‰å¯èƒ½çš„ "; " å‰ç¼€
        let content = titleParts.content || targetNote.noteTitle || "";
        if (content.startsWith("; ")) {
          content = content.substring(2).trim();
        }
        
        // æ ¼å¼åŒ–æ˜¾ç¤ºï¼š[ç±»å‹] å†…å®¹
        const type = titleParts.type || "";
        // æ£€æŸ¥æ˜¯å¦ä¸ºå½’ç±»å¡ç‰‡ï¼Œå¦‚æœæ˜¯åˆ™æ·»åŠ "å½’ç±»"åç¼€
        let displayType = type;
        if (type && this.getNoteType(targetNote) === "å½’ç±»") {
          displayType = type + "å½’ç±»";
        }
        const formattedTitle = displayType ? `[${displayType}] ${content}` : content;
        
        // æˆªæ–­å¤„ç†
        let truncatedTitle = this.truncateText(formattedTitle, 30);  // å¢åŠ é•¿åº¦åˆ°30ï¼Œå› ä¸ºç±»å‹æ ‡è¯†å ç”¨äº†ç©ºé—´
        
        return isSummary ? `[æ¦‚è¦é“¾æ¥] ${truncatedTitle}` : `[é“¾æ¥] ${truncatedTitle}`;
      } else {
        return isSummary ? "[æ¦‚è¦é“¾æ¥] (ç¬”è®°ä¸å­˜åœ¨)" : "[é“¾æ¥] (ç¬”è®°ä¸å­˜åœ¨)";
      }
    } catch (error) {
      return isSummary ? "[æ¦‚è¦é“¾æ¥] (è·å–å¤±è´¥)" : "[é“¾æ¥] (è·å–å¤±è´¥)";
    }
  }

  /**
   * æˆªæ–­æ–‡æœ¬å¹¶æ·»åŠ çœç•¥å·
   * 
   * @param {string} text - åŸå§‹æ–‡æœ¬
   * @param {number} maxLength - æœ€å¤§é•¿åº¦
   * @returns {string} æˆªæ–­åçš„æ–‡æœ¬
   */
  static truncateText(text, maxLength) {
    if (!text) return "";
    text = text.trim();
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength) + "...";
  }

  /**
   * æ˜¾ç¤ºè¯„è®ºé€‰æ‹©å¯¹è¯æ¡†ï¼ˆé€’å½’ï¼‰
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} fieldName - å­—æ®µåç§°
   * @param {Array} fieldComments - è¯„è®ºä¿¡æ¯æ•°ç»„
   * @param {Set} selectedIndices - å·²é€‰ä¸­çš„ç´¢å¼•é›†åˆ
   */
  static showCommentSelectionDialog(note, fieldName, fieldComments, selectedIndices) {
    // æ„å»ºæ˜¾ç¤ºé€‰é¡¹
    let displayOptions = fieldComments.map(item => {
      let prefix = selectedIndices.has(item.index) ? "âœ… " : "";
      return prefix + item.display;
    });
    
    // æ·»åŠ å…¨é€‰/å–æ¶ˆå…¨é€‰é€‰é¡¹
    let allSelected = selectedIndices.size === fieldComments.length;
    let selectAllText = allSelected ? "â¬œ å–æ¶ˆå…¨é€‰" : "â˜‘ï¸ å…¨é€‰æ‰€æœ‰è¯„è®º";
    displayOptions.unshift(selectAllText);
    
    // æ·»åŠ ç¡®å®šåˆ é™¤é€‰é¡¹
    displayOptions.push("ğŸ“Œ ç¡®å®šåˆ é™¤é€‰ä¸­çš„è¯„è®º");
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      `å­—æ®µ"${fieldName}"çš„è¯„è®º`,
      `å·²é€‰ä¸­ ${selectedIndices.size}/${fieldComments.length} æ¡è¯„è®º`,
      0,
      "å–æ¶ˆ",
      displayOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
        
        if (buttonIndex === 1) {
          // ç”¨æˆ·é€‰æ‹©äº†å…¨é€‰/å–æ¶ˆå…¨é€‰
          if (allSelected) {
            // å–æ¶ˆå…¨é€‰
            selectedIndices.clear();
          } else {
            // å…¨é€‰
            fieldComments.forEach(item => {
              selectedIndices.add(item.index);
            });
          }
          
          // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
          this.showCommentSelectionDialog(note, fieldName, fieldComments, selectedIndices);
          
        } else if (buttonIndex === displayOptions.length) {
          // ç”¨æˆ·é€‰æ‹©äº†"ç¡®å®šåˆ é™¤"
          if (selectedIndices.size === 0) {
            MNUtil.showHUD("æ²¡æœ‰é€‰ä¸­ä»»ä½•è¯„è®º");
            return;
          }
          
          // æ‰§è¡Œåˆ é™¤
          this.deleteSelectedComments(note, selectedIndices);
          
        } else {
          // ç”¨æˆ·é€‰æ‹©äº†æŸä¸ªè¯„è®ºï¼Œåˆ‡æ¢é€‰ä¸­çŠ¶æ€
          let selectedComment = fieldComments[buttonIndex - 2]; // å› ä¸ºåŠ äº†å…¨é€‰é€‰é¡¹ï¼Œæ‰€ä»¥ç´¢å¼•è¦å‡2
          
          if (selectedIndices.has(selectedComment.index)) {
            selectedIndices.delete(selectedComment.index);
          } else {
            selectedIndices.add(selectedComment.index);
          }
          
          // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
          this.showCommentSelectionDialog(note, fieldName, fieldComments, selectedIndices);
        }
      }
    );
  }

  /**
   * åˆ é™¤é€‰ä¸­çš„è¯„è®º
   * 
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Set} selectedIndices - è¦åˆ é™¤çš„è¯„è®ºç´¢å¼•é›†åˆ
   */
  static deleteSelectedComments(note, selectedIndices) {
    try {
      // å°†ç´¢å¼•è½¬ä¸ºæ•°ç»„å¹¶æ’åºï¼ˆä»å¤§åˆ°å°ï¼‰ï¼Œé¿å…åˆ é™¤æ—¶ç´¢å¼•å˜åŒ–
      let sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);
      
      MNUtil.undoGrouping(() => {
        for (let index of sortedIndices) {
          note.removeCommentByIndex(index);
        }
      });
      
      MNUtil.showHUD(`æˆåŠŸåˆ é™¤ ${selectedIndices.size} æ¡è¯„è®º`);
      
    } catch (error) {
      MNUtil.showHUD("åˆ é™¤è¯„è®ºæ—¶å‡ºé”™ï¼š" + error.toString());
      MNUtil.log("deleteSelectedComments å‡ºé”™: " + error.toString());
    }
  }

  /**
   * æ‰¹é‡å‘ä¸ŠæŸ¥æ‰¾å®šä¹‰ç±»å¡ç‰‡
   * ä»å½“å‰å¡ç‰‡å‘ä¸Šéå†çˆ¶å¡ç‰‡ï¼Œæ”¶é›†å¤šä¸ªå®šä¹‰ç±»å¡ç‰‡
   * 
   * @param {MNNote} startNote - èµ·å§‹å¡ç‰‡
   * @param {number} maxCount - æœ€å¤šæŸ¥æ‰¾çš„æ•°é‡ï¼Œé»˜è®¤5ä¸ª
   * @returns {Object} è¿”å›å¯¹è±¡åŒ…å« cardsï¼ˆå®šä¹‰å¡ç‰‡æ•°ç»„ï¼‰å’Œ lastNoteï¼ˆæœ€åæ£€æŸ¥çš„å¡ç‰‡ï¼‰
   */
  static findDefinitionCards(startNote, maxCount = 5) {
    const definitionCards = []
    let currentNote = startNote
    
    while (currentNote && currentNote.parentNote && definitionCards.length < maxCount) {
      currentNote = MNNote.new(currentNote.parentNote)
      
      // æ£€æŸ¥æ˜¯å¦ä¸ºå®šä¹‰ç±»å¡ç‰‡
      if (this.getNoteType(currentNote) === "å®šä¹‰") {
        definitionCards.push(currentNote)
      }
    }
    
    return { 
      cards: definitionCards, 
      lastNote: currentNote  // ä¿å­˜æœ€åæ£€æŸ¥çš„å¡ç‰‡ï¼Œç”¨äºç»§ç»­æŸ¥æ‰¾
    }
  }

  /**
   * é€‰æ‹©å®šä¹‰å¡ç‰‡
   * ä»æ‰¾åˆ°çš„å¤šä¸ªå®šä¹‰å¡ç‰‡ä¸­è®©ç”¨æˆ·é€‰æ‹©ä¸€ä¸ª
   * 
   * @param {Array<MNNote>} definitionCards - å®šä¹‰å¡ç‰‡æ•°ç»„
   * @param {boolean} canContinue - æ˜¯å¦å¯ä»¥ç»§ç»­å‘ä¸ŠæŸ¥æ‰¾
   * @returns {Promise<{selected: MNNote|null, continue: boolean}>} è¿”å›é€‰ä¸­çš„å¡ç‰‡æˆ–ç»§ç»­æŸ¥æ‰¾çš„æ ‡å¿—
   */
  static async selectDefinitionCard(definitionCards, canContinue = true) {
    if (definitionCards.length === 0) {
      return { selected: null, continue: false }
    }
    
    // æ„å»ºé€‰é¡¹åˆ—è¡¨
    const options = definitionCards.map(card => {
      const parsed = this.parseNoteTitle(card)
      const prefix = parsed.prefixContent || ""
      const content = parsed.content || card.title || "æœªå‘½åå®šä¹‰"
      return prefix ? `ã€å®šä¹‰ï¼š${prefix}ã€‘${content}` : `ã€å®šä¹‰ã€‘${content}`
    })
    
    // å¦‚æœå¯ä»¥ç»§ç»­æŸ¥æ‰¾ï¼Œæ·»åŠ é€‰é¡¹
    if (canContinue) {
      options.push("â¬†ï¸ ç»§ç»­å‘ä¸ŠæŸ¥æ‰¾æ›´å¤š...")
    }
    
    // æ˜¾ç¤ºé€‰æ‹©å¼¹çª—
    return new Promise((resolve) => {
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        "é€‰æ‹©å®šä¹‰å¡ç‰‡",
        `æ‰¾åˆ° ${definitionCards.length} ä¸ªå®šä¹‰å¡ç‰‡ï¼Œè¯·é€‰æ‹©ï¼š`,
        0,
        "å–æ¶ˆ",
        options,
        (alert, buttonIndex) => {
          if (buttonIndex === 0) {
            // å–æ¶ˆ
            resolve({ selected: null, continue: false })
          } else if (canContinue && buttonIndex === options.length) {
            // é€‰æ‹©äº†"ç»§ç»­å‘ä¸ŠæŸ¥æ‰¾"
            resolve({ selected: null, continue: true })
          } else {
            // é€‰æ‹©äº†æŸä¸ªå®šä¹‰å¡ç‰‡
            const selectedIndex = buttonIndex - 1
            resolve({ selected: definitionCards[selectedIndex], continue: false })
          }
        }
      )
    })
  }

  /**
   * é‡æ–°æ’åº"ç›¸å…³é“¾æ¥"å­—æ®µä¸‹çš„å½’ç±»å¡ç‰‡é“¾æ¥
   * æŒ‰ç…§ç±»å‹ï¼ˆå‘½é¢˜ã€åä¾‹ã€ä¾‹å­ç­‰ï¼‰å¯¹é“¾æ¥è¿›è¡Œåˆ†ç»„æ’åº
   * ä¿æŒçˆ¶å¡ç‰‡ï¼ˆå½’ç±»å¡ç‰‡ï¼‰é“¾æ¥åœ¨ç¬¬ä¸€æ¡ä½ç½®
   * 
   * @param {MNNote} defNote - å®šä¹‰ç±»å¡ç‰‡
   * @returns {boolean} æ˜¯å¦è¿›è¡Œäº†é‡æ–°æ’åº
   */
  static reorderContainsFieldLinks(defNote) {
    try {
      const commentsObj = this.parseNoteComments(defNote)
      
      // æ‰¾åˆ°"ç›¸å…³é“¾æ¥"å­—æ®µ
      const containsField = commentsObj.htmlCommentsObjArr.find(field => {
        const fieldText = field.text.trim()
        return fieldText === "ç›¸å…³é“¾æ¥" || fieldText === "ç›¸å…³é“¾æ¥:" || fieldText === "ç›¸å…³é“¾æ¥ï¼š"
      })
      
      if (!containsField) {
        MNUtil.log("æœªæ‰¾åˆ°'ç›¸å…³é“¾æ¥'å­—æ®µ")
        return false
      }
      
      // è·å–å­—æ®µä¸‹çš„æ‰€æœ‰é“¾æ¥è¯„è®º
      const fieldIndices = containsField.excludingFieldBlockIndexArr
      const linkComments = []
      
      fieldIndices.forEach(index => {
        const comment = defNote.MNComments[index]
        if (comment && comment.type === "linkComment") {
          linkComments.push({ index, comment })
        }
      })
      
      if (linkComments.length === 0) {
        MNUtil.log("'ç›¸å…³é“¾æ¥'å­—æ®µä¸‹æ²¡æœ‰é“¾æ¥")
        return false
      }
      
      // è·å–å®šä¹‰å¡ç‰‡çš„çˆ¶å¡ç‰‡IDï¼ˆå¦‚æœå­˜åœ¨ä¸”æ˜¯å½’ç±»å¡ç‰‡ï¼‰
      let parentNoteId = null
      const parentNote = defNote.parentNote
      if (parentNote) {
        const parentType = this.parseNoteTitle(parentNote).type
        if (parentType === "å½’ç±»") {
          parentNoteId = parentNote.noteId
        }
      }
      
      // è·å–æ¯ä¸ªé“¾æ¥å¯¹åº”çš„ç¬”è®°å¹¶è§£æç±»å‹
      let parentLink = null  // ä¿å­˜çˆ¶å¡ç‰‡é“¾æ¥
      const typedLinks = []  // ä¿å­˜å…¶ä»–é“¾æ¥
      
      linkComments.forEach(link => {
        try {
          const noteId = link.comment.text.toNoteId()
          const linkedNote = MNNote.new(noteId)
          if (!linkedNote) return
          
          const parsedTitle = this.parseNoteTitle(MNNote.new(linkedNote))
          const linkData = {
            ...link,
            note: linkedNote,
            noteId: noteId,
            type: parsedTitle.type || "å…¶ä»–",
            content: parsedTitle.content || ""
          }
          
          // åˆ¤æ–­æ˜¯å¦æ˜¯çˆ¶å¡ç‰‡é“¾æ¥
          if (parentNoteId && noteId === parentNoteId) {
            parentLink = linkData
            MNUtil.log("è¯†åˆ«åˆ°çˆ¶å¡ç‰‡ï¼ˆå½’ç±»ï¼‰é“¾æ¥ï¼Œå°†ä¿æŒåœ¨ç¬¬ä¸€æ¡ä½ç½®")
          } else {
            typedLinks.push(linkData)
          }
        } catch (e) {
          MNUtil.log("è§£æé“¾æ¥å¤±è´¥: " + e.toString())
        }
      })
      
      // å¦‚æœæ²¡æœ‰ä»»ä½•æœ‰æ•ˆé“¾æ¥ï¼Œè¿”å›
      if (!parentLink && typedLinks.length === 0) {
        MNUtil.log("æ²¡æœ‰æœ‰æ•ˆçš„é“¾æ¥")
        return false
      }
      
      // å¯¹éçˆ¶å¡ç‰‡é“¾æ¥æŒ‰ç±»å‹åˆ†ç»„æ’åº
      const typeOrder = ["å‘½é¢˜", "åä¾‹", "ä¾‹å­", "é—®é¢˜", "æ€è·¯", "æ€æƒ³æ–¹æ³•"]
      const groupedLinks = {}
      
      typedLinks.forEach(link => {
        if (!groupedLinks[link.type]) {
          groupedLinks[link.type] = []
        }
        groupedLinks[link.type].push(link)
      })
      
      // é‡æ–°æ’åºï¼ˆçˆ¶å¡ç‰‡é“¾æ¥åœ¨æœ€å‰é¢ï¼‰
      const orderedLinks = []
      
      // å¦‚æœæœ‰çˆ¶å¡ç‰‡é“¾æ¥ï¼Œæ”¾åœ¨ç¬¬ä¸€ä½
      if (parentLink) {
        orderedLinks.push(parentLink)
      }
      
      // ç„¶åæ·»åŠ é¢„å®šä¹‰é¡ºåºçš„ç±»å‹
      typeOrder.forEach(type => {
        if (groupedLinks[type]) {
          orderedLinks.push(...groupedLinks[type])
        }
      })
      
      // æœ€åæ·»åŠ å…¶ä»–ç±»å‹
      Object.keys(groupedLinks).forEach(type => {
        if (!typeOrder.includes(type)) {
          orderedLinks.push(...groupedLinks[type])
        }
      })
      
      // æ£€æŸ¥é¡ºåºæ˜¯å¦å‘ç”Ÿå˜åŒ–
      const needReorder = orderedLinks.some((link, idx) => 
        link.index !== fieldIndices[idx]
      )
      
      if (needReorder) {
        MNUtil.undoGrouping(() => {
          // å…ˆåˆ é™¤æ‰€æœ‰é“¾æ¥ï¼ˆä»åå¾€å‰åˆ é™¤ï¼‰
          [...fieldIndices].reverse().forEach(index => {
            const comment = defNote.MNComments[index]
            if (comment && comment.type === "linkComment") {
              defNote.removeCommentByIndex(index)
            }
          })
          
          // æŒ‰æ–°é¡ºåºæ·»åŠ é“¾æ¥
          orderedLinks.forEach(link => {
            defNote.appendNoteLink(MNNote.new(link.note), "To")
          })
        })
        
        MNUtil.log(`é‡æ–°æ’åºäº† ${orderedLinks.length} ä¸ªé“¾æ¥ï¼Œçˆ¶å¡ç‰‡é“¾æ¥${parentLink ? "å·²ä¿æŒåœ¨ç¬¬ä¸€æ¡" : "ä¸å­˜åœ¨"}`)
        return true
      }
      
      MNUtil.log("é“¾æ¥é¡ºåºå·²ç»æ˜¯æ­£ç¡®çš„ï¼Œæ— éœ€é‡æ–°æ’åº")
      return false
      
    } catch (error) {
      MNUtil.log("reorderContainsFieldLinks å‡ºé”™: " + error.toString())
      MNUtil.addErrorLog(error, "reorderContainsFieldLinks")
      return false
    }
  }

  /**
   * æ˜¾ç¤ºå®šä¹‰å¡ç‰‡ç›®å½•ï¼ˆä¸»å‡½æ•°ï¼‰
   * æ•´åˆæŸ¥æ‰¾ã€æ’åºå’Œè·³è½¬åŠŸèƒ½ï¼Œæä¾›å¿«é€Ÿå¯¼èˆªåˆ°å½’ç±»å¡ç‰‡çš„èƒ½åŠ›
   */
  static async showDefinitionCatalog() {
    try {
      // è·å–å½“å‰ç„¦ç‚¹å¡ç‰‡
      const focusNote = MNNote.getFocusNote()
      if (!focusNote) {
        MNUtil.showHUD("è¯·å…ˆé€‰ä¸­ä¸€ä¸ªå¡ç‰‡")
        return
      }
      
      let currentNote = focusNote
      let selectedDefNote = null
      
      // å¾ªç¯æŸ¥æ‰¾ï¼Œç›´åˆ°ç”¨æˆ·é€‰æ‹©ä¸€ä¸ªå®šä¹‰å¡ç‰‡æˆ–å–æ¶ˆ
      while (!selectedDefNote) {
        // æ‰¹é‡æŸ¥æ‰¾å®šä¹‰ç±»å¡ç‰‡
        const result = this.findDefinitionCards(currentNote, 5)
        
        if (result.cards.length === 0) {
          MNUtil.showHUD("æœªæ‰¾åˆ°å®šä¹‰ç±»å¡ç‰‡")
          return
        }
        
        // è®©ç”¨æˆ·é€‰æ‹©
        const canContinue = result.lastNote && result.lastNote.parentNote // è¿˜å¯ä»¥ç»§ç»­å‘ä¸ŠæŸ¥æ‰¾
        const selection = await this.selectDefinitionCard(result.cards, canContinue)
        
        if (!selection.selected && !selection.continue) {
          // ç”¨æˆ·å–æ¶ˆ
          return
        }
        
        if (selection.continue) {
          // ç»§ç»­å‘ä¸ŠæŸ¥æ‰¾
          currentNote = result.lastNote
          continue
        }
        
        // ç”¨æˆ·é€‰æ‹©äº†ä¸€ä¸ªå®šä¹‰å¡ç‰‡
        selectedDefNote = selection.selected
      }
      
      // é‡æ–°æ’åºåŒ…å«å­—æ®µçš„é“¾æ¥
      const reordered = this.reorderContainsFieldLinks(selectedDefNote)
      if (reordered) {
        MNUtil.showHUD("å·²é‡æ–°æ’åºå½’ç±»å¡ç‰‡")
      }
      
      // è·å–ç›¸å…³é“¾æ¥å­—æ®µä¸‹çš„æ‰€æœ‰é“¾æ¥
      const commentsObj = this.parseNoteComments(selectedDefNote)
      const containsField = commentsObj.htmlCommentsObjArr.find(field => {
        const fieldText = field.text.trim()
        return fieldText === "ç›¸å…³é“¾æ¥" || fieldText === "ç›¸å…³é“¾æ¥:" || fieldText === "ç›¸å…³é“¾æ¥ï¼š"
      })
      
      if (!containsField) {
        MNUtil.showHUD("å®šä¹‰å¡ç‰‡ä¸­æ²¡æœ‰'ç›¸å…³é“¾æ¥'å­—æ®µ")
        return
      }
      
      // æ”¶é›†é“¾æ¥ä¿¡æ¯
      const fieldIndices = containsField.excludingFieldBlockIndexArr
      const linkOptions = []
      const linkNoteIds = []
      
      fieldIndices.forEach(index => {
        const comment = selectedDefNote.MNComments[index]
        if (comment && comment.type === "linkComment") {
          try {
            const noteId = comment.text.toNoteId()
            const linkedNote = MNNote.new(noteId)
            if (!linkedNote) return
            
            const parsedTitle = this.parseNoteTitle(MNNote.new(linkedNote))
            
            // æ ¼å¼åŒ–æ˜¾ç¤ºé€‰é¡¹
            const type = parsedTitle.type || "?"
            const content = parsedTitle.content || "æœªçŸ¥å†…å®¹"
            const displayText = `[${type}] "${content}"`
            
            linkOptions.push(displayText)
            linkNoteIds.push(noteId)
          } catch (e) {
            MNUtil.log("å¤„ç†é“¾æ¥æ—¶å‡ºé”™: " + e.toString())
          }
        }
      })
      
      if (linkOptions.length === 0) {
        MNUtil.showHUD("ç›¸å…³é“¾æ¥å­—æ®µä¸‹æ²¡æœ‰æœ‰æ•ˆçš„å½’ç±»å¡ç‰‡")
        return
      }
      
      // è·å–å®šä¹‰å¡ç‰‡çš„æ ‡é¢˜ä¿¡æ¯
      const defParsedTitle = this.parseNoteTitle(selectedDefNote)
      const defTitle = defParsedTitle.prefixContent ? 
        `ã€å®šä¹‰ï¼š${defParsedTitle.prefixContent}ã€‘` : 
        selectedDefNote.title
      
      // å°†å®šä¹‰å¡ç‰‡æœ¬èº«ä½œä¸ºç¬¬ä¸€ä¸ªé€‰é¡¹
      linkOptions.unshift(`ğŸ“ ${defTitle} (å®šä¹‰å¡ç‰‡æœ¬èº«)`)
      linkNoteIds.unshift(selectedDefNote.noteId)
      
      // æ˜¾ç¤ºé€‰æ‹©å¼¹çª—
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        "é€‰æ‹©å½’ç±»å¡ç‰‡",
        `å®šä¹‰ï¼š${defTitle}\nå…± ${linkOptions.length} ä¸ªå½’ç±»å¡ç‰‡`,
        0,
        "å–æ¶ˆ",
        linkOptions,
        (alert, buttonIndex) => {
          if (buttonIndex === 0) return // å–æ¶ˆ
          
          const selectedIndex = buttonIndex - 1
          const selectedNoteId = linkNoteIds[selectedIndex]
          
          // åœ¨ FloatMindMap ä¸­å®šä½
          MNUtil.focusNoteInMindMapById(selectedNoteId)
          // MNUtil.showHUD("å·²å®šä½åˆ°å½’ç±»å¡ç‰‡")
        }
      )
      
    } catch (error) {
      MNUtil.addErrorLog(error, "showDefinitionCatalog")
      MNUtil.showHUD("å‘ç”Ÿé”™è¯¯ï¼š" + error.message)
    }
  }

  /**
   * æœç´¢åŠŸèƒ½ç›¸å…³é…ç½®å’Œæ–¹æ³•
   */
  
  // æœç´¢æ ¹ç›®å½•é…ç½®
  static searchRootConfigs = null;
  static tempRootInfo = null; // å­˜å‚¨ä¸´æ—¶æ ¹ç›®å½•ä¿¡æ¯
  static searchBoardId = "37F2105C-35E4-4840-AD79-DA4702C36BE1";  // æœç´¢ç­›é€‰çœ‹æ¿ ID
  
  // æ­£åˆ™è¡¨è¾¾å¼æœç´¢å‰ç¼€
  static REGEX_PREFIXES = ['r:', 're:', 'regex:'];
  
  /**
   * è§£ææœç´¢å…³é”®è¯ï¼Œè¯†åˆ«æ­£åˆ™è¡¨è¾¾å¼å‰ç¼€
   * @param {string} keyword - è¾“å…¥çš„å…³é”®è¯
   * @param {boolean} regexEnabled - æ˜¯å¦å¯ç”¨æ­£åˆ™è¡¨è¾¾å¼æœç´¢
   * @returns {Object} åŒ…å« type å’Œ pattern çš„å¯¹è±¡
   */
  static parseSearchKeyword(keyword, regexEnabled) {
    if (!regexEnabled) {
      // æœªå¯ç”¨æ­£åˆ™æœç´¢ï¼Œå…¨éƒ¨ä½œä¸ºæ™®é€šæ–‡æœ¬
      return { type: 'text', pattern: keyword };
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰æ­£åˆ™å‰ç¼€
    const lowerKeyword = keyword.toLowerCase();
    for (const prefix of this.REGEX_PREFIXES) {
      if (lowerKeyword.startsWith(prefix)) {
        return {
          type: 'regex',
          pattern: keyword.substring(prefix.length).trim()
        };
      }
    }
    
    // æ— å‰ç¼€ï¼Œæ™®é€šæ–‡æœ¬
    return { type: 'text', pattern: keyword };
  }
  
  /**
   * åˆå§‹åŒ–æœç´¢é…ç½®
   */
  static initSearchConfig() {
    if (!this.searchRootConfigs) {
      this.searchRootConfigs = this.loadSearchConfig();
      
      // æ¢å¤ä¸´æ—¶æ ¹ç›®å½•ä¿¡æ¯
      if (this.searchRootConfigs.tempRoot) {
        this.tempRootInfo = this.searchRootConfigs.tempRoot;
      }
    }
    return this.searchRootConfigs;
  }
  
  /**
   * åŠ è½½æœç´¢é…ç½®ï¼ˆä» iCloud æˆ–æœ¬åœ°ï¼‰
   */
  static loadSearchConfig() {
    try {
      // å…ˆå°è¯•ä»æœ¬åœ°åŠ è½½
      const localConfig = NSUserDefaults.standardUserDefaults().objectForKey("KnowledgeBaseTemplate_SearchConfig");
      let config = localConfig ? JSON.parse(localConfig) : null;
      
      // å¦‚æœå¼€å¯äº† iCloud åŒæ­¥ï¼Œå°è¯•ä» iCloud åŠ è½½
      if (typeof toolbarConfig !== 'undefined' && toolbarConfig.iCloudSync) {
        const cloudStore = NSUbiquitousKeyValueStore.defaultStore();
        if (cloudStore) {
          const cloudConfig = cloudStore.objectForKey("KnowledgeBaseTemplate_SearchConfig");
          if (cloudConfig) {
            const cloudData = JSON.parse(cloudConfig);
            // æ¯”è¾ƒæ—¶é—´æˆ³ï¼Œä½¿ç”¨è¾ƒæ–°çš„é…ç½®
            if (!config || (cloudData.lastModified > config.lastModified)) {
              config = cloudData;
            }
          }
        }
      }
      
      // å¦‚æœæ²¡æœ‰é…ç½®ï¼Œä½¿ç”¨é»˜è®¤é…ç½®
      if (!config) {
        config = {
          roots: {
            default: {
              id: "B2A5D567-909C-44E8-BC08-B1532D3D0AA1",
              name: "æ•°å­¦çŸ¥è¯†åº“",
              isDefault: true
            }
          },
          rootsOrder: ["default"],  // æ–°å¢ï¼šæ ¹ç›®å½•é¡ºåºæ•°ç»„
          lastUsedRoot: "default",
          includeClassification: true,  // é»˜è®¤åŒ…å«å½’ç±»å¡ç‰‡
          ignorePrefix: false,  // é»˜è®¤æœç´¢å®Œæ•´æ ‡é¢˜
          searchInKeywords: false,  // é»˜è®¤ä¸æœç´¢å…³é”®è¯å­—æ®µ
          onlyClassification: false,  // é»˜è®¤ä¸å¯ç”¨åªæœç´¢å½’ç±»å¡ç‰‡
          skipEmptyTitle: false,  // é»˜è®¤ä¸è·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡
          enableRegexSearch: false,  // é»˜è®¤ä¸å¯ç”¨æ­£åˆ™è¡¨è¾¾å¼æœç´¢
          lastModified: Date.now()
        };
      }
      
      // ç¡®ä¿æ—§é…ç½®æœ‰è¿™äº›å­—æ®µï¼ˆå‘åå…¼å®¹ï¼‰
      if (config && config.includeClassification === undefined) {
        config.includeClassification = true;
      }
      if (config && config.ignorePrefix === undefined) {
        config.ignorePrefix = false;
      }
      if (config && config.searchInKeywords === undefined) {
        config.searchInKeywords = false;
      }
      if (config && config.onlyClassification === undefined) {
        config.onlyClassification = false;  // é»˜è®¤ä¸å¯ç”¨åªæœç´¢å½’ç±»å¡ç‰‡
      }
      // æ·»åŠ è·³è¿‡ç©ºç™½æ ‡é¢˜å­—æ®µ
      if (config && config.skipEmptyTitle === undefined) {
        config.skipEmptyTitle = false;
      }
      // æ·»åŠ æ­£åˆ™è¡¨è¾¾å¼æœç´¢å­—æ®µ
      if (config && config.enableRegexSearch === undefined) {
        config.enableRegexSearch = false;
      }
      
      // ä¸ºç°æœ‰æ ¹ç›®å½•æ·»åŠ  skipEmptyTitleByDefault å­—æ®µï¼ˆå‘åå…¼å®¹ï¼‰
      if (config && config.roots) {
        for (const key in config.roots) {
          if (config.roots[key].skipEmptyTitleByDefault === undefined) {
            config.roots[key].skipEmptyTitleByDefault = false;
          }
        }
      }
      
      // æ•°æ®è¿ç§»ï¼šå¦‚æœæ—§ç‰ˆæœ¬æ²¡æœ‰ rootsOrderï¼Œè‡ªåŠ¨ç”Ÿæˆ
      if (config && config.roots && !config.rootsOrder) {
        config.rootsOrder = Object.keys(config.roots);
        // ç¡®ä¿ default åœ¨ç¬¬ä¸€ä½
        const defaultIndex = config.rootsOrder.indexOf("default");
        if (defaultIndex > 0) {
          config.rootsOrder.splice(defaultIndex, 1);
          config.rootsOrder.unshift("default");
        }
      }
      
      return config;
    } catch (error) {
      MNUtil.log("åŠ è½½æœç´¢é…ç½®å¤±è´¥: " + error.toString());
      // è¿”å›é»˜è®¤é…ç½®
      return {
        roots: {
          default: {
            id: "B2A5D567-909C-44E8-BC08-B1532D3D0AA1",
            name: "æ•°å­¦çŸ¥è¯†åº“",
            isDefault: true,
            skipEmptyTitleByDefault: false
          }
        },
        rootsOrder: ["default"],  // æ ¹ç›®å½•é¡ºåº
        lastUsedRoot: "default",
        includeClassification: true,  // é»˜è®¤åŒ…å«å½’ç±»å¡ç‰‡
        ignorePrefix: false,  // é»˜è®¤æœç´¢å®Œæ•´æ ‡é¢˜
        searchInKeywords: false,  // é»˜è®¤ä¸æœç´¢å…³é”®è¯å­—æ®µ
        onlyClassification: false,  // é»˜è®¤ä¸å¯ç”¨åªæœç´¢å½’ç±»å¡ç‰‡
        skipEmptyTitle: false,  // é»˜è®¤ä¸è·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡
        enableRegexSearch: false,  // é»˜è®¤ä¸å¯ç”¨æ­£åˆ™è¡¨è¾¾å¼æœç´¢
        lastModified: Date.now()
      };
    }
  }
  
  /**
   * ä¿å­˜æœç´¢é…ç½®ï¼ˆåˆ° iCloud å’Œæœ¬åœ°ï¼‰
   */
  static saveSearchConfig() {
    try {
      if (!this.searchRootConfigs) {
        this.initSearchConfig();
      }
      
      this.searchRootConfigs.lastModified = Date.now();
      const configStr = JSON.stringify(this.searchRootConfigs);
      
      // ä¿å­˜åˆ°æœ¬åœ°
      NSUserDefaults.standardUserDefaults().setObjectForKey(configStr, "KnowledgeBaseTemplate_SearchConfig");
      
      // å¦‚æœå¼€å¯äº† iCloud åŒæ­¥ï¼Œä¿å­˜åˆ° iCloud
      if (typeof toolbarConfig !== 'undefined' && toolbarConfig.iCloudSync) {
        const cloudStore = NSUbiquitousKeyValueStore.defaultStore();
        if (cloudStore) {
          cloudStore.setObjectForKey(configStr, "KnowledgeBaseTemplate_SearchConfig");
          cloudStore.synchronize();
        }
      }
      
      return true;
    } catch (error) {
      MNUtil.log("ä¿å­˜æœç´¢é…ç½®å¤±è´¥: " + error.toString());
      return false;
    }
  }
  
  /**
   * è·å–å½“å‰æœç´¢æ ¹ç›®å½• ID
   */
  static getCurrentSearchRoot() {
    this.initSearchConfig();
    const lastUsed = this.searchRootConfigs.lastUsedRoot;
    const root = this.searchRootConfigs.roots[lastUsed];
    return root ? root.id : this.searchRootConfigs.roots.default.id;
  }
  
  /**
   * è·å–ä¸Šæ¬¡ä½¿ç”¨çš„æ ¹ç›®å½•IDæ•°ç»„ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
   */
  static getLastUsedRootIds() {
    this.initSearchConfig();
    
    // ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦æœ‰ä¸´æ—¶æ ¹ç›®å½•
    if (this.searchRootConfigs.tempRoot) {
      // æ¢å¤ä¸´æ—¶æ ¹ç›®å½•ä¿¡æ¯
      this.tempRootInfo = this.searchRootConfigs.tempRoot;
      return [this.tempRootInfo.id];
    }
    
    // ä¼˜å…ˆä½¿ç”¨æ–°çš„å¤šé€‰å­—æ®µ
    if (this.searchRootConfigs.lastUsedRoots && this.searchRootConfigs.lastUsedRoots.length > 0) {
      const rootIds = [];
      for (const key of this.searchRootConfigs.lastUsedRoots) {
        const root = this.searchRootConfigs.roots[key];
        if (root) {
          rootIds.push(root.id);
        }
      }
      if (rootIds.length > 0) {
        return rootIds;
      }
    }
    
    // å…¼å®¹æ—§ç‰ˆå•é€‰é…ç½®
    const singleRoot = this.getCurrentSearchRoot();
    return [singleRoot];
  }
  
  /**
   * è·å–å½“å‰æ ¹ç›®å½•åç§°ï¼ˆæ”¯æŒå¤šä¸ªï¼‰
   * @param {Array} rootIds - æ ¹ç›®å½•IDæ•°ç»„
   * @param {Object} allRoots - æ‰€æœ‰æ ¹ç›®å½•é…ç½®
   * @returns {string} æ ¹ç›®å½•åç§°çš„å­—ç¬¦ä¸²è¡¨ç¤º
   */
  static getCurrentRootNames(rootIds, allRoots) {
    if (!rootIds || rootIds.length === 0) {
      return "æœªé€‰æ‹©";
    }
    
    const names = [];
    for (const rootId of rootIds) {
      // æ£€æŸ¥ä¸´æ—¶æ ¹ç›®å½•
      if (this.tempRootInfo && this.tempRootInfo.id === rootId) {
        names.push(`ğŸ“ ${this.tempRootInfo.name}`);
      } else {
        // æŸ¥æ‰¾é…ç½®ä¸­çš„æ ¹ç›®å½•
        for (const key in allRoots) {
          if (allRoots[key].id === rootId) {
            names.push(allRoots[key].name);
            break;
          }
        }
      }
    }
    
    return names.length > 0 ? names.join(", ") : "æœªçŸ¥";
  }
  
  /**
   * è·å–æ‰€æœ‰æœç´¢æ ¹ç›®å½•
   */
  static getAllSearchRoots() {
    this.initSearchConfig();
    return this.searchRootConfigs.roots;
  }
  
  /**
   * è®¾ç½®ä¸´æ—¶æ ¹ç›®å½•
   * @param {MNNote} note - è¦è®¾ä¸ºä¸´æ—¶æ ¹ç›®å½•çš„å¡ç‰‡
   */
  static setTempRoot(note) {
    try {
      this.initSearchConfig();
      
      // ä¿å­˜ä¸´æ—¶æ ¹ç›®å½•ä¿¡æ¯
      this.tempRootInfo = {
        id: note.noteId,
        name: note.noteTitle || "æ— æ ‡é¢˜",
        isTemp: true
      };
      
      // å°†ä¸´æ—¶æ ¹ç›®å½•ä¿¡æ¯ä¿å­˜åˆ°é…ç½®ä¸­ï¼Œä»¥ä¾¿ä¸‹æ¬¡æ‰“å¼€æ—¶ä»ç„¶æœ‰æ•ˆ
      this.searchRootConfigs.tempRoot = this.tempRootInfo;
      
      // æ¸…ç©ºæ­£å¼æ ¹ç›®å½•çš„é€‰æ‹©
      this.searchRootConfigs.lastUsedRoots = [];
      
      this.saveSearchConfig();
      
      MNUtil.showHUD(`ğŸ“ å·²è®¾ç½®ä¸´æ—¶æ ¹ç›®å½•ï¼š${this.tempRootInfo.name}`);
      return true;
    } catch (error) {
      MNUtil.log("è®¾ç½®ä¸´æ—¶æ ¹ç›®å½•å¤±è´¥: " + error.toString());
      MNUtil.showHUD("è®¾ç½®å¤±è´¥ï¼š" + error.message);
      return false;
    }
  }
  
  /**
   * æ¸…é™¤ä¸´æ—¶æ ¹ç›®å½•
   */
  static clearTempRoot() {
    this.initSearchConfig();
    
    if (this.tempRootInfo || this.searchRootConfigs.tempRoot) {
      this.tempRootInfo = null;
      this.searchRootConfigs.tempRoot = null;
      this.saveSearchConfig();
      MNUtil.log("å·²æ¸…é™¤ä¸´æ—¶æ ¹ç›®å½•");
    }
  }
  
  /**
   * æ·»åŠ æœç´¢æ ¹ç›®å½•
   * @param {string} noteId - å¡ç‰‡ ID æˆ– URL
   * @param {string} name - æ ¹ç›®å½•åç§°
   */
  static addSearchRoot(noteId, name) {
    try {
      this.initSearchConfig();
      
      // å¤„ç† URL æ ¼å¼çš„ noteId
      if (noteId.includes("marginnote")) {
        noteId = noteId.toNoteId();
      }
      
      // éªŒè¯å¡ç‰‡æ˜¯å¦å­˜åœ¨
      const note = MNNote.new(noteId);
      if (!note) {
        MNUtil.showHUD("å¡ç‰‡ä¸å­˜åœ¨");
        return false;
      }
      
      // ç”Ÿæˆå”¯ä¸€ key
      const key = "root_" + Date.now();
      
      // æ·»åŠ åˆ°é…ç½®
      this.searchRootConfigs.roots[key] = {
        id: noteId,
        name: name,
        isDefault: false,
        skipEmptyTitleByDefault: false
      };
      
      // æ·»åŠ åˆ°é¡ºåºæ•°ç»„æœ«å°¾
      if (!this.searchRootConfigs.rootsOrder) {
        this.searchRootConfigs.rootsOrder = Object.keys(this.searchRootConfigs.roots);
      }
      this.searchRootConfigs.rootsOrder.push(key);
      
      // ä¿å­˜é…ç½®
      this.saveSearchConfig();
      
      MNUtil.showHUD("âœ… å·²æ·»åŠ æ ¹ç›®å½•ï¼š" + name);
      return key; // è¿”å›æ–°æ·»åŠ çš„æ ¹ç›®å½• key
    } catch (error) {
      MNUtil.log("æ·»åŠ æœç´¢æ ¹ç›®å½•å¤±è´¥: " + error.toString());
      MNUtil.showHUD("æ·»åŠ å¤±è´¥ï¼š" + error.message);
      return false;
    }
  }
  
  /**
   * åˆ é™¤æœç´¢æ ¹ç›®å½•
   * @param {string} key - æ ¹ç›®å½•çš„é”®å
   * @returns {boolean} æ˜¯å¦æˆåŠŸ
   */
  static deleteSearchRoot(key) {
    try {
      this.initSearchConfig();
      
      // ä¸èƒ½åˆ é™¤é»˜è®¤æ ¹ç›®å½•
      if (key === "default") {
        MNUtil.showHUD("ä¸èƒ½åˆ é™¤é»˜è®¤æ ¹ç›®å½•");
        return false;
      }
      
      // åˆ é™¤æ ¹ç›®å½•
      if (this.searchRootConfigs.roots[key]) {
        delete this.searchRootConfigs.roots[key];
        
        // ä»é¡ºåºæ•°ç»„ä¸­ç§»é™¤
        if (this.searchRootConfigs.rootsOrder) {
          const index = this.searchRootConfigs.rootsOrder.indexOf(key);
          if (index > -1) {
            this.searchRootConfigs.rootsOrder.splice(index, 1);
          }
        }
        
        // å¦‚æœåˆ é™¤çš„æ˜¯æœ€åä½¿ç”¨çš„æ ¹ç›®å½•ï¼Œé‡ç½®ä¸ºé»˜è®¤
        if (this.searchRootConfigs.lastUsedRoot === key) {
          this.searchRootConfigs.lastUsedRoot = "default";
        }
        
        this.saveSearchConfig();
        return true;
      }
      
      return false;
    } catch (error) {
      MNUtil.log("åˆ é™¤æœç´¢æ ¹ç›®å½•å¤±è´¥: " + error.toString());
      return false;
    }
  }
  
  /**
   * ç¼–è¾‘æœç´¢æ ¹ç›®å½•
   * @param {string} key - æ ¹ç›®å½•çš„é”®å
   * @param {string} newName - æ–°åç§°
   * @param {string} newNoteId - æ–°çš„ç¬”è®°IDï¼ˆå¯é€‰ï¼‰
   * @returns {boolean} æ˜¯å¦æˆåŠŸ
   */
  static editSearchRoot(key, newName, newNoteId) {
    try {
      this.initSearchConfig();
      
      if (!this.searchRootConfigs.roots[key]) {
        MNUtil.showHUD("æ ¹ç›®å½•ä¸å­˜åœ¨");
        return false;
      }
      
      // æ›´æ–°åç§°
      if (newName) {
        this.searchRootConfigs.roots[key].name = newName;
      }
      
      // æ›´æ–°ç¬”è®°IDï¼ˆå¦‚æœæä¾›ï¼‰
      if (newNoteId) {
        // å¤„ç† URL æ ¼å¼
        if (newNoteId.includes("marginnote")) {
          newNoteId = newNoteId.toNoteId();
        }
        
        // éªŒè¯å¡ç‰‡æ˜¯å¦å­˜åœ¨
        const note = MNNote.new(newNoteId);
        if (!note) {
          MNUtil.showHUD("æ–°çš„å¡ç‰‡ä¸å­˜åœ¨");
          return false;
        }
        
        this.searchRootConfigs.roots[key].id = newNoteId;
      }
      
      this.saveSearchConfig();
      return true;
    } catch (error) {
      MNUtil.log("ç¼–è¾‘æœç´¢æ ¹ç›®å½•å¤±è´¥: " + error.toString());
      return false;
    }
  }
  
  /**
   * å¯¼å‡ºæœç´¢é…ç½®ï¼ˆä¿ç•™åŸæ–¹æ³•ä»¥å…¼å®¹ï¼‰
   * @returns {string|null} JSONå­—ç¬¦ä¸²ï¼Œå¤±è´¥è¿”å›null
   */
  static exportSearchConfig() {
    try {
      this.initSearchConfig();
      
      const config = {
        version: "1.0",
        exportDate: new Date().toISOString(),
        roots: this.searchRootConfigs.roots,
        rootsOrder: this.searchRootConfigs.rootsOrder,
        lastUsedRoot: this.searchRootConfigs.lastUsedRoot,
        settings: {
          includeClassification: this.searchRootConfigs.includeClassification,
          onlyClassification: this.searchRootConfigs.onlyClassification,
          ignorePrefix: this.searchRootConfigs.ignorePrefix,
          searchInKeywords: this.searchRootConfigs.searchInKeywords,
          skipEmptyTitle: this.searchRootConfigs.skipEmptyTitle
        }
      };

      const jsonStr = JSON.stringify(config, null, 2);
      MNUtil.copy(jsonStr);
      
      return jsonStr;
    } catch (error) {
      MNUtil.log("å¯¼å‡ºæœç´¢é…ç½®å¤±è´¥: " + error.toString());
      return null;
    }
  }

  /**
   * è·å–å®Œæ•´çš„æœç´¢é…ç½®ï¼ˆåŒ…æ‹¬åŒä¹‰è¯ã€æ’é™¤è¯ç»„ã€æ ¹ç›®å½•ç¾¤ç»„ï¼‰
   * @returns {Object} é…ç½®å¯¹è±¡
   */
  static getFullSearchConfig() {
    this.initSearchConfig();
    
    return {
      version: "3.0",  // å‡çº§ç‰ˆæœ¬å·ä»¥æ”¯æŒæ–°åŠŸèƒ½
      exportDate: new Date().toISOString(),
      exportFrom: "KnowledgeBaseTemplate",
      searchConfig: {
        roots: this.searchRootConfigs.roots,
        rootsOrder: this.searchRootConfigs.rootsOrder,
        lastUsedRoot: this.searchRootConfigs.lastUsedRoot,
        lastUsedRoots: this.searchRootConfigs.lastUsedRoots || [],  // æ–°å¢ï¼šæ”¯æŒå¤šé€‰æ ¹ç›®å½•
        
        // æ–°å¢ï¼šæ ¹ç›®å½•ç¾¤ç»„
        rootGroups: this.searchRootConfigs.rootGroups || {},
        lastUsedGroup: this.searchRootConfigs.lastUsedGroup || null,
        
        includeClassification: this.searchRootConfigs.includeClassification,
        onlyClassification: this.searchRootConfigs.onlyClassification,
        ignorePrefix: this.searchRootConfigs.ignorePrefix,
        searchInKeywords: this.searchRootConfigs.searchInKeywords,
        skipEmptyTitle: this.searchRootConfigs.skipEmptyTitle
      }
    };
  }

  /**
   * å¯¼å‡ºæœç´¢é…ç½®åˆ°æŒ‡å®šç›®æ ‡
   * @param {string} type - å¯¼å‡ºç±»å‹: "iCloud", "clipboard", "currentNote", "file"
   * @returns {Promise<boolean>} æ˜¯å¦æˆåŠŸ
   */
  static async exportSearchConfigTo(type) {
    try {
      const config = this.getFullSearchConfig();
      const jsonStr = JSON.stringify(config, null, 2);
      
      switch (type) {
        case "iCloud":
          // ä½¿ç”¨ iCloud åŒæ­¥
          const iCloudKey = "KnowledgeBaseTemplate_SearchConfig";
          // MNUtil.setByiCloud(iCloudKey, jsonStr);
          MNUtil.showHUD("âœ… å·²å¯¼å‡ºåˆ° iCloud");
          return true;
          
        case "clipboard":
          MNUtil.copy(jsonStr);
          MNUtil.showHUD("âœ… å·²å¯¼å‡ºåˆ°å‰ªè´´æ¿");
          return true;
          
        case "currentNote":
          const focusNote = MNNote.getFocusNote();
          if (!focusNote) {
            MNUtil.showHUD("âŒ è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç¬”è®°");
            return false;
          }
          
          MNUtil.undoGrouping(() => {
            focusNote.noteTitle = "KnowledgeBaseTemplate_æœç´¢é…ç½®";
            focusNote.excerptText = "```json\n" + jsonStr + "\n```";
            focusNote.excerptTextMarkdown = true;
          });
          MNUtil.showHUD("âœ… å·²å¯¼å‡ºåˆ°å½“å‰ç¬”è®°");
          return true;
          
        case "file":
          // å¯¼å‡ºåˆ°æ–‡ä»¶
          const dateStr = new Date().toISOString().replace(/:/g, '-').split('.')[0];
          const fileName = `KnowledgeBaseTemplate_SearchConfig_${dateStr}.json`;
          const documentsPath = NSSearchPathForDirectoriesInDomains(9, 1, true).firstObject; // NSDocumentDirectory
          
          if (documentsPath) {
            const filePath = documentsPath + "/" + fileName;
            NSString.stringWithString(jsonStr).writeToFileAtomicallyEncodingError(
              filePath, true, 4, null // NSUTF8StringEncoding = 4
            );
            
            // ä¿å­˜æ–‡ä»¶å¯¹è¯æ¡†
            MNUtil.saveFile(filePath, ["public.json"]);
            MNUtil.showHUD(`âœ… å·²å¯¼å‡ºåˆ°æ–‡ä»¶\n${fileName}`);
            return true;
          }
          MNUtil.showHUD("âŒ æ–‡ä»¶å¯¼å‡ºå¤±è´¥");
          return false;
          
        default:
          MNUtil.showHUD("âŒ ä¸æ”¯æŒçš„å¯¼å‡ºç±»å‹");
          return false;
      }
    } catch (error) {
      MNUtil.showHUD("âŒ å¯¼å‡ºå¤±è´¥ï¼š" + error.message);
      MNUtil.log("å¯¼å‡ºæœç´¢é…ç½®å¤±è´¥: " + error.toString());
      return false;
    }
  }
  
  /**
   * å¯¼å…¥æœç´¢é…ç½®ï¼ˆä¿ç•™åŸæ–¹æ³•ä»¥å…¼å®¹ï¼‰
   * @returns {Promise<boolean>} æ˜¯å¦æˆåŠŸ
   */
  static async importSearchConfig() {
    return this.importSearchConfigFrom("clipboard");
  }

  /**
   * ä»æŒ‡å®šæ¥æºå¯¼å…¥æœç´¢é…ç½®
   * @param {string} type - å¯¼å…¥ç±»å‹: "iCloud", "clipboard", "currentNote", "file"
   * @returns {Promise<boolean>} æ˜¯å¦æˆåŠŸ
   */
  static async importSearchConfigFrom(type) {
    try {
      let jsonStr = null;
      
      switch (type) {
        case "iCloud":
          // ä» iCloud å¯¼å…¥
          const iCloudKey = "KnowledgeBaseTemplate_SearchConfig";
          jsonStr = MNUtil.getByiCloud(iCloudKey);
          if (!jsonStr) {
            MNUtil.showHUD("âŒ iCloud ä¸­æ²¡æœ‰é…ç½®");
            return false;
          }
          break;
          
        case "clipboard":
          jsonStr = MNUtil.clipboardText;
          if (!jsonStr) {
            MNUtil.showHUD("âŒ å‰ªè´´æ¿ä¸ºç©º");
            return false;
          }
          break;
          
        case "currentNote":
          const focusNote = MNNote.getFocusNote();
          if (!focusNote) {
            MNUtil.showHUD("âŒ è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç¬”è®°");
            return false;
          }
          
          // ä»ç¬”è®°å†…å®¹ä¸­æå– JSON
          const excerptText = focusNote.excerptText || "";
          // å°è¯•æå– markdown ä»£ç å—ä¸­çš„ JSON
          const codeBlockMatch = excerptText.match(/```json\s*([\s\S]*?)\s*```/);
          if (codeBlockMatch) {
            jsonStr = codeBlockMatch[1];
          } else {
            // å°è¯•ç›´æ¥è§£æ
            jsonStr = excerptText;
          }
          break;
          
        case "file":
          // ä»æ–‡ä»¶å¯¼å…¥
          const filePath = MNUtil.openFile(["public.json"]);
          if (!filePath) {
            MNUtil.showHUD("âŒ æœªé€‰æ‹©æ–‡ä»¶");
            return false;
          }
          
          jsonStr = NSString.stringWithContentsOfFileEncodingError(filePath, 4, null); // NSUTF8StringEncoding = 4
          if (!jsonStr) {
            MNUtil.showHUD("âŒ æ— æ³•è¯»å–æ–‡ä»¶");
            return false;
          }
          break;
          
        default:
          MNUtil.showHUD("âŒ ä¸æ”¯æŒçš„å¯¼å…¥ç±»å‹");
          return false;
      }
      
      // è§£æ JSON
      let config;
      try {
        config = JSON.parse(jsonStr);
      } catch (e) {
        MNUtil.showHUD("âŒ å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„ JSON æ ¼å¼");
        return false;
      }
      
      // å¤„ç†æ–°ç‰ˆæœ¬æ ¼å¼ï¼ˆåŒ…å« searchConfigï¼‰
      let searchConfig;
      if (config.searchConfig) {
        // æ–°æ ¼å¼
        searchConfig = config.searchConfig;
      } else if (config.roots) {
        // æ—§æ ¼å¼
        searchConfig = {
          roots: config.roots,
          rootsOrder: config.rootsOrder,
          lastUsedRoot: config.lastUsedRoot,
          ...config.settings
        };
      } else {
        MNUtil.showHUD("âŒ é…ç½®æ ¼å¼æ— æ•ˆ");
        return false;
      }
      
      // è¯¢é—®å¯¼å…¥æ–¹å¼
      return new Promise((resolve) => {
        UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
          "å¯¼å…¥é…ç½®",
          "é€‰æ‹©å¯¼å…¥æ–¹å¼ï¼š",
          0,
          "å–æ¶ˆ",
          ["æ›¿æ¢ç°æœ‰é…ç½®", "åˆå¹¶é…ç½®"],
          (_, buttonIndex) => {
            if (buttonIndex === 0) {
              resolve(false);
              return;
            }
            
            this.initSearchConfig();
            
            if (buttonIndex === 1) {
              // æ›¿æ¢æ¨¡å¼
              if (searchConfig.roots) {
                this.searchRootConfigs.roots = searchConfig.roots;
                this.searchRootConfigs.rootsOrder = searchConfig.rootsOrder || Object.keys(searchConfig.roots);
                this.searchRootConfigs.lastUsedRoot = searchConfig.lastUsedRoot || "default";
                // æ–°å¢ï¼šæ”¯æŒå¤šé€‰æ ¹ç›®å½•å’Œæ ¹ç›®å½•ç¾¤ç»„
                this.searchRootConfigs.lastUsedRoots = searchConfig.lastUsedRoots || [];
                this.searchRootConfigs.rootGroups = searchConfig.rootGroups || {};
                this.searchRootConfigs.lastUsedGroup = searchConfig.lastUsedGroup || null;
              }
              
              // åº”ç”¨å…¶ä»–è®¾ç½®
              if (searchConfig.includeClassification !== undefined) {
                this.searchRootConfigs.includeClassification = searchConfig.includeClassification;
              }
              if (searchConfig.onlyClassification !== undefined) {
                this.searchRootConfigs.onlyClassification = searchConfig.onlyClassification;
              }
              if (searchConfig.ignorePrefix !== undefined) {
                this.searchRootConfigs.ignorePrefix = searchConfig.ignorePrefix;
              }
              if (searchConfig.searchInKeywords !== undefined) {
                this.searchRootConfigs.searchInKeywords = searchConfig.searchInKeywords;
              }
              if (searchConfig.skipEmptyTitle !== undefined) {
                this.searchRootConfigs.skipEmptyTitle = searchConfig.skipEmptyTitle;
              }
            } else if (buttonIndex === 2) {
              // åˆå¹¶æ¨¡å¼
              // åˆå¹¶æ ¹ç›®å½•
              if (searchConfig.roots) {
                Object.assign(this.searchRootConfigs.roots, searchConfig.roots);
                
                // åˆå¹¶é¡ºåºæ•°ç»„
                if (searchConfig.rootsOrder) {
                  const existingKeys = new Set(this.searchRootConfigs.rootsOrder || []);
                  for (const key of searchConfig.rootsOrder) {
                    if (!existingKeys.has(key) && this.searchRootConfigs.roots[key]) {
                      this.searchRootConfigs.rootsOrder.push(key);
                    }
                  }
                }
                
                // æ–°å¢ï¼šåˆå¹¶å¤šé€‰æ ¹ç›®å½•
                if (searchConfig.lastUsedRoots && searchConfig.lastUsedRoots.length > 0) {
                  // å¦‚æœå½“å‰æ²¡æœ‰è®¾ç½®ï¼Œç›´æ¥ä½¿ç”¨å¯¼å…¥çš„
                  if (!this.searchRootConfigs.lastUsedRoots || this.searchRootConfigs.lastUsedRoots.length === 0) {
                    this.searchRootConfigs.lastUsedRoots = searchConfig.lastUsedRoots;
                  }
                }
                
                // æ–°å¢ï¼šåˆå¹¶æ ¹ç›®å½•ç¾¤ç»„
                if (searchConfig.rootGroups) {
                  if (!this.searchRootConfigs.rootGroups) {
                    this.searchRootConfigs.rootGroups = {};
                  }
                  // åˆå¹¶ç¾¤ç»„ï¼Œé¿å…è¦†ç›–ç°æœ‰ç¾¤ç»„
                  for (const groupName in searchConfig.rootGroups) {
                    if (!this.searchRootConfigs.rootGroups[groupName]) {
                      this.searchRootConfigs.rootGroups[groupName] = searchConfig.rootGroups[groupName];
                    }
                  }
                }
              }
            }
            
            this.saveSearchConfig();
            MNUtil.showHUD("âœ… é…ç½®å¯¼å…¥æˆåŠŸ");
            resolve(true);
          }
        );
      });
    } catch (error) {
      MNUtil.log("å¯¼å…¥æœç´¢é…ç½®å¤±è´¥: " + error.toString());
      MNUtil.showHUD("âŒ å¯¼å…¥å¤±è´¥ï¼š" + error.message);
      return false;
    }
  }
  
  /**
   * æ˜¾ç¤ºå¯¼å‡ºé…ç½®é€‰æ‹©å¯¹è¯æ¡†
   * @returns {Promise<boolean>} æ˜¯å¦æˆåŠŸå¯¼å‡º
   */
  static async showExportConfigDialog() {
    return new Promise((resolve) => {
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        "å¯¼å‡ºæœç´¢é…ç½®",
        "é€‰æ‹©å¯¼å‡ºæ–¹å¼ï¼š",
        0,
        "å–æ¶ˆ",
        [
          "â˜ï¸ å¯¼å‡ºåˆ° iCloud",
          "ğŸ“‹ å¯¼å‡ºåˆ°å‰ªè´´æ¿",
          "ğŸ“ å¯¼å‡ºåˆ°å½“å‰ç¬”è®°",
          "ğŸ“ å¯¼å‡ºåˆ°æ–‡ä»¶"
        ],
        async (_, buttonIndex) => {
          if (buttonIndex === 0) {
            resolve(false);
            return;
          }
          
          const types = ["iCloud", "clipboard", "currentNote", "file"];
          const success = await this.exportSearchConfigTo(types[buttonIndex - 1]);
          resolve(success);
        }
      );
    });
  }

  /**
   * æ˜¾ç¤ºå¯¼å…¥é…ç½®é€‰æ‹©å¯¹è¯æ¡†
   * @returns {Promise<boolean>} æ˜¯å¦æˆåŠŸå¯¼å…¥
   */
  static async showImportConfigDialog() {
    return new Promise((resolve) => {
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        "å¯¼å…¥æœç´¢é…ç½®",
        "é€‰æ‹©å¯¼å…¥æ¥æºï¼š",
        0,
        "å–æ¶ˆ",
        [
          "â˜ï¸ ä» iCloud å¯¼å…¥",
          "ğŸ“‹ ä»å‰ªè´´æ¿å¯¼å…¥",
          "ğŸ“ ä»å½“å‰ç¬”è®°å¯¼å…¥",
          "ğŸ“ ä»æ–‡ä»¶å¯¼å…¥"
        ],
        async (_, buttonIndex) => {
          if (buttonIndex === 0) {
            resolve(false);
            return;
          }
          
          const types = ["iCloud", "clipboard", "currentNote", "file"];
          const success = await this.importSearchConfigFrom(types[buttonIndex - 1]);
          resolve(success);
        }
      );
    });
  }

  /**
   * ç®¡ç†æœç´¢æ ¹ç›®å½•ç•Œé¢
   * æä¾›æ ¹ç›®å½•çš„ç®¡ç†åŠŸèƒ½
   */
  static async manageSearchRootsUI() {
    try {
      const options = [
        "ğŸ“ ç®¡ç†æ ¹ç›®å½•åˆ—è¡¨",
        "ğŸ”„ è°ƒæ•´æ ¹ç›®å½•é¡ºåº",
        "â• æ·»åŠ å½“å‰å¡ç‰‡ä¸ºæ ¹ç›®å½•"
      ];
      
      const result = await MNUtil.userSelect(
        "ç®¡ç†æœç´¢æ ¹ç›®å½•",
        "é€‰æ‹©æ“ä½œï¼š",
        options
      );
      
      if (result === null || result === 0) {
        return false;
      }
      
      switch (result) {
        case 1: // ç®¡ç†æ ¹ç›®å½•åˆ—è¡¨
          await this.showRootManagementDialog();
          break;
          
        case 2: // è°ƒæ•´æ ¹ç›®å½•é¡ºåº
          await this.showRootOrderDialog();
          break;
          
        case 3: // æ·»åŠ å½“å‰å¡ç‰‡
          const focusNote = MNNote.getFocusNote();
          if (focusNote) {
            const name = focusNote.noteTitle || "æœªå‘½å";
            const key = "root_" + Date.now();
            this.addSearchRoot(key, name, focusNote.noteId);
            MNUtil.showHUD(`âœ… å·²æ·»åŠ æ ¹ç›®å½•ï¼š${name}`);
          } else {
            MNUtil.showHUD("âŒ è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¡ç‰‡");
          }
          break;
      }
      
      return true;
    } catch (error) {
      MNUtil.showHUD("âŒ æ“ä½œå¤±è´¥ï¼š" + error.message);
      return false;
    }
  }

  /**
   * ç»¼åˆæœç´¢é…ç½®ç®¡ç†ç•Œé¢ï¼ˆå·²åºŸå¼ƒï¼‰
   * æ­¤æ–¹æ³•å·²è¢«æ‹†åˆ†ä¸ºç‹¬ç«‹çš„é…ç½®åŠŸèƒ½ï¼Œä¸å†ä½¿ç”¨
   * @deprecated ä½¿ç”¨ showSearchSettingsDialogã€manageSearchRootsUI ç­‰ç‹¬ç«‹æ–¹æ³•
   */
  /*
  static async manageSearchConfig() {
    // æ­¤æ–¹æ³•å·²åºŸå¼ƒï¼ŒåŠŸèƒ½å·²æ‹†åˆ†ä¸ºç‹¬ç«‹çš„é…ç½®ç®¡ç†æ–¹æ³•
    MNUtil.showHUD("æ­¤åŠŸèƒ½å·²æ‹†åˆ†ä¸ºç‹¬ç«‹çš„é…ç½®ç®¡ç†æ–¹æ³•");
    return false;
  }
  */

  /**
   * æ˜¾ç¤ºæœç´¢è®¾ç½®å¯¹è¯æ¡†
   */
  static async showSearchSettingsDialog() {
    this.initSearchConfig();
    
    const settings = [
      `${this.searchRootConfigs.includeClassification ? "â˜‘ï¸" : "â˜ï¸"} æœç´¢å½’ç±»å¡ç‰‡`,
      `${this.searchRootConfigs.onlyClassification ? "â˜‘ï¸" : "â˜ï¸"} åªæœç´¢å½’ç±»å¡ç‰‡`,
      `${this.searchRootConfigs.ignorePrefix ? "â˜‘ï¸" : "â˜ï¸"} å¿½ç•¥å‰ç¼€æœç´¢`,
      `${this.searchRootConfigs.searchInKeywords ? "â˜‘ï¸" : "â˜ï¸"} æœç´¢å…³é”®è¯å­—æ®µ`,
      `${this.searchRootConfigs.skipEmptyTitle ? "â˜‘ï¸" : "â˜ï¸"} è·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡`
    ];
    
    const result = await MNUtil.userSelect(
      "æœç´¢è®¾ç½®",
      "ç‚¹å‡»åˆ‡æ¢è®¾ç½®çŠ¶æ€ï¼š",
      settings
    );
    
    if (result === null || result === 0) {
      return false;
    }
    
    switch (result) {
      case 1:
        this.searchRootConfigs.includeClassification = !this.searchRootConfigs.includeClassification;
        break;
      case 2:
        this.searchRootConfigs.onlyClassification = !this.searchRootConfigs.onlyClassification;
        break;
      case 3:
        this.searchRootConfigs.ignorePrefix = !this.searchRootConfigs.ignorePrefix;
        break;
      case 4:
        this.searchRootConfigs.searchInKeywords = !this.searchRootConfigs.searchInKeywords;
        break;
      case 5:
        this.searchRootConfigs.skipEmptyTitle = !this.searchRootConfigs.skipEmptyTitle;
        break;
    }
    
    this.saveSearchConfig();
    MNUtil.showHUD("âœ… è®¾ç½®å·²æ›´æ–°");
    
    // é‡æ–°æ˜¾ç¤ºè®¾ç½®å¯¹è¯æ¡†
    await this.showSearchSettingsDialog();
    return true;
  }

  /**
   * æ˜¾ç¤ºæ ¹ç›®å½•æ’åºå¯¹è¯æ¡†
   * @returns {Promise<boolean>} æ˜¯å¦ä¿®æ”¹äº†é¡ºåº
   */
  static async showRootOrderDialog() {
    try {
      this.initSearchConfig();
      
      // ç¡®ä¿æœ‰é¡ºåºæ•°ç»„
      if (!this.searchRootConfigs.rootsOrder) {
        this.searchRootConfigs.rootsOrder = Object.keys(this.searchRootConfigs.roots);
      }
      
      const roots = this.searchRootConfigs.roots;
      const currentOrder = this.searchRootConfigs.rootsOrder;
      const newOrder = [];
      const remainingKeys = new Set(currentOrder);
      
      MNUtil.showHUD("è¯·ä¾æ¬¡ç‚¹å‡»æ ¹ç›®å½•ï¼Œè®¾ç½®æ–°é¡ºåº");
      
      while (remainingKeys.size > 0) {
        const options = [];
        const keys = [];
        
        // æ„å»ºé€‰é¡¹åˆ—è¡¨
        for (const key of remainingKeys) {
          if (roots[key]) {
            options.push(roots[key].name);
            keys.push(key);
          }
        }
        
        if (options.length === 0) break;
        
        // æ˜¾ç¤ºé€‰æ‹©å¯¹è¯æ¡†
        const result = await new Promise((resolve) => {
          UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
            `è®¾ç½®é¡ºåº (${newOrder.length + 1}/${currentOrder.length})`,
            `å·²é€‰æ‹©ï¼š${newOrder.map(k => roots[k].name).join(" â†’ ")}\n\nè¯·é€‰æ‹©ä¸‹ä¸€ä¸ªï¼š`,
            0,
            "å®Œæˆ",
            options,
            (alert, buttonIndex) => {
              if (buttonIndex === 0) {
                resolve(null);
              } else {
                resolve(keys[buttonIndex - 1]);
              }
            }
          );
        });
        
        if (result === null) {
          // ç”¨æˆ·ç‚¹å‡»å®Œæˆï¼Œå°†å‰©ä½™çš„æŒ‰åŸé¡ºåºæ·»åŠ 
          for (const key of currentOrder) {
            if (remainingKeys.has(key)) {
              newOrder.push(key);
            }
          }
          break;
        }
        
        // æ·»åŠ é€‰ä¸­çš„é¡¹
        newOrder.push(result);
        remainingKeys.delete(result);
      }
      
      // ä¿å­˜æ–°é¡ºåº
      this.searchRootConfigs.rootsOrder = newOrder;
      this.saveSearchConfig();
      
      return true;
    } catch (error) {
      MNUtil.log("è°ƒæ•´æ ¹ç›®å½•é¡ºåºå¤±è´¥: " + error.toString());
      MNUtil.showHUD("è°ƒæ•´é¡ºåºå¤±è´¥ï¼š" + error.message);
      return false;
    }
  }
  
  /**
   * æ˜¾ç¤ºæ ¹ç›®å½•ç®¡ç†å¯¹è¯æ¡†
   * @returns {Promise<boolean>} æ˜¯å¦è¿›è¡Œäº†ä¿®æ”¹
   */
  static async showRootManagementDialog() {
    try {
      this.initSearchConfig();
      
      // è·å–æ‰€æœ‰æ ¹ç›®å½•
      const roots = this.searchRootConfigs.roots;
      const rootsOrder = this.searchRootConfigs.rootsOrder || Object.keys(roots);
      
      // æ„å»ºé€‰é¡¹åˆ—è¡¨
      const options = [];
      const keys = [];
      
      for (const key of rootsOrder) {
        if (roots[key]) {
          const root = roots[key];
          const prefix = root.isDefault ? "ğŸ“Œ " : "";
          const suffix = root.skipEmptyTitleByDefault ? " [è·³è¿‡ç©ºç™½]" : "";
          options.push(prefix + root.name + suffix);
          keys.push(key);
        }
      }
      
      if (options.length === 0) {
        MNUtil.showHUD("æ²¡æœ‰å¯ç®¡ç†çš„æ ¹ç›®å½•");
        return false;
      }
      
      // æ˜¾ç¤ºé€‰æ‹©å¯¹è¯æ¡†
      const selectedKey = await new Promise((resolve) => {
        UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
          "ç®¡ç†æ ¹ç›®å½•",
          "é€‰æ‹©è¦ç®¡ç†çš„æ ¹ç›®å½•ï¼š",
          0,
          "å–æ¶ˆ",
          options,
          (alert, buttonIndex) => {
            if (buttonIndex === 0) {
              resolve(null);
            } else {
              resolve(keys[buttonIndex - 1]);
            }
          }
        );
      });
      
      if (!selectedKey) return false;
      
      const selectedRoot = roots[selectedKey];
      
      // æ˜¾ç¤ºæ“ä½œé€‰é¡¹
      const action = await new Promise((resolve) => {
        const skipEmptyStatus = selectedRoot.skipEmptyTitleByDefault ? "âœ…" : "â˜";
        const buttons = [
          "ç¼–è¾‘åç§°", 
          "æ›´æ”¹å¡ç‰‡",
          `${skipEmptyStatus} é»˜è®¤è·³è¿‡ç©ºç™½æ ‡é¢˜`
        ];
        if (selectedKey !== "default") {
          buttons.push("åˆ é™¤");
        }
        
        UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
          selectedRoot.name,
          `ID: ${selectedRoot.id}\né€‰æ‹©æ“ä½œï¼š`,
          0,
          "å–æ¶ˆ",
          buttons,
          (alert, buttonIndex) => {
            if (buttonIndex === 0) {
              resolve(null);
            } else {
              resolve(buttons[buttonIndex - 1]);
            }
          }
        );
      });
      
      if (!action) return false;
      
      let modified = false;
      
      switch (action) {
        case "ç¼–è¾‘åç§°":
          const newName = await new Promise((resolve) => {
            UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
              "ç¼–è¾‘åç§°",
              `å½“å‰åç§°ï¼š${selectedRoot.name}\nè¯·è¾“å…¥æ–°åç§°ï¼š`,
              2, // è¾“å…¥æ¡†æ ·å¼
              "å–æ¶ˆ",
              ["ç¡®å®š"],
              (alertView, buttonIndex) => {
                if (buttonIndex === 1) {
                  resolve(alertView.textFieldAtIndex(0).text.trim());
                } else {
                  resolve(null);
                }
              }
            );
            // è®¾ç½®é»˜è®¤å€¼
            MNUtil.delay(0.01).then(() => {
              try {
                const currentAlert = UIAlertView.currentAlertView();
                if (currentAlert && currentAlert.textFieldAtIndex) {
                  const textField = currentAlert.textFieldAtIndex(0);
                  if (textField) textField.text = selectedRoot.name;
                }
              } catch (e) {}
            });
          });
          
          if (newName && newName !== selectedRoot.name) {
            modified = this.editSearchRoot(selectedKey, newName);
            if (modified) {
              MNUtil.showHUD("âœ… å·²æ›´æ–°åç§°");
            }
          }
          break;
          
        case "æ›´æ”¹å¡ç‰‡":
          const focusNote = MNNote.getFocusNote();
          if (!focusNote) {
            MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¡ç‰‡");
            break;
          }
          
          const confirmed = await MNUtil.confirm(
            "æ›´æ”¹æ ¹ç›®å½•å¡ç‰‡",
            `å°†æ ¹ç›®å½•"${selectedRoot.name}"æ›´æ”¹ä¸ºå½“å‰é€‰ä¸­çš„å¡ç‰‡ï¼Ÿ`
          );
          
          if (confirmed) {
            modified = this.editSearchRoot(selectedKey, null, focusNote.noteId);
            if (modified) {
              MNUtil.showHUD("âœ… å·²æ›´æ”¹å¡ç‰‡");
            }
          }
          break;
          
        case "åˆ é™¤":
          const deleteConfirmed = await MNUtil.confirm(
            "åˆ é™¤æ ¹ç›®å½•",
            `ç¡®å®šè¦åˆ é™¤"${selectedRoot.name}"å—ï¼Ÿ`
          );
          
          if (deleteConfirmed) {
            modified = this.deleteSearchRoot(selectedKey);
            if (modified) {
              MNUtil.showHUD("âœ… å·²åˆ é™¤");
            }
          }
          break;
          
        default:
          // å¤„ç†è·³è¿‡ç©ºç™½æ ‡é¢˜é€‰é¡¹
          if (action && action.includes("é»˜è®¤è·³è¿‡ç©ºç™½æ ‡é¢˜")) {
            // åˆ‡æ¢çŠ¶æ€
            selectedRoot.skipEmptyTitleByDefault = !selectedRoot.skipEmptyTitleByDefault;
            this.saveSearchConfig();
            MNUtil.showHUD(selectedRoot.skipEmptyTitleByDefault ? 
              "âœ… å·²å¯ç”¨é»˜è®¤è·³è¿‡ç©ºç™½æ ‡é¢˜" : 
              "â˜ å·²ç¦ç”¨é»˜è®¤è·³è¿‡ç©ºç™½æ ‡é¢˜"
            );
            modified = true;
          }
          break;
      }
      
      return modified;
    } catch (error) {
      MNUtil.log("ç®¡ç†æ ¹ç›®å½•å¤±è´¥: " + error.toString());
      MNUtil.showHUD("æ“ä½œå¤±è´¥ï¼š" + error.message);
      return false;
    }
  }
  
  /**
   * ä»å¡ç‰‡ä¸­æå–å…³é”®è¯å­—æ®µçš„å†…å®¹
   * @param {MNNote} note - è¦æå–å…³é”®è¯çš„å¡ç‰‡
   * @returns {string} å…³é”®è¯å†…å®¹ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²
   */
  static getKeywordsFromNote(note) {
    try {
      // é˜²å¾¡æ€§æ£€æŸ¥
      if (!note) {
        return "";
      }
      
      // ç¡®ä¿ MNComments å­˜åœ¨
      const comments = note.MNComments || [];

      for (const comment of comments) {
        // æ·»åŠ é˜²å¾¡æ€§æ£€æŸ¥ï¼šç¡®ä¿ comment å’Œ comment.type å­˜åœ¨
        if (!comment || !comment.type) {
          continue;
        }

        // æŸ¥æ‰¾ HtmlComment/HtmlNote ç±»å‹ä¸”ä»¥"å…³é”®è¯"å¼€å¤´çš„è¯„è®º
        if ((comment.type === "HtmlComment" || comment.type === "HtmlNote") && comment.text) {
          // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…"å…³é”®è¯ï¼š"æˆ–"å…³é”®è¯ï¼š "åçš„å†…å®¹
          const match = comment.text.match(/^å…³é”®è¯[:ï¼š]\s*(.*)$/);
          if (match) {
            // è¿”å›å…³é”®è¯å†…å®¹ï¼ˆå»é™¤é¦–å°¾ç©ºæ ¼ï¼‰
            return match[1].trim();
          }
        }
      }

      // æ²¡æœ‰æ‰¾åˆ°å…³é”®è¯å­—æ®µ
      return "";
    } catch (error) {
      MNLog.log({
        message: "getKeywordsFromNote é”™è¯¯",
        noteId: note?.noteId || "unknown",
        hasMNComments: !!note?.MNComments,
        commentsLength: note?.MNComments?.length || 0,
        errorMessage: error.message,
        errorStack: error.stack
      });
      return "";
    }
  }

  /**
   * è·å–æ‰€æœ‰åŒä¹‰è¯ç»„ï¼ˆä½¿ç”¨SynonymManagerï¼‰
   */
  static getSynonymGroups() {
    // ä½¿ç”¨SynonymManageræ¥è·å–åˆå¹¶åçš„åŒä¹‰è¯ç»„
    return SynonymManager.getSynonymGroups();
  }

  /**
   * æ™ºèƒ½è§£æåŒä¹‰è¯è¾“å…¥
   * æ”¯æŒå¤šç§åˆ†éš”ç¬¦ï¼Œä¼˜å…ˆçº§å¦‚ä¸‹ï¼š
   * 1. é€—å·åˆ†éš”ï¼ˆä¸­è‹±æ–‡ï¼‰
   * 2. åˆ†å·åˆ†éš”ï¼ˆä¸­è‹±æ–‡ï¼‰
   * 3. ä¸¤ä¸ªæˆ–æ›´å¤šè¿ç»­ç©ºæ ¼
   * 4. å•ç©ºæ ¼åˆ†éš”ï¼ˆä»…å½“æ²¡æœ‰å…¶ä»–åˆ†éš”ç¬¦æ—¶ï¼‰
   * @param {string} input - ç”¨æˆ·è¾“å…¥çš„è¯æ±‡å­—ç¬¦ä¸²
   * @returns {Array<string>} è§£æåçš„è¯æ±‡æ•°ç»„
   */
  static parseWords(input) {
    // ç§»é™¤é¦–å°¾ç©ºæ ¼
    input = input.trim();
    
    // ä¼˜å…ˆçº§1ï¼šé€—å·åˆ†å‰²
    if (input.includes(',') || input.includes('ï¼Œ')) {
      return input.split(/[,ï¼Œ]/).map(w => w.trim()).filter(w => w);
    }
    
    // ä¼˜å…ˆçº§2ï¼šåˆ†å·åˆ†å‰²
    if (input.includes(';') || input.includes('ï¼›')) {
      return input.split(/[;ï¼›]/).map(w => w.trim()).filter(w => w);
    }
    
    // ä¼˜å…ˆçº§3ï¼šä¸¤ä¸ªæˆ–æ›´å¤šè¿ç»­ç©ºæ ¼
    if (/\s{2,}/.test(input)) {
      return input.split(/\s{2,}/).map(w => w.trim()).filter(w => w);
    }
    
    // ä¼˜å…ˆçº§4ï¼šå•ç©ºæ ¼åˆ†å‰²
    return input.split(/\s+/).map(w => w.trim()).filter(w => w);
  }

  /**
   * è½¬ä¹‰æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦
   * @param {string} str - è¦è½¬ä¹‰çš„å­—ç¬¦ä¸²
   * @returns {string} è½¬ä¹‰åçš„å­—ç¬¦ä¸²
   */
  static escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * åˆ¤æ–­ç©ºæ ¼å¤„ç†è§„åˆ™
   * @param {string} from - åŸå§‹è¯
   * @param {string} to - æ›¿æ¢è¯
   * @returns {string} ç©ºæ ¼å¤„ç†è§„åˆ™ï¼š'removeSpace' | 'addSpace' | 'direct'
   */
  static getSpacingRule(from, to) {
    const isFromSymbol = /^[^\u4e00-\u9fa5a-zA-Z]+$/.test(from);  // éä¸­è‹±æ–‡
    const isToSymbol = /^[^\u4e00-\u9fa5a-zA-Z]+$/.test(to);
    const isFromChinese = /[\u4e00-\u9fa5]/.test(from);
    const isToChinese = /[\u4e00-\u9fa5]/.test(to);
    const isFromEnglish = /[a-zA-Z]/.test(from);
    const isToEnglish = /[a-zA-Z]/.test(to);
    
    // ç¬¦å·å’Œä¸­æ–‡ä¹‹é—´çš„è½¬æ¢
    if (isFromSymbol && isToChinese) return 'removeSpace';
    if (isFromChinese && isToSymbol) return 'keepOrAdd';
    
    // ä¸­è‹±æ–‡ä¹‹é—´çš„è½¬æ¢
    if (isFromChinese && isToEnglish) return 'addSpace';
    if (isFromEnglish && isToChinese) return 'removeSpace';
    
    return 'direct';
  }

  /**
   * ç¼–è¯‘æ¨¡å¼ä¸ºæ­£åˆ™è¡¨è¾¾å¼
   * @param {string} pattern - åŒ…å«{{}}å ä½ç¬¦çš„æ¨¡å¼
   * @returns {Object} è¿”å› {regex: RegExp, captureCount: number}
   */
  static compilePattern(pattern) {
    try {
      // ç¼“å­˜ç¼–è¯‘ç»“æœ
      if (!this._patternCache) {
        this._patternCache = new Map();
      }
      
      if (this._patternCache.has(pattern)) {
        return this._patternCache.get(pattern);
      }
      
      // è½¬ä¹‰æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦ï¼Œä½†ä¿ç•™{{}}
      let escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, (match) => {
        // ä¸è½¬ä¹‰{{å’Œ}}
        if (match === '{' || match === '}') {
          return match;
        }
        return '\\' + match;
      });
      
      // å°†{{}}æ›¿æ¢ä¸ºéè´ªå©ªæ•è·ç»„
      let captureCount = 0;
      const regexPattern = escapedPattern.replace(/\{\{\}\}/g, () => {
        captureCount++;
        return '(.*?)';  // éè´ªå©ªåŒ¹é…ä»»æ„å†…å®¹
      });
      
      const regex = new RegExp('^' + regexPattern + '$', 'i');  // ä¸åŒºåˆ†å¤§å°å†™
      const result = { regex, captureCount };
      
      // ç¼“å­˜ç»“æœ
      this._patternCache.set(pattern, result);
      
      return result;
    } catch (error) {
      MNUtil.log(`æ¨¡å¼ç¼–è¯‘å¤±è´¥: ${pattern}, é”™è¯¯: ${error.message}`);
      return null;
    }
  }

  /**
   * ä½¿ç”¨æ¨¡å¼åŒ¹é…æ–‡æœ¬å¹¶æå–æ•è·ç»„
   * @param {string} text - è¦åŒ¹é…çš„æ–‡æœ¬
   * @param {string} pattern - æ¨¡å¼å­—ç¬¦ä¸²
   * @returns {Object|null} è¿”å› {matches: boolean, captures: Array<string>} æˆ– null
   */
  static matchPattern(text, pattern) {
    const compiled = this.compilePattern(pattern);
    if (!compiled) return null;
    
    const match = text.match(compiled.regex);
    if (!match) return null;
    
    return {
      matches: true,
      captures: match.slice(1)  // æ’é™¤å®Œæ•´åŒ¹é…ï¼Œåªè¦æ•è·ç»„
    };
  }

  /**
   * ç”Ÿæˆæ¨¡å¼åŒ¹é…çš„å˜ä½“
   * @param {string} keyword - åŸå§‹å…³é”®è¯
   * @param {Object} group - åŒä¹‰è¯ç»„
   * @returns {Array<string>} ç”Ÿæˆçš„å˜ä½“æ•°ç»„
   */
  static generatePatternVariants(keyword, group) {
    const variants = new Set();
    
    if (!group.patternMode || !group.words) return Array.from(variants);
    
    // å°è¯•åŒ¹é…keywordåˆ°ç»„å†…çš„æ¯ä¸ªæ¨¡å¼
    for (const pattern of group.words) {
      if (!pattern.includes('{{}}')) continue;  // è·³è¿‡æ²¡æœ‰å ä½ç¬¦çš„è¯
      
      const matchResult = this.matchPattern(keyword, pattern);
      if (matchResult && matchResult.matches) {
        // åŒ¹é…æˆåŠŸï¼Œç”Ÿæˆå…¶ä»–æ¨¡å¼çš„å˜ä½“
        const captures = matchResult.captures;
        
        for (const targetPattern of group.words) {
          if (targetPattern === pattern) continue;  // è·³è¿‡è‡ªå·±
          
          let variant = targetPattern;
          
          if (targetPattern.includes('{{}}')) {
            // ç›®æ ‡ä¹Ÿæ˜¯æ¨¡å¼ï¼Œæ›¿æ¢å ä½ç¬¦
            let captureIndex = 0;
            variant = targetPattern.replace(/\{\{\}\}/g, () => {
              return captures[captureIndex++] || '';
            });
          }
          // å¦‚æœç›®æ ‡ä¸æ˜¯æ¨¡å¼ï¼ˆæ²¡æœ‰å ä½ç¬¦ï¼‰ï¼Œç›´æ¥ä½¿ç”¨
          
          variants.add(variant);
        }
      }
    }
    
    return Array.from(variants);
  }

  /**
   * ç”Ÿæˆå±€éƒ¨æ›¿æ¢å˜ä½“
   * @param {string} keyword - åŸå§‹å…³é”®è¯
   * @param {Object} group - åŒä¹‰è¯ç»„
   * @returns {Array<string>} ç”Ÿæˆçš„å˜ä½“æ•°ç»„
   */
  static generatePartialReplacements(keyword, group) {
    const variants = new Set();
    
    if (!group.partialReplacement || !group.words) return Array.from(variants);
    
    // å¯¹ç»„å†…æ¯ä¸ªè¯è¿›è¡Œæ£€æŸ¥
    for (const word of group.words) {
      if (keyword.includes(word)) {
        // ç”Ÿæˆæ‰€æœ‰å…¶ä»–è¯çš„æ›¿æ¢å˜ä½“
        for (const replacement of group.words) {
          if (replacement === word) continue;  // è·³è¿‡è‡ªå·±
          
          let variant = keyword;
          const spacingRule = this.getSpacingRule(word, replacement);
          
          switch (spacingRule) {
            case 'removeSpace':
              // ç§»é™¤å‰åç©ºæ ¼
              const regex = new RegExp(`\\s*${this.escapeRegex(word)}\\s*`, 'g');
              variant = variant.replace(regex, replacement);
              break;
              
            case 'addSpace':
              // æ·»åŠ ç©ºæ ¼
              variant = variant.replace(word, ` ${replacement} `);
              variant = variant.replace(/\s+/g, ' ').trim();
              break;
              
            case 'keepOrAdd':
              // å¦‚æœåŸæœ¬æœ‰ç©ºæ ¼åˆ™ä¿æŒï¼Œæ²¡æœ‰åˆ™æ·»åŠ 
              if (keyword.includes(` ${word} `)) {
                variant = variant.replace(` ${word} `, ` ${replacement} `);
              } else if (keyword.includes(`${word} `)) {
                variant = variant.replace(`${word} `, `${replacement} `);
              } else if (keyword.includes(` ${word}`)) {
                variant = variant.replace(` ${word}`, ` ${replacement}`);
              } else {
                variant = variant.replace(word, ` ${replacement} `);
                variant = variant.replace(/\s+/g, ' ').trim();
              }
              break;
              
            default:
              // å…¨å±€æ›¿æ¢æ‰€æœ‰å‡ºç°ï¼ˆé‡è¦ï¼šç¡®ä¿ ||x|| ä¸­çš„ä¸¤ä¸ª || éƒ½è¢«æ›¿æ¢ï¼‰
              const escapedWord = this.escapeRegex(word);
              const globalRegex = new RegExp(escapedWord, 'g');
              variant = variant.replace(globalRegex, replacement);
          }
          
          if (variant !== keyword) {
            variants.add(variant);
          }
        }
      }
    }
    
    return Array.from(variants);
  }

  /**
   * æ‰©å±•å…³é”®è¯ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰
   * æ ¹æ®åŒä¹‰è¯ç»„æ‰©å±•è¾“å…¥çš„å…³é”®è¯
   * @param {Array<string>} keywords - åŸå§‹å…³é”®è¯æ•°ç»„
   * @returns {Array<string>} æ‰©å±•åçš„å…³é”®è¯æ•°ç»„
   */
  /**
   * æ‰©å±•å…³é”®è¯å¹¶è¿”å›åˆ†ç»„ç»“æ„ï¼ˆç”¨äº"ä¸"é€»è¾‘æœç´¢ï¼‰
   * @param {Array<string>} keywords - åŸå§‹å…³é”®è¯æ•°ç»„
   * @returns {Array<Array<string>>} åˆ†ç»„çš„å…³é”®è¯æ•°ç»„ï¼Œæ¯ç»„åŒ…å«åŸå§‹è¯åŠå…¶åŒä¹‰è¯
   */
  static expandKeywordsWithSynonymsGrouped(keywords, title = null) {
    const synonymGroups = this.getSynonymGroups();
    const keywordGroups = [];
    
    // æ€§èƒ½ç›‘æ§
    const startTime = Date.now();
    let contextCheckCount = 0;
    let skipCount = 0;
    
    for (const keyword of keywords) {
      const keywordGroup = new Set();
      // å…ˆæ·»åŠ åŸå§‹å…³é”®è¯
      keywordGroup.add(keyword);
      
      // æŸ¥æ‰¾åŒ…å«è¯¥å…³é”®è¯çš„åŒä¹‰è¯ç»„
      for (const group of synonymGroups) {
        if (!group.enabled) continue;
        
        // æ£€æŸ¥ä¸Šä¸‹æ–‡è§¦å‘æ¡ä»¶
        if (group.contextTriggers && group.contextTriggers.length > 0 && title) {
          contextCheckCount++;
          // æœ‰è§¦å‘è¯é…ç½®ï¼Œéœ€è¦æ£€æŸ¥æ ‡é¢˜
          const matchesTrigger = this.checkContextTriggers(title, group.contextTriggers, group.contextMode);
          if (!matchesTrigger) {
            skipCount++;
            continue;  // ä¸æ»¡è¶³è§¦å‘æ¡ä»¶ï¼Œè·³è¿‡æ­¤ç»„
          }
        }
        
        // æ ¹æ® caseSensitive å­—æ®µå†³å®šåŒ¹é…æ–¹å¼
        const caseSensitive = group.caseSensitive || false;
        
        // 1. å®Œæ•´è¯åŒ¹é…ï¼ˆæ”¯æŒå¤§å°å†™æ•æ„Ÿï¼‰
        const foundInGroup = group.words.some(word => {
          if (caseSensitive) {
            return word === keyword;  // å¤§å°å†™æ•æ„ŸåŒ¹é…
          } else {
            return word.toLowerCase() === keyword.toLowerCase();  // å¤§å°å†™ä¸æ•æ„ŸåŒ¹é…
          }
        });
        
        if (foundInGroup) {
          // æ·»åŠ ç»„å†…æ‰€æœ‰è¯
          group.words.forEach(word => keywordGroup.add(word));
        }
        
        // 2. å±€éƒ¨æ›¿æ¢ï¼ˆæ–°åŠŸèƒ½ï¼‰
        if (group.partialReplacement) {
          const partialVariants = this.generatePartialReplacements(keyword, group);
          partialVariants.forEach(variant => keywordGroup.add(variant));
        }
        
        // 3. æ¨¡å¼åŒ¹é…ï¼ˆæ–°åŠŸèƒ½ï¼‰
        if (group.patternMode) {
          const patternVariants = this.generatePatternVariants(keyword, group);
          patternVariants.forEach(variant => keywordGroup.add(variant));
        }
      }
      
      keywordGroups.push(Array.from(keywordGroup));
    }
    
    // è®°å½•æ—¥å¿—
    const totalExpanded = keywordGroups.reduce((sum, group) => sum + group.length, 0);
    if (totalExpanded > keywords.length) {
      const details = keywordGroups.map((g, i) => {
        if (g.length > 3) {
          return `  ${keywords[i]} â†’ [${g.slice(0, 3).join(", ")}...å…±${g.length}ä¸ª]`;
        } else {
          return `  ${keywords[i]} â†’ [${g.join(", ")}]`;
        }
      }).join("\n");
      // MNUtil.log(`å…³é”®è¯æ‰©å±•è¯¦æƒ…ï¼š\n${details}`);
    }
    
    // æ€§èƒ½ç›‘æ§ï¼šè®°å½•ç»Ÿè®¡ä¿¡æ¯
    // const duration = Date.now() - startTime;
    // if (duration > 10 || contextCheckCount > 0) { // è¶…è¿‡10msæˆ–æœ‰ä¸Šä¸‹æ–‡æ£€æŸ¥æ—¶è®°å½•
    //   MNUtil.log(`ğŸ“Š å…³é”®è¯æ‰©å±•æ€§èƒ½ç»Ÿè®¡ï¼šè€—æ—¶${duration}ms å…³é”®è¯${keywords.length}ä¸ª åŒä¹‰è¯ç»„${synonymGroups.length}ä¸ª ä¸Šä¸‹æ–‡æ£€æŸ¥${contextCheckCount}æ¬¡ è·³è¿‡${skipCount}ä¸ªç»„${title ? ` æ ‡é¢˜="${title.substring(0, 20)}..."` : ''}`);
    // }
    
    return keywordGroups;
  }

  static expandKeywordsWithSynonyms(keywords, title = null) {
    const synonymGroups = this.getSynonymGroups();
    const expandedKeywords = new Set();
    
    for (const keyword of keywords) {
      // å…ˆæ·»åŠ åŸå§‹å…³é”®è¯
      expandedKeywords.add(keyword);
      
      // æŸ¥æ‰¾åŒ…å«è¯¥å…³é”®è¯çš„åŒä¹‰è¯ç»„
      for (const group of synonymGroups) {
        if (!group.enabled) continue;
        
        // æ£€æŸ¥ä¸Šä¸‹æ–‡è§¦å‘æ¡ä»¶
        if (group.contextTriggers && group.contextTriggers.length > 0 && title) {
          // æœ‰è§¦å‘è¯é…ç½®ï¼Œéœ€è¦æ£€æŸ¥æ ‡é¢˜
          const matchesTrigger = this.checkContextTriggers(title, group.contextTriggers, group.contextMode);
          if (!matchesTrigger) {
            continue;  // ä¸æ»¡è¶³è§¦å‘æ¡ä»¶ï¼Œè·³è¿‡æ­¤ç»„
          }
        }
        
        // æ ¹æ® caseSensitive å­—æ®µå†³å®šåŒ¹é…æ–¹å¼
        const caseSensitive = group.caseSensitive || false;
        
        // æ£€æŸ¥å…³é”®è¯æ˜¯å¦åœ¨ç»„å†…
        const foundInGroup = group.words.some(word => {
          if (caseSensitive) {
            return word === keyword;  // å¤§å°å†™æ•æ„ŸåŒ¹é…
          } else {
            return word.toLowerCase() === keyword.toLowerCase();  // å¤§å°å†™ä¸æ•æ„ŸåŒ¹é…
          }
        });
        
        if (foundInGroup) {
          // æ·»åŠ ç»„å†…æ‰€æœ‰è¯
          group.words.forEach(word => expandedKeywords.add(word));
        }

        // å±€éƒ¨æ›¿æ¢ï¼ˆæ”¯æŒ ||x|| â†’ â€–xâ€–ï¼‰
        if (group.partialReplacement) {
          const partialVariants = this.generatePartialReplacements(keyword, group);
          partialVariants.forEach(variant => expandedKeywords.add(variant));
        }

        // æ£€æŸ¥æ¨¡å¼åŒ¹é…
        if (group.patternMode) {
          const patternVariants = this.generatePatternVariants(keyword, group);
          patternVariants.forEach(variant => expandedKeywords.add(variant));
        }
      }
    }
    
    const result = Array.from(expandedKeywords);
    
    // å¦‚æœæ‰©å±•äº†å…³é”®è¯ï¼Œè®°å½•æ—¥å¿—
    // if (result.length > keywords.length) {
      // MNUtil.log(`å…³é”®è¯æ‰©å±•ï¼š${keywords.join(", ")} â†’ ${result.join(", ")}`);
    // }
    
    return result;
  }
  
  /**
   * æ£€æŸ¥æ ‡é¢˜æ˜¯å¦åŒ¹é…è§¦å‘è¯
   * @param {string} title - è¦æ£€æŸ¥çš„æ ‡é¢˜
   * @param {Array<string>} triggers - è§¦å‘è¯æ•°ç»„
   * @param {string} mode - åŒ¹é…æ¨¡å¼ï¼š"any" æˆ– "all"
   * @returns {boolean} æ˜¯å¦åŒ¹é…
   */
  static checkContextTriggers(title, triggers, mode = "any") {
    // å¿«é€Ÿè·³è¿‡ï¼šæ— è§¦å‘è¯æˆ–ç©ºæ ‡é¢˜ç›´æ¥è¿”å› false
    if (!title || !triggers || triggers.length === 0) return false;
    
    // æ€§èƒ½ç›‘æ§ï¼ˆä»…åœ¨è°ƒè¯•æ¨¡å¼ä¸‹ï¼‰
    const startTime = this.isDebugMode ? Date.now() : null;
    
    // æ ‡é¢˜æ ‡å‡†åŒ–ï¼ˆä¿æŒåŸæ ·ï¼Œå› ä¸ºè§¦å‘è¯æ˜¯å¤§å°å†™æ•æ„Ÿçš„ï¼‰
    const normalizedTitle = title;
    
    let result = false;
    if (mode === "all") {
      // å¿…é¡»åŒ…å«æ‰€æœ‰è§¦å‘è¯ - ä½¿ç”¨çŸ­è·¯è¯„ä¼°ä¼˜åŒ–
      result = triggers.every(trigger => normalizedTitle.includes(trigger));
    } else {
      // é»˜è®¤ "any" æ¨¡å¼ï¼šåŒ…å«ä»»æ„è§¦å‘è¯å³å¯ - ä½¿ç”¨çŸ­è·¯è¯„ä¼°ä¼˜åŒ–
      result = triggers.some(trigger => normalizedTitle.includes(trigger));
    }
    
    // æ€§èƒ½ç›‘æ§ï¼šè®°å½•è¶…è¿‡é˜ˆå€¼çš„è°ƒç”¨
    if (startTime) {
      const duration = Date.now() - startTime;
      if (duration > 5) { // è¶…è¿‡5msè®°å½•
        MNUtil.log(`âš ï¸ ä¸Šä¸‹æ–‡æ£€æŸ¥è€—æ—¶ ${duration}ms: æ ‡é¢˜="${title.substring(0, 30)}..." è§¦å‘è¯=${triggers.length}ä¸ª`);
      }
    }
    
    return result;
  }

  /**
   * è·å–æ‰€æœ‰æ’é™¤è¯ç»„
   */
  static getExclusionGroups() {
    // ä½¿ç”¨ExclusionManageræ¥è·å–åˆå¹¶åçš„æ’é™¤è¯ç»„
    return ExclusionManager.getExclusionGroups();
  }

  /**
   * æ ¹æ®å…³é”®è¯è·å–æ¿€æ´»çš„æ’é™¤è¯åˆ—è¡¨å’Œè¯¦ç»†ä¿¡æ¯
   * @param {Array<string>} keywords - å…³é”®è¯æ•°ç»„
   * @returns {Object} åŒ…å«æ’é™¤è¯åˆ—è¡¨å’Œè¯¦ç»†ä¿¡æ¯çš„å¯¹è±¡
   */
  static getActiveExclusions(keywords) {
    const exclusions = new Set();
    const activeTriggers = new Set();
    const activeGroups = [];
    const groups = this.getExclusionGroups();

    for (const keyword of keywords) {
      for (const group of groups) {
        // æ£€æŸ¥æ˜¯å¦åŒ¹é…è§¦å‘è¯ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
        const matchedTrigger = group.triggerWords.find(trigger =>
          trigger.toLowerCase() === keyword.toLowerCase()
        );

        if (matchedTrigger) {
          // è®°å½•æ¿€æ´»çš„è§¦å‘è¯
          activeTriggers.add(matchedTrigger);

          // æ·»åŠ æ‰€æœ‰æ’é™¤è¯
          group.excludeWords.forEach(word => exclusions.add(word));

          // ä½¿ç”¨è§¦å‘è¯ç¬¬ä¸€ä¸ªä½œä¸ºæ ‡è¯†ï¼Œé¿å…é‡å¤
          const groupKey = group.triggerWords[0];
          if (!activeGroups.find(g => g.triggerWords[0] === groupKey)) {
            activeGroups.push({
              triggerWords: group.triggerWords,
              excludeWords: group.excludeWords
            });
          }

          MNUtil.log(`è§¦å‘æ’é™¤è¯ç»„ [${group.triggerWords.join(", ")}]: ${keyword} â†’ æ’é™¤ [${group.excludeWords.join(", ")}]`);
        }
      }
    }

    return {
      excludeWords: Array.from(exclusions),
      triggerWords: Array.from(activeTriggers),
      groups: activeGroups
    };
  }

  /**
   * å¯¼å‡ºåŒä¹‰è¯ç»„é…ç½®
   * @returns {string|null} JSON å­—ç¬¦ä¸²æˆ– null
   */
  static exportSynonymGroups() {
    try {
      this.initSearchConfig();
      const config = {
        version: "1.0",
        exportDate: new Date().toISOString(),
        synonymGroups: this.getSynonymGroups(),
        searchRootConfigs: {
          includeClassification: this.searchRootConfigs.includeClassification,
          ignorePrefix: this.searchRootConfigs.ignorePrefix,
          searchInKeywords: this.searchRootConfigs.searchInKeywords,
          skipEmptyTitle: this.searchRootConfigs.skipEmptyTitle
        }
      };
      
      const jsonStr = JSON.stringify(config, null, 2);
      
      // å¤åˆ¶åˆ°å‰ªè´´æ¿
      MNUtil.copy(jsonStr);
      
      // ä¿å­˜åˆ°æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
      const fileName = `synonym_groups_${Date.now()}.json`;
      const documentsPath = NSFileManager.defaultManager().documentsPath;
      if (documentsPath) {
        const filePath = documentsPath + "/" + fileName;
        try {
          NSString.stringWithString(jsonStr).writeToFileAtomicallyEncodingError(
            filePath, true, 4, null // NSUTF8StringEncoding = 4
          );
          MNUtil.showHUD(`âœ… å·²å¯¼å‡ºé…ç½®\nğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿\nğŸ“ æ–‡ä»¶ï¼š${fileName}`);
        } catch (fileError) {
          // æ–‡ä»¶ä¿å­˜å¤±è´¥ï¼Œä½†å‰ªè´´æ¿æˆåŠŸ
          MNUtil.showHUD(`âœ… å·²å¯¼å‡ºé…ç½®\nğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿`);
        }
      } else {
        MNUtil.showHUD(`âœ… å·²å¯¼å‡ºé…ç½®\nğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿`);
      }
      
      return jsonStr;
    } catch (error) {
      MNUtil.showHUD("âŒ å¯¼å‡ºå¤±è´¥ï¼š" + error.message);
      MNUtil.log("å¯¼å‡ºåŒä¹‰è¯ç»„å¤±è´¥: " + error.toString());
      return null;
    }
  }

  /**
   * æ ¼å¼åŒ– JSON ä¸º Markdown ä»£ç å—
   * @param {string} jsonStr - JSON å­—ç¬¦ä¸²
   * @returns {string} æ ¼å¼åŒ–åçš„ Markdown ä»£ç å—
   */
  static formatJsonAsCodeBlock(jsonStr) {
    return `\`\`\`json\n${jsonStr}\n\`\`\``;
  }

  /**
   * ä» Markdown ä»£ç å—ä¸­æå– JSON
   * @param {string} text - åŒ…å«ä»£ç å—çš„æ–‡æœ¬
   * @returns {string|null} æå–çš„ JSON å­—ç¬¦ä¸²ï¼Œå¤±è´¥è¿”å› null
   */
  static extractJsonFromCodeBlock(text) {
    // å°è¯•æå– ```json ... ``` æ ¼å¼çš„å†…å®¹
    const codeBlockMatch = text.match(/```(?:json)?\s*\n?([\s\S]*?)\n?```/);
    if (codeBlockMatch) {
      return codeBlockMatch[1].trim();
    }
    
    // å¦‚æœæ²¡æœ‰ä»£ç å—æ ¼å¼ï¼Œç›´æ¥è¿”å›åŸæ–‡æœ¬ï¼ˆå…¼å®¹æ—§æ ¼å¼ï¼‰
    return text;
  }

  /**
   * åœ¨ç¬”è®°ä¸­æŸ¥æ‰¾åŒä¹‰è¯é…ç½®è¯„è®º
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @returns {Object|null} è¿”å› {index: è¯„è®ºç´¢å¼•, comment: è¯„è®ºå¯¹è±¡} æˆ– null
   */
  static findSynonymConfigComment(note) {
    if (!note || !note.comments) return null;
    
    for (let i = 0; i < note.comments.length; i++) {
      const comment = note.comments[i];
      if (comment.type === "textComment" && comment.text.includes('"synonymGroups"')) {
        return {
          index: i,
          comment: comment
        };
      }
    }
    return null;
  }


  /**
   * æœç´¢ç¬”è®°ä¸»å‡½æ•°ï¼ˆæ”¯æŒå¤šæ ¹ç›®å½•ï¼‰
   * @param {Array<string>} keywords - å…³é”®è¯æ•°ç»„
   * @param {string|Array<string>} rootNoteIds - æ ¹ç›®å½• IDï¼ˆå•ä¸ªæˆ–å¤šä¸ªï¼‰
   * @param {Set|null} selectedTypes - é€‰ä¸­çš„ç±»å‹é›†åˆï¼Œnull è¡¨ç¤ºå…¨é€‰
   */
  static async searchNotesInDescendants(keywords, rootNoteIds, selectedTypes = null) {
    try {
      // ç¡®ä¿ rootNoteIds æ˜¯æ•°ç»„
      if (!Array.isArray(rootNoteIds)) {
        rootNoteIds = rootNoteIds ? [rootNoteIds] : [];
      }
      
      if (rootNoteIds.length === 0) {
        MNUtil.showHUD("è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªæ ¹ç›®å½•");
        return [];
      }
      
      // è·å–æ­£åˆ™æœç´¢é…ç½®
      const enableRegexSearch = this.searchRootConfigs ? this.searchRootConfigs.enableRegexSearch : false;
      
      // è§£æå…³é”®è¯ï¼Œè¯†åˆ«æ­£åˆ™è¡¨è¾¾å¼
      const parsedKeywords = keywords.map(keyword => this.parseSearchKeyword(keyword, enableRegexSearch));
      
      // è·å–åˆ†ç»„çš„æ‰©å±•å…³é”®è¯ï¼ˆç”¨äº"ä¸"é€»è¾‘æœç´¢ï¼‰
      // æ³¨æ„ï¼šè¿™é‡Œå…ˆä¸ä¼ é€’æ ‡é¢˜ï¼Œå› ä¸ºæ¯ä¸ªå¡ç‰‡çš„æ ‡é¢˜ä¸åŒï¼Œå°†åœ¨åé¢çš„å¾ªç¯ä¸­åŠ¨æ€æ‰©å±•
      const baseExpandedKeywordGroups = this.expandKeywordsWithSynonymsGrouped(keywords);
      
      // è®¡ç®—æ€»æ‰©å±•è¯æ•°ç”¨äºæ˜¾ç¤º
      const totalExpandedCount = baseExpandedKeywordGroups.reduce((sum, group) => sum + group.length, 0);
      if (totalExpandedCount > keywords.length) {
        MNUtil.showHUD(`ğŸ”„ å…³é”®è¯å·²æ‰©å±•ï¼š${keywords.length}ä¸ªè¯ç»„ï¼Œå…±${totalExpandedCount}ä¸ªè¯`);
        await MNUtil.delay(0.5);
      }
      
      // å¦‚æœå¯ç”¨äº†æ­£åˆ™æœç´¢ï¼Œæ˜¾ç¤ºæç¤º
      if (enableRegexSearch) {
        const regexCount = parsedKeywords.filter(k => k.type === 'regex').length;
        if (regexCount > 0) {
          MNUtil.showHUD(`ğŸ”¤ æ­£åˆ™æ¨¡å¼ï¼š${regexCount}ä¸ªæ­£åˆ™è¡¨è¾¾å¼`);
          await MNUtil.delay(0.5);
        }
      }
      
      // è·å–æ¿€æ´»çš„æ’é™¤è¯ä¿¡æ¯
      const exclusionInfo = this.getActiveExclusions(keywords);
      if (exclusionInfo.excludeWords.length > 0) {
        MNUtil.showHUD(`ğŸš« å°†æ™ºèƒ½è¿‡æ»¤åŒ…å«æ’é™¤è¯çš„ç»“æœ`);
        await MNUtil.delay(0.5);
      }
      
      // è·å–é…ç½®ä¸­çš„è·³è¿‡ç©ºæ ‡é¢˜è®¾ç½®
      const skipEmptyTitle = this.searchRootConfigs ? this.searchRootConfigs.skipEmptyTitle : false;
      if (skipEmptyTitle) {
        MNUtil.showHUD(`ğŸš« å·²å¯ç”¨è·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡`);
        await MNUtil.delay(0.5);
      }
      
      // æ˜¾ç¤ºè·å–å¡ç‰‡åˆ—è¡¨çš„è¿›åº¦
      MNUtil.showHUD(`â›³ æ­£åœ¨ä» ${rootNoteIds.length} ä¸ªæ ¹ç›®å½•è·å–å¡ç‰‡åˆ—è¡¨...`);
      
      // è·å–æ‰€æœ‰æ ¹ç›®å½•çš„å­å­™å¡ç‰‡ï¼Œä½¿ç”¨ Set å»é‡
      const allDescendantsSet = new Set();
      const rootNoteInfos = [];  // å­˜å‚¨æ ¹ç›®å½•ä¿¡æ¯ï¼Œç”¨äºåç»­æ˜¾ç¤º
      
      for (const rootNoteId of rootNoteIds) {
        const rootNote = MNNote.new(rootNoteId);
        if (!rootNote) {
          MNUtil.log(`æ ¹ç›®å½•å¡ç‰‡ä¸å­˜åœ¨: ${rootNoteId}`);
          continue;
        }
        
        // ä¿å­˜æ ¹ç›®å½•ä¿¡æ¯
        rootNoteInfos.push({
          id: rootNoteId,
          name: rootNote.noteTitle || "æ— æ ‡é¢˜"
        });
        
        // è·å–è¯¥æ ¹ç›®å½•çš„æ‰€æœ‰å­å­™å¡ç‰‡ï¼ˆæ ¹æ®é…ç½®å†³å®šæ˜¯å¦è·³è¿‡ç©ºæ ‡é¢˜ï¼‰
        const descendants = skipEmptyTitle 
          ? this.getAllDescendantNotesWithSkipEmpty(rootNote, true, rootNoteIds)
          : this.getAllDescendantNotes(rootNote);
        
        // æ·»åŠ åˆ° Set ä¸­å»é‡ï¼ˆåŸºäº noteIdï¼‰
        for (const note of descendants) {
          allDescendantsSet.add(note);
        }
        
        MNUtil.log(`æ ¹ç›®å½• "${rootNote.noteTitle}": ${descendants.length} ä¸ªå¡ç‰‡`);
      }
      
      // è½¬æ¢ä¸ºæ•°ç»„
      const allDescendants = Array.from(allDescendantsSet);
      MNUtil.log(`æ€»å…±åœ¨ ${allDescendants.length} ä¸ªå¡ç‰‡ä¸­æœç´¢ï¼ˆå·²å»é‡ï¼‰`);
      
      // æ˜¾ç¤ºæœç´¢è¿›åº¦
      MNUtil.showHUD(`ğŸ” æ­£åœ¨æœç´¢ ${allDescendants.length} ä¸ªå¡ç‰‡...`);
      
      // è·å–é…ç½®ä¸­çš„å½’ç±»å¡ç‰‡è®¾ç½®
      const includeClassification = this.searchRootConfigs ? this.searchRootConfigs.includeClassification : true;
      const onlyClassification = this.searchRootConfigs ? this.searchRootConfigs.onlyClassification : false;
      // è·å–é…ç½®ä¸­çš„å¿½ç•¥å‰ç¼€è®¾ç½®
      const ignorePrefix = this.searchRootConfigs ? this.searchRootConfigs.ignorePrefix : false;
      
      // è¿‡æ»¤ç¬¦åˆæ¡ä»¶çš„å¡ç‰‡
      const results = [];
      let processedCount = 0;
      
      for (const note of allDescendants) {
        const mnNote = MNNote.new(note);
        const title = mnNote.noteTitle || "";
        
        // æ¯å¤„ç† 100 ä¸ªå¡ç‰‡æ˜¾ç¤ºä¸€æ¬¡è¿›åº¦
        processedCount++;
        if (processedCount % 100 === 0) {
          MNUtil.showHUD(`ğŸ” æ­£åœ¨æœç´¢... (${processedCount}/${allDescendants.length})`);
          // å»¶è¿Ÿä¸€ä¸‹ï¼Œè®©UIæœ‰æœºä¼šæ›´æ–°
          await MNUtil.delay(0.01);
        }
        
        // è·å–å¡ç‰‡ç±»å‹
        const noteType = this.getNoteType(mnNote);
        
        // å¤„ç†å½’ç±»å¡ç‰‡çš„è¿‡æ»¤é€»è¾‘
        if (onlyClassification) {
          // åªæœç´¢å½’ç±»å¡ç‰‡æ¨¡å¼
          if (noteType !== "å½’ç±»") {
            continue;  // è·³è¿‡éå½’ç±»å¡ç‰‡
          }
        } else if (!includeClassification && noteType === "å½’ç±»") {
          // ä¸åŒ…å«å½’ç±»å¡ç‰‡æ¨¡å¼
          continue;  // è·³è¿‡å½’ç±»å¡ç‰‡
        }
        
        // å¦‚æœç”¨æˆ·é€‰æ‹©äº†ç‰¹å®šç±»å‹ï¼Œè¿›è¡Œç±»å‹ç­›é€‰ï¼ˆåªæœç´¢å½’ç±»å¡ç‰‡æ—¶å¿½ç•¥ç±»å‹ç­›é€‰ï¼‰
        if (!onlyClassification && selectedTypes !== null && selectedTypes.size > 0) {
          if (!selectedTypes.has(noteType)) {
            continue;  // è·³è¿‡æœªé€‰ä¸­ç±»å‹çš„å¡ç‰‡
          }
        }
        
        // æ ¹æ®é…ç½®å†³å®šæœç´¢çš„æ–‡æœ¬å†…å®¹
        let searchText = title;  // é»˜è®¤æœç´¢å®Œæ•´æ ‡é¢˜
        
        // å¦‚æœå¯ç”¨äº†å¿½ç•¥å‰ç¼€ï¼Œä¸”ä¸æ˜¯å½’ç±»å¡ç‰‡
        if (ignorePrefix && noteType !== "å½’ç±»") {
          const parsedTitle = this.parseNoteTitle(mnNote);
          // ä½¿ç”¨æ— å‰ç¼€çš„å†…å®¹éƒ¨åˆ†è¿›è¡Œæœç´¢
          searchText = parsedTitle.content || title;
        }
        
        // è·å–é…ç½®ä¸­çš„æœç´¢å…³é”®è¯å­—æ®µè®¾ç½®
        const searchInKeywords = this.searchRootConfigs ? this.searchRootConfigs.searchInKeywords : false;
        
        // å¦‚æœå¯ç”¨äº†å…³é”®è¯å­—æ®µæœç´¢ï¼Œå°è¯•è·å–å…³é”®è¯å†…å®¹
        if (searchInKeywords) {
          const keywordsContent = this.getKeywordsFromNote(mnNote);
          if (keywordsContent) {
            // å°†å…³é”®è¯å†…å®¹æ·»åŠ åˆ°æœç´¢æ–‡æœ¬ä¸­
            searchText = searchText + " " + keywordsContent;
          }
        }
        
        // æ ¹æ®å½“å‰å¡ç‰‡çš„æ ‡é¢˜åŠ¨æ€æ‰©å±•å…³é”®è¯
        const expandedKeywordGroups = this.expandKeywordsWithSynonymsGrouped(keywords, title);
        
        // ä½¿ç”¨"ä¸"é€»è¾‘ï¼šæ¯ä¸ªå…³é”®è¯ç»„å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ªåŒ¹é…
        // ä¾‹å¦‚ï¼šè¾“å…¥ "A//B"ï¼ŒA åŠå…¶åŒä¹‰è¯ä¸ºä¸€ç»„ï¼ŒB åŠå…¶åŒä¹‰è¯ä¸ºä¸€ç»„
        // æœç´¢æ–‡æœ¬å¿…é¡»åŒ…å«ç¬¬ä¸€ç»„ä¸­çš„è‡³å°‘ä¸€ä¸ªè¯ ä¸” åŒ…å«ç¬¬äºŒç»„ä¸­çš„è‡³å°‘ä¸€ä¸ªè¯
        let allGroupsMatch = true;
        
        // ä½¿ç”¨è§£æåçš„å…³é”®è¯è¿›è¡ŒåŒ¹é…
        for (let i = 0; i < parsedKeywords.length; i++) {
          const parsedKeyword = parsedKeywords[i];
          let groupHasMatch = false;
          
          if (parsedKeyword.type === 'regex') {
            // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ï¼ˆä¸è¿›è¡ŒåŒä¹‰è¯æ‰©å±•ï¼‰
            try {
              const regex = new RegExp(parsedKeyword.pattern, 'i'); // é»˜è®¤ä¸åŒºåˆ†å¤§å°å†™
              if (regex.test(searchText)) {
                groupHasMatch = true;
              }
            } catch (e) {
              // æ— æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œè·³è¿‡
              MNUtil.log(`æ— æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼: ${parsedKeyword.pattern}`);
            }
          } else {
            // æ™®é€šæ–‡æœ¬åŒ¹é…ï¼ˆä½¿ç”¨åŒä¹‰è¯æ‰©å±•ï¼‰
            const keywordGroup = expandedKeywordGroups[i];
            if (keywordGroup) {
              // æ£€æŸ¥å½“å‰ç»„ä¸­æ˜¯å¦æœ‰ä»»ä½•å…³é”®è¯åŒ¹é…
              for (const keyword of keywordGroup) {
                if (searchText.includes(keyword)) {
                  groupHasMatch = true;
                  break;  // æ‰¾åˆ°åŒ¹é…å°±è·³å‡ºå½“å‰ç»„çš„å¾ªç¯
                }
              }
            }
          }
          
          // å¦‚æœå½“å‰ç»„æ²¡æœ‰ä»»ä½•åŒ¹é…ï¼Œåˆ™æ•´ä½“ä¸åŒ¹é…
          if (!groupHasMatch) {
            allGroupsMatch = false;
            break;  // ä¸éœ€è¦æ£€æŸ¥å…¶ä»–ç»„äº†
          }
        }
        
        // åªæœ‰æ‰€æœ‰ç»„éƒ½æœ‰åŒ¹é…æ—¶ï¼Œæ‰è€ƒè™‘å°†å¡ç‰‡åŠ å…¥ç»“æœ
        if (allGroupsMatch) {
          // æ™ºèƒ½æ’é™¤æ£€æŸ¥
          let shouldExclude = false;
          
          if (exclusionInfo.groups.length > 0) {
            // ========================================
            // ğŸ” æœç´¢æ—¶çš„æ’é™¤è¯åŒ¹é…é€»è¾‘ï¼ˆæ—§ç‰ˆæœ¬å®ç°ï¼‰
            // ========================================
            //
            // ğŸ”„ å…¼å®¹æ€§è¯´æ˜ï¼š
            // è¿™æ˜¯æ—§ç‰ˆæœ¬çš„æœç´¢å®ç°ï¼Œä¸ search.html ä¸­çš„æ–°å®ç°é€»è¾‘ç›¸åŒã€‚
            // åŒæ ·ä½¿ç”¨ affectedTriggers å­—æ®µåˆ¤æ–­æ˜¯å¦æ’é™¤ã€‚
            //
            // åˆ¤æ–­æµç¨‹ï¼š
            // 1. å®æ—¶åˆ†æå¡ç‰‡çš„æ’é™¤è¯ç»„ï¼ˆä¸ç´¢å¼•æ„å»ºæ—¶é€»è¾‘ä¸€è‡´ï¼‰
            // 2. éå†ç”¨æˆ·æœç´¢æ¿€æ´»çš„æ’é™¤è¯ç»„ï¼ˆactiveGroupï¼‰
            // 3. æ£€æŸ¥å¡ç‰‡çš„æ’é™¤è¯ç»„ï¼ˆcardGroupï¼‰
            // 4. å…³é”®æ£€æŸ¥ï¼šç”¨æˆ·æœç´¢çš„è§¦å‘è¯æ˜¯å¦åœ¨å¡ç‰‡çš„ affectedTriggers ä¸­
            //
            // ä¸¤ä¸ªå…³é”®å­—æ®µçš„åŒºåˆ«ï¼š
            // - activeGroup.triggerWordsï¼šç”¨æˆ·æœç´¢æ¿€æ´»çš„è§¦å‘è¯ï¼ˆæ¥è‡ªæœç´¢æŸ¥è¯¢ï¼‰
            // - cardGroup.affectedTriggersï¼šå¡ç‰‡ä¸­è¢«æ±¡æŸ“çš„è§¦å‘è¯ï¼ˆæ¥è‡ªå®æ—¶åˆ†æï¼‰
            //
            const applicableGroups = KnowledgeBaseIndexer.analyzeExclusionGroups(searchText);

            if (applicableGroups.length > 0) {
              // æ£€æŸ¥æ˜¯å¦æœ‰æ¿€æ´»çš„æ’é™¤è¯ç»„éœ€è¦æ’é™¤è¿™å¼ å¡ç‰‡
              for (const activeGroup of exclusionInfo.groups) {
                for (const cardGroup of applicableGroups) {
                  // æ£€æŸ¥æ˜¯å¦ä¸ºåŒä¸€ä¸ªæ’é™¤è¯ç»„ï¼ˆé€šè¿‡ ID æˆ– triggerWords æ¯”å¯¹ï¼‰
                  if (cardGroup.groupId === activeGroup.id) {
                    // ğŸ¯ æ ¸å¿ƒåˆ¤æ–­ï¼šç”¨æˆ·æœç´¢çš„è§¦å‘è¯æ˜¯å¦åœ¨å¡ç‰‡çš„æ±¡æŸ“åˆ—è¡¨ä¸­
                    // åªæœ‰å½“"ç”¨æˆ·æœç´¢çš„è§¦å‘è¯"åœ¨"å¡ç‰‡è¢«æ±¡æŸ“çš„è§¦å‘è¯"ä¸­æ—¶ï¼Œæ‰æ’é™¤å¡ç‰‡
                    const hasAffectedTrigger = activeGroup.triggerWords.some(trigger =>
                      cardGroup.affectedTriggers.includes(trigger)
                    );

                    if (hasAffectedTrigger) {
                      shouldExclude = true;  // âŒ åº”è¯¥æ’é™¤ï¼ˆå®Œå…¨æ±¡æŸ“ï¼‰
                      MNUtil.log(`âŒ æ’é™¤å¡ç‰‡: "${title}" (åŒ¹é…æ’é™¤ç»„ "${cardGroup.groupName}")`);
                      break;
                    }
                    // âœ… å¦åˆ™ä¿ç•™ï¼ˆéƒ¨åˆ†æ±¡æŸ“æˆ–æ— æ±¡æŸ“ï¼‰
                  }
                }
                if (shouldExclude) break;
              }

              if (!shouldExclude && applicableGroups.length > 0) {
                MNUtil.log(`âœ… ä¿ç•™å¡ç‰‡: "${title}" (è™½åŒ…å«æ’é™¤è¯ä½†è§¦å‘è¯ç‹¬ç«‹å­˜åœ¨)`);
              }
            }
          }
          
          // åªæœ‰ä¸åº”è¯¥æ’é™¤æ—¶æ‰åŠ å…¥ç»“æœ
          if (!shouldExclude) {
            results.push(mnNote);
          }
        }
      }
      
      MNUtil.log(`æ‰¾åˆ° ${results.length} ä¸ªåŒ¹é…ç»“æœ`);
      return results;
    } catch (error) {
      MNUtil.log("æœç´¢å¤±è´¥: " + error.toString());
      MNUtil.addErrorLog(error, "searchNotesInDescendants");
      return [];
    }
  }
  
  /**
   * æ ¹æ®é€‰ä¸­çš„æ ¹ç›®å½•æ›´æ–° skipEmptyTitle è®¾ç½®
   * @param {Array} currentRootIds - å½“å‰é€‰ä¸­çš„æ ¹ç›®å½•IDæ•°ç»„
   * @param {Object} allRoots - æ‰€æœ‰æ ¹ç›®å½•é…ç½®
   * @returns {boolean} æ˜¯å¦åº”è¯¥è·³è¿‡ç©ºç™½æ ‡é¢˜
   */
  static updateSkipEmptyTitleFromRoots(currentRootIds, allRoots) {
    // ç­–ç•¥ï¼šæ‰€æœ‰é€‰ä¸­çš„æ ¹ç›®å½•éƒ½å¯ç”¨ skipEmptyTitleByDefault æ—¶æ‰é»˜è®¤å¼€å¯ï¼ˆä¿å®ˆç­–ç•¥ï¼‰
    let shouldSkipEmpty = false;
    
    if (currentRootIds.length > 0) {
      shouldSkipEmpty = true; // å…ˆå‡è®¾åº”è¯¥è·³è¿‡
      
      for (const rootId of currentRootIds) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸´æ—¶æ ¹ç›®å½•
        if (this.tempRootInfo && this.tempRootInfo.id === rootId) {
          // ä¸´æ—¶æ ¹ç›®å½•é»˜è®¤ä¸è·³è¿‡ç©ºç™½æ ‡é¢˜
          shouldSkipEmpty = false;
          break;
        }
        
        // åœ¨é…ç½®ä¸­æŸ¥æ‰¾æ ¹ç›®å½•
        let rootFound = false;
        for (const key in allRoots) {
          if (allRoots[key].id === rootId) {
            rootFound = true;
            // å¦‚æœæœ‰ä»»ä½•ä¸€ä¸ªæ ¹ç›®å½•æ²¡æœ‰å¯ç”¨è·³è¿‡ç©ºç™½ï¼Œå°±ä¸è·³è¿‡
            if (!allRoots[key].skipEmptyTitleByDefault) {
              shouldSkipEmpty = false;
              break;
            }
          }
        }
        
        // å¦‚æœæŸä¸ªæ ¹ç›®å½•æœªæ‰¾åˆ°ï¼ˆå¯èƒ½æ˜¯å·²åˆ é™¤çš„ï¼‰ï¼Œé»˜è®¤ä¸è·³è¿‡
        if (!rootFound) {
          shouldSkipEmpty = false;
          break;
        }
        
        if (!shouldSkipEmpty) break;
      }
    }
    
    // åº”ç”¨è®¾ç½®
    this.searchRootConfigs.skipEmptyTitle = shouldSkipEmpty;
    this.saveSearchConfig();
    
    return shouldSkipEmpty;
  }
  
  /**
   * æ˜¾ç¤ºæœç´¢å¯¹è¯æ¡† - ä¸»å…¥å£
   * å¤„ç†ç”¨æˆ·è¾“å…¥å’Œæœç´¢æµç¨‹
   */
  static async showSearchDialog() {
    try {
      // åˆå§‹åŒ–é…ç½®
      this.initSearchConfig();
      
      // è·å–ä¸Šæ¬¡ä½¿ç”¨çš„æ ¹ç›®å½•ï¼ˆæ”¯æŒå¤šä¸ªï¼‰
      let currentRootIds = this.getLastUsedRootIds();
      let allRoots = this.getAllSearchRoots();
      let selectedTypes = null;  // null è¡¨ç¤ºå…¨é€‰ï¼ŒSet è¡¨ç¤ºé€‰ä¸­çš„ç±»å‹
      
      // ç¬¬ä¸€æ­¥ï¼šç¡®è®¤/é€‰æ‹©æ ¹ç›®å½•
      const rootSelectionResult = await this.showRootSelectionStep(currentRootIds, allRoots);
      if (!rootSelectionResult) {
        return; // ç”¨æˆ·å–æ¶ˆ
      }
      currentRootIds = rootSelectionResult;
      
      // ä¿å­˜æœ€åä½¿ç”¨çš„æ ¹ç›®å½•
      const rootKeys = [];
      for (const rootId of currentRootIds) {
        for (const key in allRoots) {
          if (allRoots[key].id === rootId) {
            rootKeys.push(key);
            break;
          }
        }
      }
      this.searchRootConfigs.lastUsedRoots = rootKeys;
      this.saveSearchConfig();
      
      // æ ¹æ®é€‰ä¸­çš„æ ¹ç›®å½•åˆå§‹åŒ– skipEmptyTitle è®¾ç½®
      const shouldSkipEmpty = this.updateSkipEmptyTitleFromRoots(currentRootIds, allRoots);
      
      // æ˜¾ç¤ºæç¤º
      if (shouldSkipEmpty) {
        MNUtil.showHUD("âœ… å·²æ ¹æ®æ ¹ç›®å½•è®¾ç½®é»˜è®¤å¯ç”¨è·³è¿‡ç©ºç™½æ ‡é¢˜");
        await MNUtil.delay(1);
      }
      
      // ç¬¬äºŒæ­¥ï¼šè¾“å…¥å…³é”®è¯å¹¶æœç´¢
      let keywords = [];
      
      // ä¸»å¾ªç¯ï¼šå¤„ç†ç”¨æˆ·è¾“å…¥
      while (true) {
        // è·å–å½“å‰æ ¹ç›®å½•åç§°ï¼ˆæ”¯æŒå¤šä¸ªï¼‰
        const currentRootNames = this.getCurrentRootNames(currentRootIds, allRoots);
        
        // æ„å»ºæç¤ºä¿¡æ¯
        let rootDisplay = currentRootNames;
        if (currentRootIds.length > 3) {
          // å¦‚æœé€‰æ‹©äº†å¤ªå¤šæ ¹ç›®å½•ï¼Œåªæ˜¾ç¤ºå‰3ä¸ªå’Œæ•°é‡
          const firstThree = currentRootNames.split(", ").slice(0, 3).join(", ");
          rootDisplay = `${firstThree} ç­‰ ${currentRootIds.length} ä¸ª`;
        }
        let message = `ğŸ” æœç´¢ç¬”è®°\nğŸ“ æ ¹ç›®å½•(${currentRootIds.length}ä¸ª)ï¼š${rootDisplay}`;
        if (keywords.length > 0) {
          message += `\nğŸ”‘ å·²è¾“å…¥å…³é”®è¯ï¼š${keywords.join(" // ")}`;
        }
        // æ˜¾ç¤ºå½’ç±»å¡ç‰‡æœç´¢çŠ¶æ€
        const includeClassification = this.searchRootConfigs.includeClassification;
        message += `\nğŸ“‘ æœç´¢å½’ç±»å¡ç‰‡ï¼š${includeClassification ? "â˜‘ï¸ æ˜¯" : "â˜ï¸ å¦"}`;
        // æ˜¾ç¤ºåªæœç´¢å½’ç±»å¡ç‰‡çŠ¶æ€
        const onlyClassification = this.searchRootConfigs.onlyClassification;
        message += `\nğŸ¯ åªæœç´¢å½’ç±»å¡ç‰‡ï¼š${onlyClassification ? "â˜‘ï¸ æ˜¯" : "â˜ï¸ å¦"}`;
        // æ˜¾ç¤ºå¿½ç•¥å‰ç¼€æœç´¢çŠ¶æ€
        const ignorePrefix = this.searchRootConfigs.ignorePrefix;
        message += `\nğŸ“ å¿½ç•¥å‰ç¼€æœç´¢ï¼š${ignorePrefix ? "â˜‘ï¸ æ˜¯" : "â˜ï¸ å¦"}`;
        // æ˜¾ç¤ºæœç´¢å…³é”®è¯å­—æ®µçŠ¶æ€
        const searchInKeywords = this.searchRootConfigs.searchInKeywords;
        message += `\nğŸ”– æœç´¢å…³é”®è¯å­—æ®µï¼š${searchInKeywords ? "â˜‘ï¸ æ˜¯" : "â˜ï¸ å¦"}`;
        // æ˜¾ç¤ºè·³è¿‡ç©ºç™½æ ‡é¢˜çŠ¶æ€
        const skipEmptyTitle = this.searchRootConfigs.skipEmptyTitle;
        message += `\nğŸš« è·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡ï¼š${skipEmptyTitle ? "â˜‘ï¸ æ˜¯" : "â˜ï¸ å¦"}`;
        // æ˜¾ç¤ºæ­£åˆ™è¡¨è¾¾å¼æœç´¢çŠ¶æ€
        const enableRegexSearch = this.searchRootConfigs.enableRegexSearch;
        message += `\nğŸ”¤ æ­£åˆ™è¡¨è¾¾å¼æœç´¢ï¼š${enableRegexSearch ? "â˜‘ï¸ æ˜¯" : "â˜ï¸ å¦"}`;
        // æ˜¾ç¤ºé€‰ä¸­çš„ç±»å‹ï¼ˆåªæœç´¢å½’ç±»å¡ç‰‡æ—¶ä¸æ˜¾ç¤ºç±»å‹é€‰æ‹©ï¼‰
        if (!onlyClassification) {
          if (selectedTypes !== null && selectedTypes.size > 0) {
            const typeNames = Array.from(selectedTypes).join("ã€");
            message += `\nğŸ“‹ æœç´¢ç±»å‹ï¼š${typeNames}`;
          } else {
            message += `\nğŸ“‹ æœç´¢ç±»å‹ï¼šå…¨éƒ¨`;
          }
        }
        // æ ¹æ®æ­£åˆ™æœç´¢çŠ¶æ€æ˜¾ç¤ºä¸åŒçš„æç¤º
        if (enableRegexSearch) {
          message += `\n\nğŸ’¡ æ­£åˆ™æ¨¡å¼å·²å¯ç”¨ï¼š\nâ€¢ ä½¿ç”¨å‰ç¼€ r: re: regex: æ ‡è¯†æ­£åˆ™è¡¨è¾¾å¼\nâ€¢ æ— å‰ç¼€çš„å…³é”®è¯ä»æ”¯æŒåŒä¹‰è¯æ‰©å±•\nâ€¢ ç¤ºä¾‹ï¼šr:^å®šç†\\d+ æˆ– è¯æ˜`;
        } else {
          message += `\n\nğŸ’¡ æç¤ºï¼šç‚¹å‡»"æ·»åŠ æ ¹ç›®å½•"å¯ä½¿ç”¨å½“å‰å¡ç‰‡æˆ–è¾“å…¥ID/URL`;
        }
        
        // æ˜¾ç¤ºè¾“å…¥æ¡†
        const result = await new Promise((resolve) => {
          UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
            "æœç´¢ç¬”è®°",
            message,
            2, // è¾“å…¥æ¡†æ ·å¼
            "å–æ¶ˆ",
            // æ„å»ºæŒ‰é’®æ•°ç»„
            (() => {
              const buttons = [
                "å¼€å§‹æœç´¢", "ä¸‹ä¸€ä¸ªè¯", "åˆ‡æ¢æ ¹ç›®å½•", "æ·»åŠ æ ¹ç›®å½•",
                includeClassification ? "â˜‘ï¸ æœç´¢å½’ç±»å¡ç‰‡" : "â˜ï¸ æœç´¢å½’ç±»å¡ç‰‡",
                onlyClassification ? "â˜‘ï¸ åªæœç´¢å½’ç±»å¡ç‰‡" : "â˜ï¸ åªæœç´¢å½’ç±»å¡ç‰‡",
                ignorePrefix ? "â˜‘ï¸ å¿½ç•¥å‰ç¼€æœç´¢" : "â˜ï¸ å¿½ç•¥å‰ç¼€æœç´¢",
                searchInKeywords ? "â˜‘ï¸ æœç´¢å…³é”®è¯å­—æ®µ" : "â˜ï¸ æœç´¢å…³é”®è¯å­—æ®µ",
                skipEmptyTitle ? "â˜‘ï¸ è·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡" : "â˜ï¸ è·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡",
                enableRegexSearch ? "â˜‘ï¸ æ­£åˆ™è¡¨è¾¾å¼æœç´¢" : "â˜ï¸ æ­£åˆ™è¡¨è¾¾å¼æœç´¢"
              ];
              // åªåœ¨æœªå¯ç”¨"åªæœç´¢å½’ç±»å¡ç‰‡"æ—¶æ˜¾ç¤ºç±»å‹é€‰æ‹©æŒ‰é’®
              if (!onlyClassification) {
                buttons.push("ğŸ“‹ é€‰æ‹©ç±»å‹");
              }
              // æ·»åŠ æ›´å¤šåŠŸèƒ½æŒ‰é’®
              buttons.push("âš™ï¸ æ›´å¤šåŠŸèƒ½");
              return buttons;
            })(),
            (alert, buttonIndex) => {
              if (buttonIndex === 0) {
                // å–æ¶ˆ
                resolve({ action: "cancel" });
                return;
              }
              
              const inputText = alert.textFieldAtIndex(0).text.trim();
              
              switch (buttonIndex) {
                case 1: // å¼€å§‹æœç´¢
                  if (inputText) {
                    // å¤„ç†è¾“å…¥çš„å…³é”®è¯
                    const newKeywords = inputText.split("//").map(k => k.trim()).filter(k => k);
                    keywords.push(...newKeywords);
                  }
                  
                  if (keywords.length === 0) {
                    MNUtil.showHUD("è¯·è¾“å…¥æœç´¢å…³é”®è¯");
                    resolve({ action: "continue" });
                  } else {
                    resolve({ action: "search" });
                  }
                  break;
                  
                case 2: // ä¸‹ä¸€ä¸ªè¯
                  if (inputText) {
                    const newKeywords = inputText.split("//").map(k => k.trim()).filter(k => k);
                    keywords.push(...newKeywords);
                  }
                  resolve({ action: "nextWord" });
                  break;
                  
                case 3: // åˆ‡æ¢æ ¹ç›®å½•
                  resolve({ action: "switchRoot" });
                  break;
                  
                case 4: // æ·»åŠ æ ¹ç›®å½•
                  resolve({ action: "addRoot" });
                  break;
                  
                case 5: // åˆ‡æ¢å½’ç±»å¡ç‰‡æœç´¢å¼€å…³
                  resolve({ action: "toggleClassification" });
                  break;
                  
                case 6: // åˆ‡æ¢åªæœç´¢å½’ç±»å¡ç‰‡å¼€å…³
                  resolve({ action: "toggleOnlyClassification" });
                  break;
                  
                case 7: // åˆ‡æ¢å¿½ç•¥å‰ç¼€æœç´¢å¼€å…³
                  resolve({ action: "toggleIgnorePrefix" });
                  break;
                  
                case 8: // åˆ‡æ¢æœç´¢å…³é”®è¯å­—æ®µå¼€å…³
                  resolve({ action: "toggleSearchInKeywords" });
                  break;
                  
                case 9: // åˆ‡æ¢è·³è¿‡ç©ºç™½æ ‡é¢˜å¼€å…³
                  resolve({ action: "toggleSkipEmptyTitle" });
                  break;
                  
                case 10: // åˆ‡æ¢æ­£åˆ™è¡¨è¾¾å¼æœç´¢å¼€å…³
                  resolve({ action: "toggleRegexSearch" });
                  break;
                  
                case 11: // é€‰æ‹©ç±»å‹ï¼ˆåªåœ¨æœªå¯ç”¨"åªæœç´¢å½’ç±»å¡ç‰‡"æ—¶å­˜åœ¨ï¼‰
                  if (!onlyClassification) {
                    resolve({ action: "selectTypes" });
                  } else {
                    // å¦‚æœ"åªæœç´¢å½’ç±»å¡ç‰‡"å¯ç”¨ï¼Œ11 æ˜¯"æ›´å¤šåŠŸèƒ½"
                    resolve({ action: "moreFeatures" });
                  }
                  break;
                  
                case 12: // æ›´å¤šåŠŸèƒ½ï¼ˆåªåœ¨æœªå¯ç”¨"åªæœç´¢å½’ç±»å¡ç‰‡"æ—¶å­˜åœ¨ï¼‰
                  resolve({ action: "moreFeatures" });
                  break;
              }
            }
          );
        });
        
        // å¤„ç†ç»“æœ
        switch (result.action) {
          case "cancel":
            return;
            
          case "search":
            // æ‰§è¡Œæœç´¢
            MNUtil.showHUD("â³ æœç´¢ä¸­...");
            const results = await this.searchNotesInDescendants(keywords, currentRootIds, selectedTypes);
            
            if (results.length === 0) {
              MNUtil.showHUD(`æœªæ‰¾åˆ°åŒ…å« "${keywords.join(' AND ')}" çš„å¡ç‰‡`);
            } else if (results.length === 1) {
              // åªæœ‰ä¸€ä¸ªç»“æœæ—¶ï¼Œç›´æ¥å®šä½åˆ°è¯¥å¡ç‰‡
              results[0].focusInFloatMindMap(0.5);
              MNUtil.showHUD(`âœ… æ‰¾åˆ°å”¯ä¸€ç»“æœï¼Œå·²å®šä½`);
            } else {
              // å¤šä¸ªç»“æœæ—¶ï¼Œåˆ›å»ºæœç´¢ç»“æœå¡ç‰‡
              this.createSearchResultCard(results, keywords, currentRootNames);
              MNUtil.showHUD(`âœ… æ‰¾åˆ° ${results.length} ä¸ªç»“æœ`);
            }
            return;
            
          case "nextWord":
          case "continue":
            // ç»§ç»­å¾ªç¯
            break;
            
          case "switchRoot":
            // é€‰æ‹©æ ¹ç›®å½•ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
            const newRootIds = await this.showRootSelection(currentRootIds, allRoots);
            if (newRootIds && newRootIds.length > 0) {
              currentRootIds = newRootIds;
              
              // æ›´æ–° skipEmptyTitle è®¾ç½®
              const shouldSkip = this.updateSkipEmptyTitleFromRoots(currentRootIds, allRoots);
              if (shouldSkip) {
                MNUtil.showHUD("âœ… å·²æ ¹æ®æ–°é€‰æ‹©çš„æ ¹ç›®å½•å¯ç”¨è·³è¿‡ç©ºç™½æ ‡é¢˜");
              } else {
                MNUtil.showHUD("â˜ å·²æ ¹æ®æ–°é€‰æ‹©çš„æ ¹ç›®å½•ç¦ç”¨è·³è¿‡ç©ºç™½æ ‡é¢˜");
              }
            }
            break;
            
          case "addRoot":
            // æ·»åŠ æ ¹ç›®å½•
            const newRoot = await this.handleAddRoot(null);
            if (newRoot) {
              // å°†æ–°æ·»åŠ çš„æ ¹ç›®å½•åŠ å…¥åˆ°å½“å‰é€‰ä¸­çš„æ ¹ç›®å½•åˆ—è¡¨
              if (!currentRootIds.includes(newRoot.id)) {
                currentRootIds.push(newRoot.id);
              }
              // æ›´æ–°æœ€åä½¿ç”¨çš„æ ¹ç›®å½•åˆ—è¡¨
              const rootKeys = [];
              for (const rootId of currentRootIds) {
                // æŸ¥æ‰¾æ¯ä¸ªæ ¹ç›®å½•å¯¹åº”çš„key
                for (const key in allRoots) {
                  if (allRoots[key].id === rootId) {
                    rootKeys.push(key);
                    break;
                  }
                }
              }
              // å¦‚æœæ–°æ ¹ç›®å½•çš„keyä¸åœ¨åˆ—è¡¨ä¸­ï¼Œæ·»åŠ å®ƒ
              if (!rootKeys.includes(newRoot.key)) {
                rootKeys.push(newRoot.key);
              }
              this.searchRootConfigs.lastUsedRoots = rootKeys;
              this.saveSearchConfig();
              // åˆ·æ–° allRoots ä»¥åŒ…å«æ–°æ·»åŠ çš„æ ¹ç›®å½•
              allRoots = this.getAllSearchRoots();
              
              // æ›´æ–° skipEmptyTitle è®¾ç½®ï¼ˆæ–°æ·»åŠ çš„æ ¹ç›®å½•é»˜è®¤ä¸è·³è¿‡ï¼‰
              this.updateSkipEmptyTitleFromRoots(currentRootIds, allRoots);
              
              MNUtil.showHUD(`âœ… å·²æ·»åŠ æ ¹ç›®å½•ï¼š${newRoot.name}`);
            }
            break;
            
          case "toggleClassification":
            // åˆ‡æ¢å½’ç±»å¡ç‰‡æœç´¢å¼€å…³
            this.searchRootConfigs.includeClassification = !this.searchRootConfigs.includeClassification;
            // å¦‚æœç¦ç”¨äº†åŒ…å«å½’ç±»å¡ç‰‡ï¼ŒåŒæ—¶ä¹Ÿè¦ç¦ç”¨åªæœç´¢å½’ç±»å¡ç‰‡
            if (!this.searchRootConfigs.includeClassification) {
              this.searchRootConfigs.onlyClassification = false;
            }
            this.saveSearchConfig();
            MNUtil.showHUD(`å½’ç±»å¡ç‰‡æœç´¢ï¼š${this.searchRootConfigs.includeClassification ? "å·²å¯ç”¨" : "å·²ç¦ç”¨"}`);
            break;
            
          case "toggleOnlyClassification":
            // åˆ‡æ¢åªæœç´¢å½’ç±»å¡ç‰‡å¼€å…³
            this.searchRootConfigs.onlyClassification = !this.searchRootConfigs.onlyClassification;
            // å¦‚æœå¯ç”¨äº†åªæœç´¢å½’ç±»å¡ç‰‡ï¼Œç¡®ä¿åŒ…å«å½’ç±»å¡ç‰‡ä¹Ÿæ˜¯å¯ç”¨çš„
            if (this.searchRootConfigs.onlyClassification) {
              this.searchRootConfigs.includeClassification = true;
              // åŒæ—¶æ¸…ç©ºç±»å‹é€‰æ‹©
              selectedTypes = null;
            }
            this.saveSearchConfig();
            MNUtil.showHUD(`åªæœç´¢å½’ç±»å¡ç‰‡ï¼š${this.searchRootConfigs.onlyClassification ? "å·²å¯ç”¨" : "å·²ç¦ç”¨"}`);
            break;
            
          case "toggleIgnorePrefix":
            // åˆ‡æ¢å¿½ç•¥å‰ç¼€æœç´¢å¼€å…³
            this.searchRootConfigs.ignorePrefix = !this.searchRootConfigs.ignorePrefix;
            this.saveSearchConfig();
            MNUtil.showHUD(`å¿½ç•¥å‰ç¼€æœç´¢ï¼š${this.searchRootConfigs.ignorePrefix ? "å·²å¯ç”¨" : "å·²ç¦ç”¨"}`);
            break;
            
          case "toggleSearchInKeywords":
            // åˆ‡æ¢æœç´¢å…³é”®è¯å­—æ®µå¼€å…³
            this.searchRootConfigs.searchInKeywords = !this.searchRootConfigs.searchInKeywords;
            this.saveSearchConfig();
            MNUtil.showHUD(`æœç´¢å…³é”®è¯å­—æ®µï¼š${this.searchRootConfigs.searchInKeywords ? "å·²å¯ç”¨" : "å·²ç¦ç”¨"}`);
            break;
            
          case "toggleSkipEmptyTitle":
            // åˆ‡æ¢è·³è¿‡ç©ºç™½æ ‡é¢˜å¼€å…³
            this.searchRootConfigs.skipEmptyTitle = !this.searchRootConfigs.skipEmptyTitle;
            this.saveSearchConfig();
            MNUtil.showHUD(`è·³è¿‡ç©ºç™½æ ‡é¢˜å¡ç‰‡ï¼š${this.searchRootConfigs.skipEmptyTitle ? "å·²å¯ç”¨" : "å·²ç¦ç”¨"}`);
            break;
            
          case "toggleRegexSearch":
            // åˆ‡æ¢æ­£åˆ™è¡¨è¾¾å¼æœç´¢å¼€å…³
            this.searchRootConfigs.enableRegexSearch = !this.searchRootConfigs.enableRegexSearch;
            this.saveSearchConfig();
            MNUtil.showHUD(`æ­£åˆ™è¡¨è¾¾å¼æœç´¢ï¼š${this.searchRootConfigs.enableRegexSearch ? "å·²å¯ç”¨" : "å·²ç¦ç”¨"}`);
            break;
            
          case "selectTypes":
            // æ˜¾ç¤ºç±»å‹é€‰æ‹©å¯¹è¯æ¡†
            const newSelectedTypes = await this.showTypeSelectDialog(selectedTypes);
            if (newSelectedTypes !== null) {
              selectedTypes = newSelectedTypes;
            }
            break;
            
          case "moreFeatures":
            // æ˜¾ç¤ºæ›´å¤šåŠŸèƒ½èœå•
            const moreAction = await this.showMoreFeaturesMenu();
            if (moreAction === "manageRoots") {
              await this.manageSearchRootsUI();
            } else if (moreAction === "importExport") {
              await this.showImportExportMenu();
            }
            break;
            
        }
        
        // å¦‚æœæ˜¯ search æˆ– cancelï¼Œä¼š returnï¼Œå…¶ä»–æƒ…å†µç»§ç»­å¾ªç¯
        if (result.action === "search" || result.action === "cancel") {
          break;
        }
      }
    } catch (error) {
      MNUtil.showHUD("æœç´¢å¤±è´¥: " + error.message);
      MNUtil.addErrorLog(error, "showSearchDialog");
    }
  }
  
  /**
   * æ˜¾ç¤ºç±»å‹é€‰æ‹©å¯¹è¯æ¡†
   * @param {Set|null} selectedTypes - å·²é€‰ä¸­çš„ç±»å‹é›†åˆï¼Œnull è¡¨ç¤ºç¬¬ä¸€æ¬¡æ‰“å¼€
   * @returns {Promise<Set|null>} è¿”å›é€‰ä¸­çš„ç±»å‹é›†åˆï¼Œnull è¡¨ç¤ºå–æ¶ˆ
   */
  static showTypeSelectDialog(selectedTypes = null) {
    // å®šä¹‰å¯é€‰çš„ç±»å‹
    const availableTypes = ["å®šä¹‰", "å‘½é¢˜", "åä¾‹", "æ€æƒ³æ–¹æ³•", "æ€è·¯", "é—®é¢˜"];
    
    // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ‰“å¼€ï¼ˆselectedTypes ä¸º nullï¼‰ï¼Œåˆ›å»ºç©º Set
    if (selectedTypes === null) {
      selectedTypes = new Set();
    }
    
    // æ„å»ºæ˜¾ç¤ºé€‰é¡¹
    let displayOptions = availableTypes.map(type => {
      let prefix = selectedTypes.has(type) ? "âœ… " : "";
      return prefix + type;
    });
    
    // æ·»åŠ å…¨é€‰/å–æ¶ˆå…¨é€‰é€‰é¡¹
    let allSelected = selectedTypes.size === availableTypes.length;
    let selectAllText = allSelected ? "â¬œ å–æ¶ˆå…¨é€‰" : "â˜‘ï¸ å…¨é€‰æ‰€æœ‰ç±»å‹";
    displayOptions.unshift(selectAllText);
    
    // æ·»åŠ ç¡®å®šé€‰é¡¹
    displayOptions.push("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    displayOptions.push("âœ… ç¡®å®šé€‰æ‹©");
    
    return new Promise((resolve) => {
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        "é€‰æ‹©è¦æœç´¢çš„å¡ç‰‡ç±»å‹",
        `å·²é€‰ä¸­ ${selectedTypes.size}/${availableTypes.length} ä¸ªç±»å‹`,
        0,
        "å–æ¶ˆ",
        displayOptions,
        (alert, buttonIndex) => {
          if (buttonIndex === 0) {
            resolve(null); // å–æ¶ˆ
            return;
          }
          
          if (buttonIndex === 1) {
            // å…¨é€‰/å–æ¶ˆå…¨é€‰
            if (allSelected) {
              selectedTypes.clear();
            } else {
              availableTypes.forEach(type => selectedTypes.add(type));
            }
            // é€’å½’è°ƒç”¨
            this.showTypeSelectDialog(selectedTypes).then(resolve);
          } else if (buttonIndex === displayOptions.length) {
            // ç¡®å®š
            resolve(selectedTypes.size > 0 ? selectedTypes : null);
          } else if (buttonIndex === displayOptions.length - 1) {
            // åˆ†éš”çº¿ï¼Œé‡æ–°æ˜¾ç¤º
            this.showTypeSelectDialog(selectedTypes).then(resolve);
          } else {
            // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
            const typeIndex = buttonIndex - 2;
            const type = availableTypes[typeIndex];
            if (selectedTypes.has(type)) {
              selectedTypes.delete(type);
            } else {
              selectedTypes.add(type);
            }
            // é€’å½’è°ƒç”¨
            this.showTypeSelectDialog(selectedTypes).then(resolve);
          }
        }
      );
    });
  }
  
  /**
   * è·å–å½“å‰æ ¹ç›®å½•åç§°
   */
  static getCurrentRootName(currentRootId, allRoots) {
    // å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯ä¸´æ—¶æ ¹ç›®å½•
    if (this.tempRootInfo && this.tempRootInfo.id === currentRootId) {
      return this.tempRootInfo.name;
    }
    
    // åœ¨é…ç½®ä¸­æŸ¥æ‰¾
    for (const [key, root] of Object.entries(allRoots)) {
      if (root.id === currentRootId) {
        return root.name;
      }
    }
    
    // å¦‚æœè¿˜æ˜¯æœªæ‰¾åˆ°ï¼Œå¯èƒ½æ˜¯ä¹‹å‰ä¿å­˜çš„ä¸´æ—¶æ ¹ç›®å½•ï¼Œå°è¯•è·å–å¡ç‰‡ä¿¡æ¯
    try {
      const rootNote = MNNote.new(currentRootId);
      if (rootNote) {
        return rootNote.noteTitle || "æ— æ ‡é¢˜";
      }
    } catch (e) {
      // å¿½ç•¥é”™è¯¯
    }
    
    return "æœªçŸ¥";
  }
  
  /**
   * æ˜¾ç¤ºæ ¹ç›®å½•é€‰æ‹©æ­¥éª¤ï¼ˆæœç´¢çš„ç¬¬ä¸€æ­¥ï¼‰
   * @param {Array} currentRootIds - å½“å‰é€‰ä¸­çš„æ ¹ç›®å½•IDæ•°ç»„
   * @param {Object} allRoots - æ‰€æœ‰æ ¹ç›®å½•
   * @returns {Promise<Array|null>} è¿”å›é€‰ä¸­çš„æ ¹ç›®å½•IDæ•°ç»„ï¼Œå–æ¶ˆè¿”å›null
   */
  static async showRootSelectionStep(currentRootIds, allRoots) {
    const currentRootNames = this.getCurrentRootNames(currentRootIds, allRoots);
    let rootDisplay = currentRootNames;
    if (currentRootIds.length > 3) {
      const firstThree = currentRootNames.split(", ").slice(0, 3).join(", ");
      rootDisplay = `${firstThree} ç­‰ ${currentRootIds.length} ä¸ª`;
    }
    
    const message = `ğŸ“ å½“å‰æ ¹ç›®å½•(${currentRootIds.length}ä¸ª):\n${rootDisplay}\n\næ˜¯å¦ä½¿ç”¨å½“å‰æ ¹ç›®å½•è¿›è¡Œæœç´¢ï¼Ÿ`;
    
    return new Promise((resolve) => {
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        "æœç´¢ç¬”è®° - é€‰æ‹©æ ¹ç›®å½•",
        message,
        0,
        "å–æ¶ˆ",
        ["âœ… ç¡®å®šä½¿ç”¨", "ğŸ”„ åˆ‡æ¢æ ¹ç›®å½•", "â• æ·»åŠ æ ¹ç›®å½•", "ğŸ“ è®¾ä¸ºä¸´æ—¶æ ¹ç›®å½•"],
        async (alert, buttonIndex) => {
          if (buttonIndex === 0) {
            resolve(null); // å–æ¶ˆ
            return;
          }
          
          switch (buttonIndex) {
            case 1: // ç¡®å®šä½¿ç”¨
              resolve(currentRootIds);
              break;
              
            case 2: // åˆ‡æ¢æ ¹ç›®å½•
              const newRootIds = await this.showRootSelectionWithGroups([], allRoots); // æ¸…ç©ºé€‰æ‹©
              if (newRootIds && newRootIds.length > 0) {
                // åˆ‡æ¢åˆ°æ­£å¼æ ¹ç›®å½•æ—¶ï¼Œæ¸…é™¤ä¸´æ—¶æ ¹ç›®å½•
                this.clearTempRoot();
                resolve(newRootIds);
              } else {
                // å¦‚æœç”¨æˆ·åœ¨åˆ‡æ¢ç•Œé¢å–æ¶ˆï¼Œé‡æ–°æ˜¾ç¤ºå½“å‰æ­¥éª¤
                const result = await this.showRootSelectionStep(currentRootIds, allRoots);
                resolve(result);
              }
              break;
              
            case 3: // æ·»åŠ æ ¹ç›®å½•
              const focusNote = MNNote.getFocusNote();
              if (!focusNote) {
                MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¡ç‰‡ä½œä¸ºæ ¹ç›®å½•");
                const result = await this.showRootSelectionStep(currentRootIds, allRoots);
                resolve(result);
                return;
              }
              
              // è·å–å¡ç‰‡æ ‡é¢˜ä½œä¸ºé»˜è®¤åç§°
              const defaultName = focusNote.noteTitle || "æœªå‘½åæ ¹ç›®å½•";
              
              // è¯·æ±‚ç”¨æˆ·è¾“å…¥æˆ–ç¡®è®¤åç§°
              const newRootName = await new Promise((innerResolve) => {
                UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
                  "æ·»åŠ æ ¹ç›®å½•",
                  `å½“å‰é€‰ä¸­çš„å¡ç‰‡ï¼š${defaultName}\n\nè¯·è¾“å…¥æ ¹ç›®å½•çš„åç§°ï¼š`,
                  2,
                  "å–æ¶ˆ",
                  ["ç¡®å®š"],
                  (alert2, buttonIndex2) => {
                    if (buttonIndex2 === 1) {
                      const name = alert2.textFieldAtIndex(0).text.trim() || defaultName;
                      innerResolve(name);
                    } else {
                      innerResolve(null);
                    }
                  }
                );
                // è®¾ç½®é»˜è®¤å€¼
                MNUtil.delay(0.01).then(() => {
                  try {
                    const currentAlert = UIAlertView.currentAlertView();
                    if (currentAlert && currentAlert.textFieldAtIndex) {
                      const textField = currentAlert.textFieldAtIndex(0);
                      if (textField) textField.text = defaultName;
                    }
                  } catch (e) {}
                });
              });
              
              if (newRootName) {
                const key = this.addSearchRoot(focusNote.noteId, newRootName);
                if (key && key !== false) {
                  const newRoot = {
                    key: key,
                    id: focusNote.noteId,
                    name: newRootName
                  };
                  if (!currentRootIds.includes(newRoot.id)) {
                    currentRootIds.push(newRoot.id);
                  }
                  allRoots[newRoot.key] = newRoot;
                  MNUtil.showHUD(`âœ… å·²æ·»åŠ æ ¹ç›®å½•ï¼š${newRoot.name}`);
                  
                  // æ›´æ–°æœ€åä½¿ç”¨çš„æ ¹ç›®å½•
                  const rootKeys = [];
                  for (const rootId of currentRootIds) {
                    for (const k in allRoots) {
                      if (allRoots[k].id === rootId) {
                        rootKeys.push(k);
                        break;
                      }
                    }
                  }
                  this.searchRootConfigs.lastUsedRoots = rootKeys;
                  this.saveSearchConfig();
                }
              }
              
              // é‡æ–°æ˜¾ç¤ºå½“å‰æ­¥éª¤
              const result = await this.showRootSelectionStep(currentRootIds, allRoots);
              resolve(result);
              break;
              
            case 4: // è®¾ä¸ºä¸´æ—¶æ ¹ç›®å½•
              const currentNote = MNNote.getFocusNote();
              if (!currentNote) {
                MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¡ç‰‡ä½œä¸ºä¸´æ—¶æ ¹ç›®å½•");
                const result = await this.showRootSelectionStep(currentRootIds, allRoots);
                resolve(result);
                return;
              }
              
              // è®¾ç½®ä¸´æ—¶æ ¹ç›®å½•
              this.setTempRoot(currentNote);
              
              // è¿”å›ä¸´æ—¶æ ¹ç›®å½•ä½œä¸ºæœç´¢æ ¹ç›®å½•
              resolve([currentNote.noteId]);
              break;
          }
        }
      );
    });
  }

  /**
   * æ˜¾ç¤ºæ ¹ç›®å½•é€‰æ‹©å¯¹è¯æ¡†ï¼ˆæ”¯æŒå¤šé€‰å’Œç¾¤ç»„ï¼‰
   * @param {Array} currentRootIds - å½“å‰é€‰ä¸­çš„æ ¹ç›®å½•IDæ•°ç»„
   * @param {Object} allRoots - æ‰€æœ‰æ ¹ç›®å½•
   * @returns {Promise<Array>} è¿”å›é€‰ä¸­çš„æ ¹ç›®å½•IDæ•°ç»„
   */
  static async showRootSelectionWithGroups(currentRootIds, allRoots) {
    // ç¡®ä¿æœ‰ç¾¤ç»„é…ç½®
    if (!this.searchRootConfigs.rootGroups) {
      this.searchRootConfigs.rootGroups = {};
    }
    
    // ä½¿ç”¨å¢å¼ºçš„é€‰æ‹©å¯¹è¯æ¡†ï¼ˆå¸¦ç¾¤ç»„åŠŸèƒ½ï¼‰
    return new Promise((resolve) => {
      this.showEnhancedRootMultiSelectDialog(currentRootIds, allRoots, resolve);
    });
  }
  
  /**
   * æ˜¾ç¤ºæ ¹ç›®å½•é€‰æ‹©å¯¹è¯æ¡†ï¼ˆæ”¯æŒå¤šé€‰ï¼‰- ä¿ç•™åŸæœ‰å‡½æ•°ä»¥å…¼å®¹
   * @param {string|Array} currentRootIds - å½“å‰é€‰ä¸­çš„æ ¹ç›®å½•IDï¼ˆå•ä¸ªæˆ–å¤šä¸ªï¼‰
   * @param {Object} allRoots - æ‰€æœ‰æ ¹ç›®å½•
   * @returns {Promise<Array>} è¿”å›é€‰ä¸­çš„æ ¹ç›®å½•IDæ•°ç»„
   */
  static async showRootSelection(currentRootIds, allRoots) {
    // ç¡®ä¿ currentRootIds æ˜¯æ•°ç»„
    if (!Array.isArray(currentRootIds)) {
      currentRootIds = currentRootIds ? [currentRootIds] : [];
    }
    
    // ä½¿ç”¨ rootsOrder æ•°ç»„çš„é¡ºåºï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ Object.keys
    this.initSearchConfig();
    const rootsOrder = this.searchRootConfigs.rootsOrder || Object.keys(allRoots);
    
    // æ„å»ºæ ¹ç›®å½•é€‰é¡¹æ•°ç»„
    const rootOptions = [];
    const rootKeys = [];
    
    // æ·»åŠ ä¸´æ—¶æ ¹ç›®å½•é€‰é¡¹
    rootOptions.push({
      key: "__current__",
      name: "ğŸ“ å½“å‰é€‰ä¸­çš„å¡ç‰‡ï¼ˆä¸´æ—¶ï¼‰",
      id: null
    });
    
    // æ·»åŠ é…ç½®ä¸­çš„æ ¹ç›®å½•
    for (const key of rootsOrder) {
      const root = allRoots[key];
      if (root) {
        rootOptions.push({
          key: key,
          name: root.name,
          id: root.id
        });
      }
    }
    
    // åˆå§‹åŒ–é€‰ä¸­çŠ¶æ€
    const selectedIndices = new Set();
    for (let i = 0; i < rootOptions.length; i++) {
      const option = rootOptions[i];
      if (option.key === "__current__") {
        // æ£€æŸ¥ä¸´æ—¶æ ¹ç›®å½•æ˜¯å¦è¢«é€‰ä¸­
        if (this.tempRootInfo && currentRootIds.includes(this.tempRootInfo.id)) {
          selectedIndices.add(i);
        }
      } else {
        // æ£€æŸ¥é…ç½®ä¸­çš„æ ¹ç›®å½•æ˜¯å¦è¢«é€‰ä¸­
        if (currentRootIds.includes(option.id)) {
          selectedIndices.add(i);
        }
      }
    }
    
    // ä½¿ç”¨PromiseåŒ…è£…å¼‚æ­¥æ“ä½œ
    return new Promise((resolve) => {
      this.showRootMultiSelectDialog(rootOptions, selectedIndices, resolve);
    });
  }
  
  /**
   * æ˜¾ç¤ºå¢å¼ºçš„æ ¹ç›®å½•å¤šé€‰å¯¹è¯æ¡†ï¼ˆå¸¦ç¾¤ç»„åŠŸèƒ½ï¼‰
   * @param {Array} currentRootIds - å½“å‰é€‰ä¸­çš„æ ¹ç›®å½•IDæ•°ç»„
   * @param {Object} allRoots - æ‰€æœ‰æ ¹ç›®å½•
   * @param {Function} finalCallback - æœ€ç»ˆå›è°ƒå‡½æ•°
   */
  static showEnhancedRootMultiSelectDialog(currentRootIds, allRoots, finalCallback) {
    // æ„å»ºæ˜¾ç¤ºé€‰é¡¹
    const displayOptions = [];
    
    // 1. ç¡®å®šæŒ‰é’®æ”¾åœ¨æœ€å‰é¢
    displayOptions.push("âœ… ç¡®å®šé€‰æ‹©");
    displayOptions.push("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    
    // 2. å¿«é€Ÿç¾¤ç»„åŒºåŸŸ
    const groups = this.searchRootConfigs.rootGroups || {};
    const groupNames = Object.keys(groups).sort((a, b) => {
      const orderA = groups[a].order || 999;
      const orderB = groups[b].order || 999;
      return orderA - orderB;
    });
    
    if (groupNames.length > 0) {
      displayOptions.push("â”â”â” å¿«é€Ÿç¾¤ç»„ â”â”â”");
      for (const groupName of groupNames) {
        const group = groups[groupName];
        const icon = group.icon || "âš¡";
        displayOptions.push(`${icon} ${groupName}`);
      }
      displayOptions.push("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    }
    
    // 3. ç¾¤ç»„ç®¡ç†æŒ‰é’®
    displayOptions.push("ğŸ’¾ ä¿å­˜å½“å‰é€‰æ‹©ä¸ºç¾¤ç»„");
    displayOptions.push("ğŸ“ ç®¡ç†æ ¹ç›®å½•");
    displayOptions.push("âš™ï¸ ç®¡ç†ç¾¤ç»„");
    displayOptions.push("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    
    // 4. å•ç‹¬é€‰æ‹©åŒºåŸŸ
    displayOptions.push("â”â”â” å•ç‹¬é€‰æ‹© â”â”â”");
    
    // æ„å»ºæ ¹ç›®å½•é€‰é¡¹æ•°ç»„
    const rootsOrder = this.searchRootConfigs.rootsOrder || Object.keys(allRoots);
    const rootOptions = [];
    
    for (const key of rootsOrder) {
      const root = allRoots[key];
      if (root) {
        rootOptions.push({
          key: key,
          name: root.name,
          id: root.id
        });
      }
    }
    
    // æ£€æŸ¥å½“å‰é€‰ä¸­çŠ¶æ€
    const selectedIndices = new Set();
    for (let i = 0; i < rootOptions.length; i++) {
      if (currentRootIds.includes(rootOptions[i].id)) {
        selectedIndices.add(i);
      }
    }
    
    // æ·»åŠ å…¨é€‰/å–æ¶ˆå…¨é€‰
    const allSelected = selectedIndices.size === rootOptions.length;
    displayOptions.push(allSelected ? "â¬œ å–æ¶ˆå…¨é€‰" : "â˜‘ï¸ å…¨é€‰");
    
    // æ·»åŠ å„ä¸ªæ ¹ç›®å½•é€‰é¡¹
    for (let i = 0; i < rootOptions.length; i++) {
      const option = rootOptions[i];
      const isSelected = selectedIndices.has(i);
      const prefix = isSelected ? "âœ… " : "";
      displayOptions.push(prefix + option.name);
    }
    
    // æ„å»ºæç¤ºä¿¡æ¯
    const currentRootNames = this.getCurrentRootNames(currentRootIds, allRoots);
    let message = `å·²é€‰ä¸­ ${currentRootIds.length} ä¸ªæ ¹ç›®å½•`;
    if (currentRootIds.length > 0 && currentRootIds.length <= 3) {
      message += `:\n${currentRootNames}`;
    } else if (currentRootIds.length > 3) {
      const firstThree = currentRootNames.split(", ").slice(0, 3).join(", ");
      message += `:\n${firstThree} ç­‰`;
    }
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©æœç´¢æ ¹ç›®å½•",
      message,
      0,
      "å–æ¶ˆ",
      displayOptions,
      async (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          finalCallback([]); // å–æ¶ˆ
          return;
        }
        
        const selection = buttonIndex - 1;
        
        // å¤„ç†ç¡®å®šé€‰æ‹©
        if (selection === 0) {
          // è¿”å›å½“å‰é€‰ä¸­çš„æ ¹ç›®å½•ID
          const selectedRootIds = [];
          for (let i = 0; i < rootOptions.length; i++) {
            if (selectedIndices.has(i)) {
              selectedRootIds.push(rootOptions[i].id);
            }
          }
          finalCallback(selectedRootIds);
          return;
        }
        
        let currentIndex = 1; // è·³è¿‡ç¡®å®šæŒ‰é’®
        currentIndex++; // è·³è¿‡åˆ†éš”çº¿
        
        // å¤„ç†ç¾¤ç»„é€‰æ‹©
        if (groupNames.length > 0) {
          currentIndex++; // è·³è¿‡"å¿«é€Ÿç¾¤ç»„"æ ‡é¢˜
          
          for (const groupName of groupNames) {
            if (selection === currentIndex) {
              // åˆ‡æ¢ç¾¤ç»„é€‰æ‹©çŠ¶æ€
              const group = groups[groupName];
              const groupRootIds = [];
              
              // 1. è·å–ç¾¤ç»„å†…çš„æ‰€æœ‰æ ¹ç›®å½•ID
              for (const rootKey of group.roots) {
                const root = allRoots[rootKey];
                if (root) {
                  groupRootIds.push(root.id);
                }
              }
              
              // 2. æ£€æŸ¥ç¾¤ç»„å†…æ ¹ç›®å½•çš„é€‰ä¸­çŠ¶æ€
              let allSelected = true;
              let anySelected = false;
              
              for (const rootId of groupRootIds) {
                if (currentRootIds.includes(rootId)) {
                  anySelected = true;
                } else {
                  allSelected = false;
                }
              }
              
              // 3. æ ¹æ®çŠ¶æ€å†³å®šæ“ä½œ
              let newRootIds = [...currentRootIds]; // å¤åˆ¶å½“å‰é€‰æ‹©
              
              if (allSelected && anySelected) {
                // æƒ…å†µ1ï¼šå…¨éƒ¨å·²é€‰ä¸­ â†’ å–æ¶ˆé€‰ä¸­ç¾¤ç»„å†…çš„æ ¹ç›®å½•
                newRootIds = currentRootIds.filter(id => !groupRootIds.includes(id));
                MNUtil.showHUD(`âŒ å·²å–æ¶ˆç¾¤ç»„ï¼š${groupName}`);
              } else {
                // æƒ…å†µ2ï¼šéƒ¨åˆ†æˆ–éƒ½æœªé€‰ä¸­ â†’ é€‰ä¸­ç¾¤ç»„å†…æ‰€æœ‰æ ¹ç›®å½•
                for (const rootId of groupRootIds) {
                  if (!newRootIds.includes(rootId)) {
                    newRootIds.push(rootId);
                  }
                }
                MNUtil.showHUD(`âœ… å·²åº”ç”¨ç¾¤ç»„ï¼š${groupName}`);
              }
              
              // 4. æ›´æ–°æœ€åä½¿ç”¨çš„ç¾¤ç»„å’Œé…ç½®
              this.searchRootConfigs.lastUsedGroup = groupName;
              groups[groupName].lastUsed = new Date().toISOString();
              this.saveSearchConfig();
              
              // é€’å½’è°ƒç”¨ï¼Œæ˜¾ç¤ºæ›´æ–°åçš„çŠ¶æ€
              this.showEnhancedRootMultiSelectDialog(newRootIds, allRoots, finalCallback);
              return;
            }
            currentIndex++;
          }
          currentIndex++; // è·³è¿‡åˆ†éš”çº¿
        }
        
        // å¤„ç†ä¿å­˜ç¾¤ç»„
        if (selection === currentIndex) {
          if (currentRootIds.length === 0) {
            MNUtil.showHUD("è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸€ä¸ªæ ¹ç›®å½•");
            this.showEnhancedRootMultiSelectDialog(currentRootIds, allRoots, finalCallback);
            return;
          }
          
          // ä¿å­˜å½“å‰é€‰æ‹©ä¸ºç¾¤ç»„
          await this.saveCurrentSelectionAsGroup(currentRootIds, allRoots);
          
          // é‡æ–°æ˜¾ç¤ºå¯¹è¯æ¡†
          this.showEnhancedRootMultiSelectDialog(currentRootIds, allRoots, finalCallback);
          return;
        }
        currentIndex++;
        
        // å¤„ç†ç®¡ç†æ ¹ç›®å½•
        if (selection === currentIndex) {
          await this.showRootManagementDialog().then(() => {
            // åˆ·æ–°æ‰€æœ‰æ ¹ç›®å½•é…ç½®
            const updatedRoots = this.getAllSearchRoots();
            // é‡æ–°æ˜¾ç¤ºå¯¹è¯æ¡†
            this.showEnhancedRootMultiSelectDialog(currentRootIds, updatedRoots, finalCallback);
          });
          return;
        }
        currentIndex++;
        
        // å¤„ç†ç®¡ç†ç¾¤ç»„
        if (selection === currentIndex) {
          await this.manageRootGroups();
          // é‡æ–°æ˜¾ç¤ºå¯¹è¯æ¡†
          this.showEnhancedRootMultiSelectDialog(currentRootIds, allRoots, finalCallback);
          return;
        }
        currentIndex++;
        currentIndex++; // è·³è¿‡åˆ†éš”çº¿
        currentIndex++; // è·³è¿‡"å•ç‹¬é€‰æ‹©"æ ‡é¢˜
        
        // å¤„ç†å…¨é€‰/å–æ¶ˆå…¨é€‰
        if (selection === currentIndex) {
          if (allSelected) {
            selectedIndices.clear();
            currentRootIds = [];
          } else {
            selectedIndices.clear();
            currentRootIds = [];
            for (let i = 0; i < rootOptions.length; i++) {
              selectedIndices.add(i);
              currentRootIds.push(rootOptions[i].id);
            }
          }
          // é€’å½’è°ƒç”¨
          this.showEnhancedRootMultiSelectDialog(currentRootIds, allRoots, finalCallback);
          return;
        }
        currentIndex++;
        
        // å¤„ç†å•ä¸ªæ ¹ç›®å½•é€‰æ‹©
        const rootIndex = selection - currentIndex;
        if (rootIndex >= 0 && rootIndex < rootOptions.length) {
          const rootId = rootOptions[rootIndex].id;
          const idx = currentRootIds.indexOf(rootId);
          
          if (idx >= 0) {
            // å–æ¶ˆé€‰ä¸­
            currentRootIds.splice(idx, 1);
            selectedIndices.delete(rootIndex);
          } else {
            // é€‰ä¸­
            currentRootIds.push(rootId);
            selectedIndices.add(rootIndex);
          }
          
          // é€’å½’è°ƒç”¨
          this.showEnhancedRootMultiSelectDialog(currentRootIds, allRoots, finalCallback);
        }
      }
    );
  }

  /**
   * æ˜¾ç¤ºæ ¹ç›®å½•å¤šé€‰å¯¹è¯æ¡†ï¼ˆé€’å½’å®ç°ï¼‰- ä¿ç•™åŸæœ‰å‡½æ•°
   * @param {Array} rootOptions - æ ¹ç›®å½•é€‰é¡¹æ•°ç»„
   * @param {Set} selectedIndices - å·²é€‰ä¸­çš„ç´¢å¼•é›†åˆ
   * @param {Function} finalCallback - æœ€ç»ˆå›è°ƒå‡½æ•°
   */
  static showRootMultiSelectDialog(rootOptions, selectedIndices, finalCallback) {
    // æ„å»ºæ˜¾ç¤ºé€‰é¡¹
    const displayOptions = [];
    
    // æ·»åŠ ä¸´æ—¶æ ¹ç›®å½•é€‰é¡¹
    displayOptions.push("ğŸ“ ä½¿ç”¨å½“å‰é€‰ä¸­çš„å¡ç‰‡ï¼ˆä¸´æ—¶ï¼‰");
    
    // æ·»åŠ å…¨é€‰/å–æ¶ˆå…¨é€‰é€‰é¡¹
    const allSelected = selectedIndices.size === rootOptions.length;
    displayOptions.push(allSelected ? "â¬œ å–æ¶ˆå…¨é€‰" : "â˜‘ï¸ å…¨é€‰æ‰€æœ‰æ ¹ç›®å½•");
    
    // æ·»åŠ åˆ†éš”çº¿
    displayOptions.push("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    
    // æ·»åŠ å„ä¸ªæ ¹ç›®å½•é€‰é¡¹
    for (let i = 0; i < rootOptions.length; i++) {
      const option = rootOptions[i];
      const isSelected = selectedIndices.has(i);
      const prefix = isSelected ? "âœ… " : "";
      displayOptions.push(prefix + option.name);
    }
    
    // æ·»åŠ åˆ†éš”çº¿å’Œæ“ä½œæŒ‰é’®
    displayOptions.push("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    displayOptions.push("ğŸ“ ç®¡ç†æ ¹ç›®å½•");
    displayOptions.push("âœ”ï¸ ç¡®å®šé€‰æ‹©");
    
    // æ„å»ºæç¤ºä¿¡æ¯
    const message = `å·²é€‰ä¸­ ${selectedIndices.size}/${rootOptions.length} ä¸ªæ ¹ç›®å½•\n\nğŸ’¡ æç¤ºï¼šç‚¹å‡»æ ¹ç›®å½•åˆ‡æ¢é€‰ä¸­çŠ¶æ€`;
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©æœç´¢æ ¹ç›®å½•",
      message,
      0,  // æ ·å¼
      "å–æ¶ˆ",
      displayOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) {
          // ç”¨æˆ·ç‚¹å‡»å–æ¶ˆ
          finalCallback([]);
          return;
        }
        
        const selectedOptionIndex = buttonIndex - 1;
        
        if (selectedOptionIndex === 0) {
          // ä¸´æ—¶æ ¹ç›®å½•
          const currentNote = MNNote.getFocusNote();
          if (currentNote) {
            // ä¿å­˜ä¸´æ—¶æ ¹ç›®å½•ä¿¡æ¯
            this.tempRootInfo = {
              id: currentNote.noteId,
              name: currentNote.noteTitle || "æ— æ ‡é¢˜"
            };
            
            // æ¸…ç©ºæ‰€æœ‰é€‰æ‹©ï¼Œåªé€‰ä¸­ä¸´æ—¶æ ¹ç›®å½•
            const tempRootIds = [currentNote.noteId];
            finalCallback(tempRootIds);
          } else {
            MNUtil.showHUD("è¯·å…ˆé€‰ä¸­ä¸€ä¸ªå¡ç‰‡ä½œä¸ºä¸´æ—¶æ ¹ç›®å½•");
            // é‡æ–°æ˜¾ç¤ºå¯¹è¯æ¡†
            this.showRootMultiSelectDialog(rootOptions, selectedIndices, finalCallback);
          }
          return;
          
        } else if (selectedOptionIndex === 1) {
          // å…¨é€‰/å–æ¶ˆå…¨é€‰
          if (allSelected) {
            selectedIndices.clear();
          } else {
            for (let i = 0; i < rootOptions.length; i++) {
              selectedIndices.add(i);
            }
          }
          // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
          this.showRootMultiSelectDialog(rootOptions, selectedIndices, finalCallback);
          
        } else if (selectedOptionIndex === 2 || selectedOptionIndex === displayOptions.length - 3) {
          // åˆ†éš”çº¿ï¼Œå¿½ç•¥å¹¶é‡æ–°æ˜¾ç¤º
          this.showRootMultiSelectDialog(rootOptions, selectedIndices, finalCallback);
          
        } else if (selectedOptionIndex === displayOptions.length - 2) {
          // ç®¡ç†æ ¹ç›®å½•
          this.showRootManagementDialog().then((manageResult) => {
            if (manageResult) {
              // å¦‚æœè¿›è¡Œäº†ä¿®æ”¹ï¼Œé‡æ–°æ„å»ºé€‰é¡¹åˆ—è¡¨
              const updatedRoots = this.getAllSearchRoots();
              const rootsOrder = this.searchRootConfigs.rootsOrder || Object.keys(updatedRoots);
              const updatedOptions = [];
              
              // é‡å»ºé€‰é¡¹æ•°ç»„
              for (const key of rootsOrder) {
                const root = updatedRoots[key];
                if (root) {
                  updatedOptions.push({
                    key: key,
                    name: root.name,
                    id: root.id
                  });
                }
              }
              
              // æ›´æ–°é€‰ä¸­çŠ¶æ€ä»¥åŒ¹é…æ–°çš„é€‰é¡¹åˆ—è¡¨
              const newSelectedIndices = new Set();
              for (let i = 0; i < updatedOptions.length; i++) {
                // æ£€æŸ¥ä¹‹å‰é€‰ä¸­çš„æ ¹ç›®å½•æ˜¯å¦è¿˜å­˜åœ¨
                const option = updatedOptions[i];
                for (const oldIndex of selectedIndices) {
                  if (oldIndex < rootOptions.length && 
                      rootOptions[oldIndex].id === option.id) {
                    newSelectedIndices.add(i);
                    break;
                  }
                }
              }
              
              // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
              this.showRootMultiSelectDialog(updatedOptions, newSelectedIndices, finalCallback);
            } else {
              // æ²¡æœ‰ä¿®æ”¹ï¼Œé‡æ–°æ˜¾ç¤ºåŸå¯¹è¯æ¡†
              this.showRootMultiSelectDialog(rootOptions, selectedIndices, finalCallback);
            }
          });
          
        } else if (selectedOptionIndex === displayOptions.length - 1) {
          // ç¡®å®šé€‰æ‹©
          const selectedRootIds = [];
          const selectedRootKeys = [];
          
          for (const index of selectedIndices) {
            const option = rootOptions[index];
            
            if (option.key === "__current__") {
              // å¤„ç†ä¸´æ—¶æ ¹ç›®å½•
              const currentNote = MNNote.getFocusNote();
              if (currentNote) {
                // ä¿å­˜ä¸´æ—¶æ ¹ç›®å½•ä¿¡æ¯
                this.tempRootInfo = {
                  id: currentNote.noteId,
                  name: currentNote.noteTitle || "æ— æ ‡é¢˜"
                };
                selectedRootIds.push(currentNote.noteId);
              } else {
                MNUtil.showHUD("è¯·å…ˆé€‰ä¸­ä¸€ä¸ªå¡ç‰‡ä½œä¸ºä¸´æ—¶æ ¹ç›®å½•");
                // é‡æ–°æ˜¾ç¤ºå¯¹è¯æ¡†
                this.showRootMultiSelectDialog(rootOptions, selectedIndices, finalCallback);
                return;
              }
            } else {
              // ä½¿ç”¨é…ç½®ä¸­çš„æ ¹ç›®å½•
              selectedRootIds.push(option.id);
              selectedRootKeys.push(option.key);
            }
          }
          
          // ä¿å­˜æœ€åä½¿ç”¨çš„æ ¹ç›®å½•ï¼ˆå¤šä¸ªï¼‰
          if (selectedRootKeys.length > 0) {
            this.searchRootConfigs.lastUsedRoots = selectedRootKeys;
            this.saveSearchConfig();
          }
          
          // è¿”å›ç»“æœ
          finalCallback(selectedRootIds);
          
        } else {
          // ç”¨æˆ·ç‚¹å‡»äº†æŸä¸ªæ ¹ç›®å½•é€‰é¡¹
          const rootIndex = selectedOptionIndex - 3;  // å‡å»ä¸´æ—¶æ ¹ç›®å½•ã€å…¨é€‰å’Œåˆ†éš”çº¿
          
          if (rootIndex >= 0 && rootIndex < rootOptions.length) {
            // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
            if (selectedIndices.has(rootIndex)) {
              selectedIndices.delete(rootIndex);
            } else {
              selectedIndices.add(rootIndex);
            }
          }
          
          // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
          this.showRootMultiSelectDialog(rootOptions, selectedIndices, finalCallback);
        }
      }
    );
  }
  
  /**
   * ä¿å­˜å½“å‰é€‰æ‹©ä¸ºç¾¤ç»„
   * @param {Array} currentRootIds - å½“å‰é€‰ä¸­çš„æ ¹ç›®å½•IDæ•°ç»„
   * @param {Object} allRoots - æ‰€æœ‰æ ¹ç›®å½•é…ç½®
   */
  static async saveCurrentSelectionAsGroup(currentRootIds, allRoots) {
    // è·å–ç¾¤ç»„åç§°
    const result = await MNUtil.input(
      "ä¿å­˜ç¾¤ç»„",
      "è¯·è¾“å…¥ç¾¤ç»„åç§°ï¼š",
      ["å–æ¶ˆ", "ç¡®å®š"]
    );
    
    if (!result || result.button !== 1 || !result.input || result.input.trim() === "") {
      return;
    }
    
    const groupName = result.input.trim();
    
    // æ£€æŸ¥ç¾¤ç»„æ˜¯å¦å·²å­˜åœ¨
    if (!this.searchRootConfigs.rootGroups) {
      this.searchRootConfigs.rootGroups = {};
    }
    
    if (this.searchRootConfigs.rootGroups[groupName]) {
      const confirm = await MNUtil.confirm(
        "ç¾¤ç»„å·²å­˜åœ¨",
        `ç¾¤ç»„"${groupName}"å·²å­˜åœ¨ï¼Œæ˜¯å¦æ›¿æ¢ï¼Ÿ`,
        ["å–æ¶ˆ", "æ›¿æ¢"]
      );
      if (confirm !== 1) {
        return;
      }
    }
    
    // å°†æ ¹ç›®å½•IDè½¬æ¢ä¸ºkey
    const rootKeys = [];
    for (const rootId of currentRootIds) {
      for (const key in allRoots) {
        if (allRoots[key].id === rootId) {
          rootKeys.push(key);
          break;
        }
      }
    }
    
    // åˆ›å»ºç¾¤ç»„
    const nextOrder = Object.values(this.searchRootConfigs.rootGroups).length + 1;
    this.searchRootConfigs.rootGroups[groupName] = {
      name: groupName,
      roots: rootKeys,
      icon: "âš¡",
      order: nextOrder,
      createTime: new Date().toISOString(),
      lastUsed: null
    };
    
    this.saveSearchConfig();
    MNUtil.showHUD(`âœ… å·²ä¿å­˜ç¾¤ç»„ï¼š${groupName}`);
  }
  
  /**
   * ç®¡ç†æ ¹ç›®å½•ç¾¤ç»„
   */
  static async manageRootGroups() {
    const groups = this.searchRootConfigs.rootGroups || {};
    const groupNames = Object.keys(groups).sort((a, b) => {
      const orderA = groups[a].order || 999;
      const orderB = groups[b].order || 999;
      return orderA - orderB;
    });
    
    if (groupNames.length === 0) {
      MNUtil.showHUD("æš‚æ— ä¿å­˜çš„ç¾¤ç»„");
      return;
    }
    
    const options = ["â• æ–°å»ºç¾¤ç»„"];
    for (const groupName of groupNames) {
      const group = groups[groupName];
      const icon = group.icon || "âš¡";
      const rootCount = group.roots.length;
      options.push(`${icon} ${groupName} (${rootCount}ä¸ªæ ¹ç›®å½•)`);
    }
    
    const result = await MNUtil.userSelect(
      "ç®¡ç†æ ¹ç›®å½•ç¾¤ç»„",
      "é€‰æ‹©è¦ç®¡ç†çš„ç¾¤ç»„ï¼š",
      options
    );
    
    if (result === null || result === 0) {
      return;
    }
    
    if (result === 1) {
      // æ–°å»ºç¾¤ç»„
      await this.createNewRootGroup();
    } else {
      // ç®¡ç†å·²æœ‰ç¾¤ç»„
      const groupName = groupNames[result - 2];
      await this.editRootGroup(groupName);
    }
  }
  
  /**
   * ç¼–è¾‘æ ¹ç›®å½•ç¾¤ç»„
   * @param {string} groupName - ç¾¤ç»„åç§°
   */
  static async editRootGroup(groupName) {
    const group = this.searchRootConfigs.rootGroups[groupName];
    if (!group) {
      MNUtil.showHUD("ç¾¤ç»„ä¸å­˜åœ¨");
      return;
    }
    
    const options = [
      "ğŸ“ é‡å‘½åç¾¤ç»„",
      "ğŸ”§ ç¼–è¾‘åŒ…å«çš„æ ¹ç›®å½•",
      "ğŸ¨ æ›´æ”¹å›¾æ ‡",
      "ğŸ—‘ åˆ é™¤ç¾¤ç»„"
    ];
    
    const result = await MNUtil.userSelect(
      `ç®¡ç†ç¾¤ç»„ï¼š${groupName}`,
      `åŒ…å« ${group.roots.length} ä¸ªæ ¹ç›®å½•`,
      options
    );
    
    if (result === null || result === 0) {
      return;
    }
    
    switch (result) {
      case 1: // é‡å‘½å
        await this.renameRootGroup(groupName);
        break;
      case 2: // ç¼–è¾‘åŒ…å«çš„æ ¹ç›®å½•
        await this.editGroupRoots(groupName);
        break;
      case 3: // æ›´æ”¹å›¾æ ‡
        await this.changeGroupIcon(groupName);
        break;
      case 4: // åˆ é™¤
        await this.deleteRootGroup(groupName);
        break;
    }
  }
  
  /**
   * é‡å‘½åç¾¤ç»„
   */
  static async renameRootGroup(oldName) {
    const result = await MNUtil.input(
      "é‡å‘½åç¾¤ç»„",
      `å½“å‰åç§°ï¼š${oldName}`,
      [{
        key: "name",
        hint: "æ–°çš„ç¾¤ç»„åç§°",
        value: oldName
      }]
    );
    
    if (!result || !result.name || result.name.trim() === "" || result.name === oldName) {
      return;
    }
    
    const newName = result.name.trim();
    
    if (this.searchRootConfigs.rootGroups[newName]) {
      MNUtil.showHUD("æ–°åç§°å·²è¢«ä½¿ç”¨");
      return;
    }
    
    // é‡å‘½å
    const group = this.searchRootConfigs.rootGroups[oldName];
    group.name = newName;
    this.searchRootConfigs.rootGroups[newName] = group;
    delete this.searchRootConfigs.rootGroups[oldName];
    
    // å¦‚æœæ˜¯æœ€åä½¿ç”¨çš„ç¾¤ç»„ï¼Œæ›´æ–°å¼•ç”¨
    if (this.searchRootConfigs.lastUsedGroup === oldName) {
      this.searchRootConfigs.lastUsedGroup = newName;
    }
    
    this.saveSearchConfig();
    MNUtil.showHUD(`âœ… å·²é‡å‘½åä¸ºï¼š${newName}`);
  }
  
  /**
   * æ›´æ”¹ç¾¤ç»„å›¾æ ‡
   */
  static async changeGroupIcon(groupName) {
    const group = this.searchRootConfigs.rootGroups[groupName];
    const result = await MNUtil.input(
      "æ›´æ”¹å›¾æ ‡",
      `ç¾¤ç»„ï¼š${groupName}`,
      [{
        key: "icon",
        hint: "è¾“å…¥å›¾æ ‡ï¼ˆå¦‚ï¼šâš¡ã€ğŸ“šã€ğŸ”¬ã€ğŸ¯ï¼‰",
        value: group.icon || "âš¡"
      }]
    );
    
    if (!result || !result.icon) {
      return;
    }
    
    group.icon = result.icon;
    this.saveSearchConfig();
    MNUtil.showHUD(`âœ… å›¾æ ‡å·²æ›´æ–°`);
  }
  
  /**
   * ç¼–è¾‘ç¾¤ç»„åŒ…å«çš„æ ¹ç›®å½•
   * @param {string} groupName - ç¾¤ç»„åç§°
   */
  static async editGroupRoots(groupName) {
    const group = this.searchRootConfigs.rootGroups[groupName];
    if (!group) {
      MNUtil.showHUD("ç¾¤ç»„ä¸å­˜åœ¨");
      return;
    }
    
    const allRoots = this.getAllSearchRoots();
    const rootsOrder = this.searchRootConfigs.rootsOrder || Object.keys(allRoots);
    
    // å¾ªç¯æ˜¾ç¤ºç¼–è¾‘ç•Œé¢
    while (true) {
      // æ„å»ºæ˜¾ç¤ºé€‰é¡¹
      const displayOptions = [];
      
      // 1. ç¡®å®šæŒ‰é’®åœ¨é¡¶éƒ¨
      displayOptions.push("âœ… ä¿å­˜å¹¶è¿”å›");
      displayOptions.push("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
      
      // 2. æ˜¾ç¤ºæ‰€æœ‰æ ¹ç›®å½•ï¼Œæ ‡è®°å·²åœ¨ç¾¤ç»„ä¸­çš„
      const groupRootKeys = new Set(group.roots);
      
      for (const key of rootsOrder) {
        const root = allRoots[key];
        if (root) {
          const isInGroup = groupRootKeys.has(key);
          const prefix = isInGroup ? "âœ… " : "";
          displayOptions.push(prefix + root.name);
        }
      }
      
      // æ„å»ºæç¤ºä¿¡æ¯
      const message = `å½“å‰åŒ…å« ${group.roots.length} ä¸ªæ ¹ç›®å½•\n\nğŸ’¡ ç‚¹å‡»æ ¹ç›®å½•å¯æ·»åŠ /ç§»é™¤`;
      
      const result = await MNUtil.userSelect(
        `ç¼–è¾‘ç¾¤ç»„ï¼š${groupName}`,
        message,
        displayOptions
      );
      
      // å¤„ç†ç”¨æˆ·é€‰æ‹©
      if (result === null || result === 0) {
        // ç”¨æˆ·å–æ¶ˆ
        return;
      }
      
      if (result === 1) {
        // ä¿å­˜å¹¶è¿”å›
        this.saveSearchConfig();
        MNUtil.showHUD(`âœ… ç¾¤ç»„"${groupName}"å·²æ›´æ–°`);
        return;
      }
      
      if (result === 2) {
        // åˆ†éš”çº¿ï¼Œå¿½ç•¥å¹¶ç»§ç»­å¾ªç¯
        continue;
      }
      
      // åˆ‡æ¢æ ¹ç›®å½•çš„é€‰ä¸­çŠ¶æ€
      const rootIndex = result - 3; // å‡å»"ä¿å­˜æŒ‰é’®"ã€"åˆ†éš”çº¿"å’Œæ•°ç»„åç§»
      if (rootIndex >= 0 && rootIndex < rootsOrder.length) {
        const rootKey = rootsOrder[rootIndex];
        
        if (groupRootKeys.has(rootKey)) {
          // ä»ç¾¤ç»„ä¸­ç§»é™¤
          group.roots = group.roots.filter(k => k !== rootKey);
          groupRootKeys.delete(rootKey);
          
          const rootName = allRoots[rootKey]?.name || rootKey;
          MNUtil.showHUD(`â– å·²ç§»é™¤ï¼š${rootName}`);
        } else {
          // æ·»åŠ åˆ°ç¾¤ç»„
          group.roots.push(rootKey);
          groupRootKeys.add(rootKey);
          
          const rootName = allRoots[rootKey]?.name || rootKey;
          MNUtil.showHUD(`â• å·²æ·»åŠ ï¼š${rootName}`);
        }
      }
    }
  }
  
  /**
   * åˆ é™¤ç¾¤ç»„
   */
  static async deleteRootGroup(groupName) {
    const confirm = await MNUtil.confirm(
      "åˆ é™¤ç¾¤ç»„",
      `ç¡®å®šè¦åˆ é™¤ç¾¤ç»„"${groupName}"å—ï¼Ÿ`,
      ["å–æ¶ˆ", "åˆ é™¤"]
    );
    
    if (confirm !== 1) {
      return;
    }
    
    delete this.searchRootConfigs.rootGroups[groupName];
    
    // å¦‚æœæ˜¯æœ€åä½¿ç”¨çš„ç¾¤ç»„ï¼Œæ¸…é™¤å¼•ç”¨
    if (this.searchRootConfigs.lastUsedGroup === groupName) {
      this.searchRootConfigs.lastUsedGroup = null;
    }
    
    this.saveSearchConfig();
    MNUtil.showHUD(`âœ… å·²åˆ é™¤ç¾¤ç»„ï¼š${groupName}`);
  }
  
  /**
   * åˆ›å»ºæ–°ç¾¤ç»„
   */
  static async createNewRootGroup() {
    const result = await MNUtil.input(
      "æ–°å»ºç¾¤ç»„",
      "è¯·è¾“å…¥ç¾¤ç»„ä¿¡æ¯ï¼š",
      [
        {
          key: "name",
          hint: "ç¾¤ç»„åç§°",
          value: ""
        },
        {
          key: "icon",
          hint: "å›¾æ ‡ï¼ˆå¯é€‰ï¼Œå¦‚ï¼šâš¡ã€ğŸ“šã€ğŸ”¬ï¼‰",
          value: "âš¡"
        }
      ]
    );
    
    if (!result || !result.name || result.name.trim() === "") {
      return;
    }
    
    const groupName = result.name.trim();
    const icon = result.icon || "âš¡";
    
    if (!this.searchRootConfigs.rootGroups) {
      this.searchRootConfigs.rootGroups = {};
    }
    
    if (this.searchRootConfigs.rootGroups[groupName]) {
      MNUtil.showHUD("ç¾¤ç»„å·²å­˜åœ¨");
      return;
    }
    
    const nextOrder = Object.values(this.searchRootConfigs.rootGroups).length + 1;
    this.searchRootConfigs.rootGroups[groupName] = {
      name: groupName,
      roots: [],
      icon: icon,
      order: nextOrder,
      createTime: new Date().toISOString(),
      lastUsed: null
    };
    
    this.saveSearchConfig();
    MNUtil.showHUD(`âœ… å·²åˆ›å»ºç¾¤ç»„ï¼š${groupName}`);
  }
  
  /**
   * æ·»åŠ å½“å‰å¡ç‰‡ä½œä¸ºæ ¹ç›®å½•
   * @param {MNNote} note - è¦æ·»åŠ çš„å¡ç‰‡
   */
  static async addCurrentNoteAsRoot(note) {
    const noteId = note.noteId;
    const noteTitle = note.noteTitle || "æ— æ ‡é¢˜";
    
    // ç”Ÿæˆå”¯ä¸€çš„key
    let key = noteTitle.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, "_");
    let counter = 1;
    while (this.searchRootConfigs.roots[key]) {
      key = `${noteTitle}_${counter}`;
      counter++;
    }
    
    // æ·»åŠ åˆ°é…ç½®
    this.searchRootConfigs.roots[key] = {
      name: noteTitle,
      id: noteId,
      skipEmptyTitleByDefault: false
    };
    
    // æ·»åŠ åˆ°é¡ºåºæ•°ç»„
    if (!this.searchRootConfigs.rootsOrder) {
      this.searchRootConfigs.rootsOrder = [];
    }
    this.searchRootConfigs.rootsOrder.push(key);
    
    this.saveSearchConfig();
    
    return {
      key: key,
      name: noteTitle,
      id: noteId
    };
  }

  /**
   * å¤„ç†æ·»åŠ æ ¹ç›®å½•
   */
  static async handleAddRoot(input) {
    if (input) {
      // ç”¨æˆ·è¾“å…¥äº† ID æˆ– URLï¼Œè¯·æ±‚è¾“å…¥åç§°
      return await new Promise((resolve) => {
        UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
          "æ·»åŠ æ ¹ç›®å½•",
          "è¯·è¾“å…¥æ ¹ç›®å½•çš„åç§°",
          2,
          "å–æ¶ˆ",
          ["ç¡®å®š"],
          (alert, buttonIndex) => {
            if (buttonIndex === 1) {
              const name = alert.textFieldAtIndex(0).text.trim();
              if (name) {
                const key = this.addSearchRoot(input, name);
                if (key && key !== false) {
                  // è¿”å›æ–°æ·»åŠ çš„æ ¹ç›®å½•ä¿¡æ¯
                  resolve({
                    key: key,
                    id: this.searchRootConfigs.roots[key].id,
                    name: name
                  });
                  return;
                }
              }
            }
            resolve(null);
          }
        );
      });
    } else {
      // è¾“å…¥ä¸ºç©ºæ—¶ï¼Œæä¾›é€‰é¡¹è®©ç”¨æˆ·é€‰æ‹©
      return await new Promise((resolve) => {
        UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
          "æ·»åŠ æœç´¢æ ¹ç›®å½•",
          "è¯·é€‰æ‹©æ·»åŠ æ–¹å¼",
          0,
          "å–æ¶ˆ",
          ["ğŸ“ ä½¿ç”¨å½“å‰é€‰ä¸­çš„å¡ç‰‡", "ğŸ“ æ‰‹åŠ¨è¾“å…¥å¡ç‰‡ ID/URL"],
          async (alert, buttonIndex) => {
            if (buttonIndex === 1) {
              // ä½¿ç”¨å½“å‰é€‰ä¸­çš„å¡ç‰‡
              const currentNote = MNNote.getFocusNote();
              if (currentNote) {
                // è·å–å¡ç‰‡æ ‡é¢˜ä½œä¸ºé»˜è®¤åç§°
                const defaultName = currentNote.noteTitle || "æœªå‘½åæ ¹ç›®å½•";
                
                // è¯·æ±‚ç”¨æˆ·è¾“å…¥æˆ–ç¡®è®¤åç§°
                const result = await new Promise((innerResolve) => {
                  UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
                    "æ·»åŠ æ ¹ç›®å½•",
                    `å½“å‰é€‰ä¸­çš„å¡ç‰‡ï¼š${defaultName}\n\nè¯·è¾“å…¥æ ¹ç›®å½•çš„åç§°ï¼ˆæˆ–ä½¿ç”¨é»˜è®¤åç§°ï¼‰`,
                    2,
                    "å–æ¶ˆ",
                    ["ç¡®å®š"],
                    (alert2, buttonIndex2) => {
                      if (buttonIndex2 === 1) {
                        const name = alert2.textFieldAtIndex(0).text.trim() || defaultName;
                        const key = this.addSearchRoot(currentNote.noteId, name);
                        if (key && key !== false) {
                          innerResolve({
                            key: key,
                            id: this.searchRootConfigs.roots[key].id,
                            name: name
                          });
                          return;
                        }
                      }
                      innerResolve(null);
                    }
                  );
                  // æ³¨é‡Šæ‰é¢„å¡«å……ä»¥é¿å…åªè¯»å±æ€§é”™è¯¯
                  // const textField = UIAlertView.currentAlertView().textFieldAtIndex(0);
                  // textField.text = defaultName;
                });
                resolve(result);
              } else {
                MNUtil.showHUD("è¯·å…ˆé€‰ä¸­ä¸€ä¸ªå¡ç‰‡");
                resolve(null);
              }
            } else if (buttonIndex === 2) {
              // æ‰‹åŠ¨è¾“å…¥ ID/URL
              const inputResult = await new Promise((innerResolve) => {
                UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
                  "æ‰‹åŠ¨è¾“å…¥",
                  "è¯·è¾“å…¥å¡ç‰‡ ID æˆ– URL",
                  2,
                  "å–æ¶ˆ",
                  ["ä¸‹ä¸€æ­¥"],
                  async (alert2, buttonIndex2) => {
                    if (buttonIndex2 === 1) {
                      const idOrUrl = alert2.textFieldAtIndex(0).text.trim();
                      if (idOrUrl) {
                        // è°ƒç”¨åŸæ¥çš„é€»è¾‘å¤„ç†è¾“å…¥çš„ ID/URL
                        const result = await this.handleAddRoot(idOrUrl);
                        innerResolve(result);
                      } else {
                        MNUtil.showHUD("è¯·è¾“å…¥æœ‰æ•ˆçš„å¡ç‰‡ ID æˆ– URL");
                        innerResolve(null);
                      }
                    } else {
                      innerResolve(null);
                    }
                  }
                );
              });
              resolve(inputResult);
            } else {
              resolve(null);
            }
          }
        );
      });
    }
  }
  
  /**
   * åˆ›å»ºæœç´¢ç»“æœå¡ç‰‡
   * @param {Array<MNNote>} results - æœç´¢ç»“æœ
   * @param {Array<string>} keywords - æœç´¢å…³é”®è¯
   * @param {string} rootName - æ ¹ç›®å½•åç§°
   */
  static createSearchResultCard(results, keywords, rootName) {
    try {
      // è·å–æœç´¢çœ‹æ¿
      const boardNote = MNNote.new(this.searchBoardId, false);
      if (!boardNote) {
        MNUtil.showHUD("æœç´¢çœ‹æ¿ä¸å­˜åœ¨");
        return null;
      }
      
      // åˆ›å»ºç»“æœå¡ç‰‡
      const resultCard = boardNote.createChildNote({
        title: `æœç´¢ï¼š${keywords.join(" AND ")}`,
        excerptText: ""
      });
      
      // æ·»åŠ æœç´¢ä¿¡æ¯
      resultCard.appendTextComment(`ğŸ“‘ æœç´¢ç»“æœï¼š${keywords.join(" AND ")}`);
      resultCard.appendTextComment(`ğŸ“ æ ¹ç›®å½•ï¼š${rootName}`);
      resultCard.appendTextComment(`â° æœç´¢æ—¶é—´ï¼š${new Date().toLocaleString('zh-CN')}`);
      resultCard.appendTextComment(`ğŸ“Š ç»“æœæ•°é‡ï¼š${results.length} ä¸ª`);
      resultCard.appendTextComment("");  // ç©ºè¡Œ
      
      // æŒ‰ç±»å‹åˆ†ç»„
      const groupedResults = {};
      
      for (const note of results) {
        // ä½¿ç”¨ getNoteType è·å–æ­£ç¡®çš„å¡ç‰‡ç±»å‹
        const type = this.getNoteType(note) || "å…¶ä»–";
        
        if (!groupedResults[type]) {
          groupedResults[type] = [];
        }
        groupedResults[type].push(note);
      }
      
      // å®šä¹‰ç±»å‹é¡ºåºå’Œå›¾æ ‡
      const typeOrder = {
        "å®šä¹‰": "ğŸ“˜",
        "å‘½é¢˜": "ğŸ“™",
        "ä¾‹å­": "ğŸ“—",
        "åä¾‹": "ğŸ“•",
        "å½’ç±»": "ğŸ“‘",
        "æ€æƒ³æ–¹æ³•": "ğŸ’¡",
        "é—®é¢˜": "â“",
        "å…¶ä»–": "ğŸ”–"
      };
      
      // æŒ‰é¡ºåºæ·»åŠ åˆ†ç»„ç»“æœ
      for (const [type, icon] of Object.entries(typeOrder)) {
        if (groupedResults[type] && groupedResults[type].length > 0) {
          // æ·»åŠ åˆ†ç»„æ ‡é¢˜ï¼ˆä½¿ç”¨ç®€å•çš„ Markdown æ ¼å¼ï¼‰
          const groupTitle = `${icon} ${type}ï¼ˆ${groupedResults[type].length}ä¸ªï¼‰`;
          resultCard.appendMarkdownComment(`---`);  // åˆ†éš”çº¿
          resultCard.appendMarkdownComment(`**${groupTitle}**`);  // ç²—ä½“æ ‡é¢˜
          
          // æ·»åŠ è¯¥ç»„çš„é“¾æ¥
          for (const note of groupedResults[type]) {
            // å»ºç«‹ä»ç»“æœå¡ç‰‡åˆ°æœç´¢ç»“æœçš„å•å‘é“¾æ¥
            // ä½¿ç”¨ "To" ç±»å‹ï¼Œåœ¨ç»“æœå¡ç‰‡ä¸­æ·»åŠ æŒ‡å‘æœç´¢ç»“æœçš„é“¾æ¥
            resultCard.appendNoteLink(note, "To");
          }
        }
      }
      
      // èšç„¦åˆ°ç»“æœå¡ç‰‡
      resultCard.focusInFloatMindMap(0.5);
      
      return resultCard;
    } catch (error) {
      MNUtil.log("åˆ›å»ºæœç´¢ç»“æœå¡ç‰‡å¤±è´¥: " + error.toString());
      MNUtil.addErrorLog(error, "createSearchResultCard");
      return null;
    }
  }

  static showSearchBoard() {
    const boardNote = MNNote.new(this.searchBoardId, false);
    if (!boardNote) {
      MNUtil.showHUD("æœç´¢çœ‹æ¿ä¸å­˜åœ¨");
      return null;
    }

    if (boardNote.childNotes.length === 0) {
      boardNote.focusInFloatMindMap(0.3)
    } else {
      // å¦‚æœæœ‰å­å¡ç‰‡ï¼Œèšç„¦åˆ°æœ€åä¸€å¼ å­å¡ç‰‡
      const lastChild = boardNote.childNotes[boardNote.childNotes.length - 1];
      lastChild.focusInFloatMindMap(0.5);
    }
  }

  /**
   * é…ç½®æœç´¢æ¨¡å¼
   */
  static async configureSearchMode() {
    try {
      while (true) {
        // è·å–å½“å‰é…ç½®
        const config = this.getSearchConfig();
        const modeNames = {
          exact: "ç²¾ç¡®æœç´¢",
          synonym: "åŒä¹‰è¯æ‰©å±•",
          exclude: "æ’é™¤è¯è¿‡æ»¤",
          full: "å®Œæ•´æ¨¡å¼"
        };
        
        const currentMode = modeNames[config.mode] || "ç²¾ç¡®æœç´¢";
        
        // æ˜¾ç¤ºé€‰é¡¹
        const options = [
          `å½“å‰æ¨¡å¼: ${currentMode}`,
          "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
          config.mode === 'exact' ? "âœ… ç²¾ç¡®æœç´¢ï¼ˆæœ€å¿«ï¼‰" : "âš¡ ç²¾ç¡®æœç´¢ï¼ˆæœ€å¿«ï¼‰",
          config.mode === 'synonym' ? "âœ… åŒä¹‰è¯æ‰©å±•" : "ğŸ”„ åŒä¹‰è¯æ‰©å±•",
          config.mode === 'exclude' ? "âœ… æ’é™¤è¯è¿‡æ»¤" : "ğŸš« æ’é™¤è¯è¿‡æ»¤",
          config.mode === 'full' ? "âœ… å®Œæ•´æ¨¡å¼ï¼ˆåŒä¹‰è¯+æ’é™¤è¯ï¼‰" : "ğŸ”¥ å®Œæ•´æ¨¡å¼ï¼ˆåŒä¹‰è¯+æ’é™¤è¯ï¼‰",
          "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
          "â„¹ï¸ æŸ¥çœ‹æ¨¡å¼è¯´æ˜"
        ];
        
        const choice = await MNUtil.userSelect(
          "æœç´¢æ¨¡å¼è®¾ç½®",
          "",
          options,
        );
        
        if (choice === 0) break;  // å–æ¶ˆ
        
        // å¤„ç†é€‰æ‹©
        if (choice === 3) {  // ç²¾ç¡®æœç´¢
          this.saveSearchConfig({ mode: 'exact', useSynonyms: false, useExclusion: false });
          MNUtil.showHUD("å·²åˆ‡æ¢åˆ°ç²¾ç¡®æœç´¢æ¨¡å¼");
        } else if (choice === 4) {  // åŒä¹‰è¯æ‰©å±•
          this.saveSearchConfig({ mode: 'synonym', useSynonyms: true, useExclusion: false });
          MNUtil.showHUD("å·²åˆ‡æ¢åˆ°åŒä¹‰è¯æ‰©å±•æ¨¡å¼");
        } else if (choice === 5) {  // æ’é™¤è¯è¿‡æ»¤
          this.saveSearchConfig({ mode: 'exclude', useSynonyms: false, useExclusion: true });
          MNUtil.showHUD("å·²åˆ‡æ¢åˆ°æ’é™¤è¯è¿‡æ»¤æ¨¡å¼");
        } else if (choice === 6) {  // å®Œæ•´æ¨¡å¼
          this.saveSearchConfig({ mode: 'full', useSynonyms: true, useExclusion: true });
          MNUtil.showHUD("å·²åˆ‡æ¢åˆ°å®Œæ•´æ¨¡å¼");
        } else if (choice === 8) {  // æŸ¥çœ‹è¯´æ˜
          await this.showSearchModeHelp();
        }
      }
    } catch (error) {
      MNUtil.showHUD("é…ç½®æœç´¢æ¨¡å¼å¤±è´¥: " + error.message);
    }
  }
  
  /**
   * æ˜¾ç¤ºæœç´¢æ¨¡å¼è¯´æ˜
   */
  static async showSearchModeHelp() {
    const helpText = `æœç´¢æ¨¡å¼è¯´æ˜ï¼š

âš¡ ç²¾ç¡®æœç´¢
â€¢ ç›´æ¥åŒ¹é…å…³é”®è¯
â€¢ é€Ÿåº¦æœ€å¿«
â€¢ é€‚åˆç²¾ç¡®æŸ¥æ‰¾

ğŸ”„ åŒä¹‰è¯æ‰©å±•
â€¢ è‡ªåŠ¨æ‰©å±•åŒä¹‰è¯
â€¢ æé«˜å¬å›ç‡
â€¢ é€‚åˆæ¨¡ç³ŠæŸ¥æ‰¾

ğŸš« æ’é™¤è¯è¿‡æ»¤
â€¢ è¿‡æ»¤æ— å…³ç»“æœ
â€¢ æé«˜å‡†ç¡®ç‡
â€¢ é€‚åˆç²¾ç¡®é¢†åŸŸ

ğŸ”¥ å®Œæ•´æ¨¡å¼
â€¢ åŒä¹‰è¯+æ’é™¤è¯
â€¢ æœ€å…¨é¢çš„æœç´¢
â€¢ é€Ÿåº¦ç¨æ…¢`;

    await MNUtil.alert("æœç´¢æ¨¡å¼è¯´æ˜", helpText);
  }
  
  /**
   * è·å–æœç´¢é…ç½®
   */
  static getSearchConfig() {
    const configKey = "KnowledgeBaseTemplate_SearchModeConfig";
    const savedConfig = NSUserDefaults.standardUserDefaults().objectForKey(configKey);
    
    if (savedConfig) {
      try {
        return JSON.parse(savedConfig);
      } catch (e) {
        MNUtil.log("è§£ææœç´¢é…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®");
      }
    }
    
    // é»˜è®¤é…ç½®
    return {
      mode: 'exact',
      useSynonyms: false,
      useExclusion: false,
      lastUpdated: Date.now()
    };
  }
  
  /**
   * ä¿å­˜æœç´¢é…ç½®
   */
  static saveSearchConfig(config) {
    const configKey = "KnowledgeBaseTemplate_SearchModeConfig";
    const configToSave = {
      ...config,
      lastUpdated: Date.now()
    };
    
    NSUserDefaults.standardUserDefaults().setObjectForKey(
      JSON.stringify(configToSave),
      configKey
    );
  }



  /**
   * æ˜¾ç¤ºæ›´å¤šåŠŸèƒ½èœå•
   */
  static async showMoreFeaturesMenu() {
    const options = [
      "ğŸ“ ç®¡ç†æ ¹ç›®å½•",
      "ğŸ“¤ğŸ“¥ å¯¼å…¥å¯¼å‡ºé…ç½®"
    ];

    const result = await MNUtil.userSelect(
      "æ›´å¤šæœç´¢åŠŸèƒ½",
      "é€‰æ‹©è¦ç®¡ç†çš„åŠŸèƒ½ï¼š",
      options
    );

    if (result === null || result === 0) return null;

    switch (result) {
      case 1:
        return "manageRoots";
      case 2:
        return "importExport";
    }
    return null;
  }

  /**
   * æ˜¾ç¤ºå¯¼å…¥å¯¼å‡ºèœå•
   */
  static async showImportExportMenu() {
    const options = [
      "ğŸ“¤ å¯¼å‡ºå®Œæ•´é…ç½®",
      "ğŸ“¥ å¯¼å…¥å®Œæ•´é…ç½®"
    ];

    const result = await MNUtil.userSelect(
      "å¯¼å…¥å¯¼å‡ºé…ç½®",
      "é€‰æ‹©æ“ä½œï¼š",
      options
    );

    if (result === null || result === 0) return;

    switch (result) {
      case 1: // å¯¼å‡ºå®Œæ•´é…ç½®
        await this.exportFullSearchConfig();
        break;
      case 2: // å¯¼å…¥å®Œæ•´é…ç½®
        await this.importFullSearchConfig();
        break;
    }
  }

  /**
   * å¯¼å‡ºå®Œæ•´æœç´¢é…ç½®
   */
  static async exportFullSearchConfig() {
    try {
      // ä½¿ç”¨ç»Ÿä¸€çš„é…ç½®è·å–å‡½æ•°
      const config = this.getFullSearchConfig();
      // æ·»åŠ  type å­—æ®µç”¨äºè¯†åˆ«
      config.type = "fullSearchConfig";
      
      const jsonStr = JSON.stringify(config, null, 2);
      
      const target = await MNUtil.userSelect(
        "å¯¼å‡ºå®Œæ•´é…ç½®",
        "é€‰æ‹©å¯¼å‡ºæ–¹å¼ï¼š",
        ["â˜ï¸ åŒæ­¥åˆ° iCloud", "ğŸ“‹ å¤åˆ¶åˆ°å‰ªè´´æ¿", "ğŸ“ ä¿å­˜åˆ°å½“å‰ç¬”è®°"]
      );
      
      if (target === null || target === 0) return;
      
      switch (target) {
        case 1: // iCloud
          // MNUtil.setByiCloud("KnowledgeBaseTemplate_FullSearchConfig", jsonStr);
          MNUtil.showHUD("â˜ï¸ å·²åŒæ­¥åˆ° iCloud");
          break;
        case 2: // å‰ªè´´æ¿
          MNUtil.copy(jsonStr);
          MNUtil.showHUD("ğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
          break;
        case 3: // å½“å‰ç¬”è®°
          const focusNote = MNNote.getFocusNote();
          if (focusNote) {
            const formattedJson = this.formatJsonAsCodeBlock(jsonStr);
            focusNote.appendTextComment(formattedJson);
            MNUtil.showHUD("ğŸ“ å·²ä¿å­˜åˆ°å½“å‰ç¬”è®°");
          } else {
            MNUtil.showHUD("âŒ æœªé€‰ä¸­ç¬”è®°");
          }
          break;
      }
    } catch (error) {
      MNUtil.showHUD("âŒ å¯¼å‡ºå¤±è´¥ï¼š" + error.message);
    }
  }

  /**
   * å¯¼å…¥å®Œæ•´æœç´¢é…ç½®
   */
  static async importFullSearchConfig() {
    try {
      const source = await MNUtil.userSelect(
        "å¯¼å…¥å®Œæ•´é…ç½®",
        "é€‰æ‹©å¯¼å…¥æ¥æºï¼š",
        ["â˜ï¸ ä» iCloud åŒæ­¥", "ğŸ“‹ ä»å‰ªè´´æ¿å¯¼å…¥", "ğŸ“ ä»å½“å‰ç¬”è®°å¯¼å…¥"]
      );
      
      if (source === null || source === 0) return;
      
      let jsonStr = null;
      
      switch (source) {
        case 1: // iCloud
          jsonStr = MNUtil.getByiCloud("KnowledgeBaseTemplate_FullSearchConfig", null);
          if (!jsonStr) {
            MNUtil.showHUD("âŒ iCloud ä¸­æœªæ‰¾åˆ°é…ç½®");
            return;
          }
          break;
        case 2: // å‰ªè´´æ¿
          jsonStr = MNUtil.clipboardText;
          break;
        case 3: // å½“å‰ç¬”è®°
          const focusNote = MNNote.getFocusNote();
          if (!focusNote) {
            MNUtil.showHUD("âŒ æœªé€‰ä¸­ç¬”è®°");
            return;
          }
          // æŸ¥æ‰¾åŒ…å«å®Œæ•´é…ç½®çš„è¯„è®º
          for (const comment of focusNote.comments) {
            if (comment.type === "textComment" && comment.text.includes('"fullSearchConfig"')) {
              jsonStr = this.extractJsonFromCodeBlock(comment.text);
              break;
            }
          }
          if (!jsonStr) {
            MNUtil.showHUD("âŒ å½“å‰ç¬”è®°ä¸­æœªæ‰¾åˆ°é…ç½®");
            return;
          }
          break;
      }
      
      const config = JSON.parse(jsonStr);
      if (!config.searchConfig) {
        throw new Error("æ— æ•ˆçš„é…ç½®æ ¼å¼");
      }
      
      // ç‰ˆæœ¬å…¼å®¹æ€§å¤„ç†
      if (!config.version || config.version !== "1.0") {
        // æ—§ç‰ˆæœ¬é…ç½®ï¼Œè‡ªåŠ¨å‡çº§
        config.searchConfig.rootGroups = config.searchConfig.rootGroups || {};
        config.searchConfig.lastUsedGroup = config.searchConfig.lastUsedGroup || null;
        config.searchConfig.lastUsedRoots = config.searchConfig.lastUsedRoots || 
          (config.searchConfig.lastUsedRoot ? [config.searchConfig.lastUsedRoot] : []);
      }
      
      const importMode = await MNUtil.userSelect(
        "å¯¼å…¥æ–¹å¼",
        "é€‰æ‹©å¯¼å…¥æ–¹å¼ï¼š",
        ["æ›¿æ¢ç°æœ‰é…ç½®", "åˆå¹¶é…ç½®"]
      );
      
      if (importMode === null || importMode === 0) return;
      
      this.initSearchConfig();
      
      if (importMode === 1) {
        // æ›¿æ¢
        Object.assign(this.searchRootConfigs, config.searchConfig);
        this.searchRootConfigs.synonymGroups = config.synonymGroups || [];
      } else {
        // åˆå¹¶
        // åˆå¹¶æ ¹ç›®å½•
        if (config.searchConfig.roots) {
          Object.assign(this.searchRootConfigs.roots, config.searchConfig.roots);
        }
        
        // åˆå¹¶ç¾¤ç»„
        if (config.searchConfig.rootGroups) {
          if (!this.searchRootConfigs.rootGroups) {
            this.searchRootConfigs.rootGroups = {};
          }
          // åˆå¹¶ç¾¤ç»„ï¼Œå¦‚æœåŒååˆ™è¯¢é—®ç”¨æˆ·
          for (const groupName in config.searchConfig.rootGroups) {
            if (this.searchRootConfigs.rootGroups[groupName]) {
              const overwrite = await MNUtil.confirm(
                "ç¾¤ç»„å†²çª",
                `ç¾¤ç»„"${groupName}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`,
                ["è·³è¿‡", "è¦†ç›–"]
              );
              if (overwrite === 1) {
                this.searchRootConfigs.rootGroups[groupName] = config.searchConfig.rootGroups[groupName];
              }
            } else {
              this.searchRootConfigs.rootGroups[groupName] = config.searchConfig.rootGroups[groupName];
            }
          }
        }
        
        // åˆå¹¶åŒä¹‰è¯ç»„
        if (config.synonymGroups && config.synonymGroups.length > 0) {
          if (!this.searchRootConfigs.synonymGroups) {
            this.searchRootConfigs.synonymGroups = [];
          }
          const existingIds = new Set(this.searchRootConfigs.synonymGroups.map(g => g.id));
          for (const group of config.synonymGroups) {
            if (!existingIds.has(group.id)) {
              this.searchRootConfigs.synonymGroups.push(group);
            }
          }
        }
      }
      
      // éªŒè¯å¯¼å…¥çš„ç¾¤ç»„
      if (this.searchRootConfigs.rootGroups) {
        for (const groupName in this.searchRootConfigs.rootGroups) {
          const group = this.searchRootConfigs.rootGroups[groupName];
          const validRoots = [];
          
          for (const rootKey of group.roots || []) {
            if (this.searchRootConfigs.roots[rootKey]) {
              validRoots.push(rootKey);
            } else {
              MNUtil.log(`è­¦å‘Šï¼šç¾¤ç»„"${groupName}"ä¸­çš„æ ¹ç›®å½•"${rootKey}"ä¸å­˜åœ¨`);
            }
          }
          
          group.roots = validRoots;
          
          // å¦‚æœç¾¤ç»„ä¸ºç©ºï¼Œåˆ é™¤è¯¥ç¾¤ç»„
          if (validRoots.length === 0) {
            delete this.searchRootConfigs.rootGroups[groupName];
            MNUtil.log(`å·²ç§»é™¤ç©ºç¾¤ç»„ï¼š${groupName}`);
          }
        }
      }
      
      this.saveSearchConfig();
      MNUtil.showHUD("âœ… é…ç½®å¯¼å…¥æˆåŠŸ");
    } catch (error) {
      MNUtil.showHUD("âŒ å¯¼å…¥å¤±è´¥ï¼š" + error.message);
    }
  }


  /**
   * ç¡®è®¤æ“ä½œå¯¹è¯æ¡†
   */
  static async confirmAction(title, message) {
    return new Promise((resolve) => {
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        title,
        message,
        0,
        "å–æ¶ˆ",
        ["ç¡®å®š"],
        (alert, buttonIndex) => {
          resolve(buttonIndex === 1);
        }
      );
    });
  }

  // ==================== è¯æ˜æ¨¡æ¿ç®¡ç†ç³»ç»Ÿ ====================
  
  static proofTemplates = null;
  

  /**
   * æ·»åŠ ç­‰ä»·è¯æ˜ï¼ˆé›†æˆæ¨¡æ¿ç³»ç»Ÿå’Œæ™ºèƒ½ç©ºæ ¼å¤„ç†ï¼‰
   * @param {MNNote} note - ç›®æ ‡ç¬”è®°
   */
  static async addEquivalenceProof(note) {
    if (!note) {
      MNUtil.showHUD("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç¬”è®°");
      return;
    }
    
    try {
      // åˆå§‹åŒ–æ¨¡æ¿é…ç½®
      this.initProofTemplates();
      
      const enabledTemplates = this.getEnabledProofTemplates();
      
      if (enabledTemplates.length === 0) {
        MNUtil.showHUD("âŒ æ²¡æœ‰å¯ç”¨çš„è¯æ˜æ¨¡æ¿ï¼Œè¯·å…ˆåˆ›å»ºæ¨¡æ¿");
        return;
      }
      
      // é€‰æ‹©æ¨¡æ¿
      const templateOptions = enabledTemplates.map(t => t.name);
      const selectedTemplateIndex = await MNUtil.userSelect(
        "é€‰æ‹©è¯æ˜æ¨¡æ¿",
        "è¯·é€‰æ‹©è¦ä½¿ç”¨çš„è¯æ˜æ¨¡æ¿ï¼š",
        templateOptions
      );
      
      if (selectedTemplateIndex === 0) {
        MNUtil.showHUD("å·²å–æ¶ˆ");
        return;
      }
      
      const selectedTemplate = enabledTemplates[selectedTemplateIndex - 1];
      
      // æ”¶é›†è¾“å…¥æ•°æ®
      const inputs = {};
      
      // æ£€æŸ¥æ¨¡æ¿æ˜¯å¦éœ€è¦å‘½é¢˜A
      if (selectedTemplate.forwardTemplate && selectedTemplate.forwardTemplate.includes('{A}')) {
        const propositionA = await this.showInputDialog(
          "è¾“å…¥å‘½é¢˜ A",
          "è¯·è¾“å…¥ç¬¬ä¸€ä¸ªå‘½é¢˜ï¼ˆä¾‹å¦‚ï¼šAæ˜¯Bçš„å­é›†ï¼‰",
          "ä¸‹ä¸€æ­¥"
        );
        if (!propositionA) {
          MNUtil.showHUD("å·²å–æ¶ˆ");
          return;
        }
        inputs.A = propositionA;
      }
      
      // æ£€æŸ¥æ¨¡æ¿æ˜¯å¦éœ€è¦å‘½é¢˜B
      if ((selectedTemplate.forwardTemplate && selectedTemplate.forwardTemplate.includes('{B}')) ||
          (selectedTemplate.reverseTemplate && selectedTemplate.reverseTemplate.includes('{B}'))) {
        const propositionB = await this.showInputDialog(
          "è¾“å…¥å‘½é¢˜ B", 
          "è¯·è¾“å…¥ç¬¬äºŒä¸ªå‘½é¢˜ï¼ˆä¾‹å¦‚ï¼šBåŒ…å«Aï¼‰",
          "ç¡®å®š"
        );
        if (!propositionB) {
          MNUtil.showHUD("å·²å–æ¶ˆ");
          return;
        }
        inputs.B = propositionB;
      }
      
      // åˆ›å»ºå­å¡ç‰‡
      MNUtil.undoGrouping(() => {
        // æ›¿æ¢å ä½ç¬¦ï¼Œä½¿ç”¨ Pangu.spacing å¤„ç†ä¸­è‹±æ–‡é—´è·
        const replacePlaceholders = (text) => {
          if (!text) return "";
          // ä½¿ç”¨ Pangu.spacing å¤„ç†ä¸­è‹±æ–‡é—´è·
          const spacedA = inputs.A ? Pangu.spacing(inputs.A) : "";
          const spacedB = inputs.B ? Pangu.spacing(inputs.B) : "";
          return text.replace(/\{A\}/g, spacedA)
                     .replace(/\{B\}/g, spacedB);
        };
        
        // æ­£å‘è¯æ˜å­å¡ç‰‡
        if (selectedTemplate.forwardTemplate) {
          const forwardTitle = replacePlaceholders(selectedTemplate.forwardTemplate);
          const forwardNote = MNNote.new({ title: forwardTitle });
          if (forwardNote) {
            note.addChild(forwardNote);
          }
        }
        
        // åå‘è¯æ˜å­å¡ç‰‡ï¼ˆä»…ç­‰ä»·è¯æ˜ç±»å‹ï¼‰
        if (selectedTemplate.type === "equivalence" && selectedTemplate.reverseTemplate) {
          const reverseTitle = replacePlaceholders(selectedTemplate.reverseTemplate);
          const reverseNote = MNNote.new({ title: reverseTitle });
          if (reverseNote) {
            note.addChild(reverseNote);
          }
        }
        
        note.refresh();
      });
      
      MNUtil.showHUD(`âœ… ${selectedTemplate.name}å·²æ·»åŠ `);
      
    } catch (error) {
      MNUtil.showHUD(`âŒ é”™è¯¯: ${error.message}`);
      MNUtil.addErrorLog(error, "addEquivalenceProof", {
        noteId: note?.noteId,
        noteTitle: note?.noteTitle
      });
    }
  }

  // ==================== è¯æ˜æ¨¡æ¿ç®¡ç†ç³»ç»Ÿ ====================
  
  /**
   * åˆå§‹åŒ–è¯æ˜æ¨¡æ¿é…ç½®
   */
  static initProofTemplates() {
    if (!this.proofTemplates) {
      this.proofTemplates = this.loadProofTemplates();
    }
    return this.proofTemplates;
  }

  /**
   * ä»å­˜å‚¨åŠ è½½è¯æ˜æ¨¡æ¿é…ç½®
   */
  static loadProofTemplates() {
    try {
      // å…ˆå°è¯•ä»æœ¬åœ°åŠ è½½
      const localConfig = NSUserDefaults.standardUserDefaults().objectForKey("KnowledgeBaseTemplate_ProofTemplates");
      let config = localConfig ? JSON.parse(localConfig) : null;
      
      // å¦‚æœæ²¡æœ‰æœ¬åœ°é…ç½®ï¼Œä» iCloud åŠ è½½
      if (!config) {
        try {
          const cloudStore = NSUbiquitousKeyValueStore.defaultStore();
          if (cloudStore) {
            const cloudConfig = cloudStore.objectForKey("KnowledgeBaseTemplate_ProofTemplates");
            if (cloudConfig) {
              config = JSON.parse(cloudConfig);
              // åŒæ­¥åˆ°æœ¬åœ°
              NSUserDefaults.standardUserDefaults().setObjectForKey(cloudConfig, "KnowledgeBaseTemplate_ProofTemplates");
            }
          }
        } catch (cloudError) {
          // iCloud ä¸å¯ç”¨æ—¶å¿½ç•¥é”™è¯¯
        }
      }
      
      // å¦‚æœè¿˜æ˜¯æ²¡æœ‰é…ç½®ï¼Œè¿”å›é»˜è®¤é…ç½®
      if (!config) {
        config = this.getDefaultProofTemplates();
        this.saveProofTemplates(); // ä¿å­˜é»˜è®¤é…ç½®
      }
      
      return config;
    } catch (error) {
      MNUtil.showHUD("åŠ è½½è¯æ˜æ¨¡æ¿å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®");
      return this.getDefaultProofTemplates();
    }
  }

  /**
   * è·å–é»˜è®¤è¯æ˜æ¨¡æ¿é…ç½®
   */
  static getDefaultProofTemplates() {
    return {
      templates: [
        {
          id: "template_equivalence_standard",
          name: "æ ‡å‡†ç­‰ä»·è¯æ˜",
          type: "equivalence",
          forwardTemplate: "è‹¥ {A} æˆç«‹ï¼Œåˆ™ {B} æˆç«‹",
          reverseTemplate: "è‹¥ {B} æˆç«‹ï¼Œåˆ™ {A} æˆç«‹",
          enabled: true,
          createdAt: Date.now(),
          updatedAt: Date.now()
        },
        {
          id: "template_implication_standard",
          name: "æ ‡å‡†è•´æ¶µè¯æ˜",
          type: "implication",
          forwardTemplate: "è‹¥ {A} æˆç«‹ï¼Œåˆ™ {B} æˆç«‹",
          reverseTemplate: "",
          enabled: true,
          createdAt: Date.now(),
          updatedAt: Date.now()
        }
      ],
      lastModified: Date.now(),
      version: "1.0"
    };
  }

  /**
   * ä¿å­˜è¯æ˜æ¨¡æ¿é…ç½®
   */
  static saveProofTemplates() {
    try {
      if (!this.proofTemplates) {
        this.initProofTemplates();
      }
      
      this.proofTemplates.lastModified = Date.now();
      const configStr = JSON.stringify(this.proofTemplates);
      
      // ä¿å­˜åˆ°æœ¬åœ°
      NSUserDefaults.standardUserDefaults().setObjectForKey(configStr, "KnowledgeBaseTemplate_ProofTemplates");
      
      // å¦‚æœå¼€å¯äº† iCloud åŒæ­¥ï¼Œä¿å­˜åˆ° iCloud
      try {
        if (typeof toolbarConfig !== 'undefined' && toolbarConfig.iCloudSync) {
          const cloudStore = NSUbiquitousKeyValueStore.defaultStore();
          if (cloudStore) {
            cloudStore.setObjectForKey(configStr, "KnowledgeBaseTemplate_ProofTemplates");
            cloudStore.synchronize();
          }
        }
      } catch (cloudError) {
        // iCloud åŒæ­¥å¤±è´¥ä¸å½±å“æœ¬åœ°ä¿å­˜
      }
      
      return true;
    } catch (error) {
      MNUtil.showHUD("ä¿å­˜è¯æ˜æ¨¡æ¿å¤±è´¥: " + error.message);
      return false;
    }
  }

  /**
   * è·å–æ‰€æœ‰è¯æ˜æ¨¡æ¿
   */
  static getProofTemplates() {
    this.initProofTemplates();
    return this.proofTemplates.templates || [];
  }
  
  /**
   * è·å–æ‰€æœ‰å¯ç”¨çš„è¯æ˜æ¨¡æ¿
   */
  static getEnabledProofTemplates() {
    const allTemplates = this.getProofTemplates();
    return allTemplates.filter(template => template.enabled);
  }
  
  /**
   * æ˜¾ç¤ºè¾“å…¥å¯¹è¯æ¡†
   * @param {string} title - å¯¹è¯æ¡†æ ‡é¢˜
   * @param {string} message - å¯¹è¯æ¡†æ¶ˆæ¯
   * @param {string} confirmText - ç¡®è®¤æŒ‰é’®æ–‡æœ¬
   * @returns {Promise<string|null>} è¾“å…¥æ–‡æœ¬æˆ–nullï¼ˆå¦‚æœå–æ¶ˆï¼‰
   */
  static async showInputDialog(title, message, confirmText) {
    return new Promise((resolve) => {
      UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
        title,
        message,
        2, // è¾“å…¥æ¡†æ ·å¼
        "å–æ¶ˆ",
        [confirmText],
        (alert, buttonIndex) => {
          if (buttonIndex === 1) {
            const text = alert.textFieldAtIndex(0).text;
            resolve(text);
          } else {
            resolve(null);
          }
        }
      );
    });
  }

  // ==================== è¯æ˜æ¨¡æ¿ç®¡ç†ç•Œé¢ ====================
  
  /**
   * è¯æ˜æ¨¡æ¿ç®¡ç†ä¸»ç•Œé¢
   */
  static async manageProofTemplates() {
    try {
      this.initProofTemplates();
      
      while (true) {
        const templates = this.getProofTemplates();
        const templateList = templates.map(t => 
          `${t.enabled ? 'âœ…' : 'âŒ'} ${t.name} (${t.type})`
        );
        
        const options = [
          "ğŸ“ æ·»åŠ æ–°æ¨¡æ¿",
          "ğŸ“‹ ç¼–è¾‘æ¨¡æ¿",
          "ğŸ—‘ï¸ åˆ é™¤æ¨¡æ¿",
          "ğŸ”„ å¯ç”¨/ç¦ç”¨æ¨¡æ¿",
          "ğŸ“¥ å¯¼å…¥æ¨¡æ¿",
          "ğŸ“¤ å¯¼å‡ºæ¨¡æ¿",
          "ğŸ”§ é‡ç½®ä¸ºé»˜è®¤",
          "âŒ å…³é—­"
        ];
        
        let message = `å½“å‰æ¨¡æ¿ (${templates.length} ä¸ª):\n`;
        templateList.forEach((item, index) => {
          message += `${index + 1}. ${item}\n`;
        });
        
        const choice = await MNUtil.userSelect(
          "è¯æ˜æ¨¡æ¿ç®¡ç†",
          message,
          options
        );
        
        if (choice === 0 || choice === 8) break; // å–æ¶ˆæˆ–å…³é—­
        
        switch (choice) {
          case 1: // æ·»åŠ æ–°æ¨¡æ¿
            await this.addNewTemplate();
            break;
          case 2: // ç¼–è¾‘æ¨¡æ¿
            await this.editTemplateBySelection();
            break;
          case 3: // åˆ é™¤æ¨¡æ¿
            await this.deleteTemplateBySelection();
            break;
          case 4: // å¯ç”¨/ç¦ç”¨æ¨¡æ¿
            await this.toggleTemplateBySelection();
            break;
          case 5: // å¯¼å…¥æ¨¡æ¿
            MNUtil.showHUD("å¯¼å…¥åŠŸèƒ½å¼€å‘ä¸­...");
            break;
          case 6: // å¯¼å‡ºæ¨¡æ¿
            MNUtil.showHUD("å¯¼å‡ºåŠŸèƒ½å¼€å‘ä¸­...");
            break;
          case 7: // é‡ç½®ä¸ºé»˜è®¤
            await this.resetToDefaultTemplates();
            break;
        }
      }
      
    } catch (error) {
      MNUtil.showHUD(`âŒ ç®¡ç†æ¨¡æ¿æ—¶å‡ºé”™: ${error.message}`);
      MNUtil.addErrorLog(error, "manageProofTemplates");
    }
  }
  
  /**
   * æ·»åŠ æ–°æ¨¡æ¿
   */
  static async addNewTemplate() {
    try {
      const name = await this.showInputDialog(
        "æ¨¡æ¿åç§°",
        "è¯·è¾“å…¥æ¨¡æ¿åç§°ï¼ˆä¾‹å¦‚ï¼šå……åˆ†å¿…è¦æ¡ä»¶è¯æ˜ï¼‰",
        "ä¸‹ä¸€æ­¥"
      );
      if (!name) return;
      
      const typeOptions = ["ç­‰ä»·è¯æ˜", "è•´æ¶µè¯æ˜", "è‡ªå®šä¹‰è¯æ˜"];
      const typeChoice = await MNUtil.userSelect(
        "é€‰æ‹©æ¨¡æ¿ç±»å‹",
        "è¯·é€‰æ‹©è¯æ˜æ¨¡æ¿çš„ç±»å‹ï¼š",
        typeOptions
      );
      if (typeChoice === 0) return;
      
      const typeMap = { 1: "equivalence", 2: "implication", 3: "custom" };
      const type = typeMap[typeChoice];
      
      const forwardTemplate = await this.showInputDialog(
        "æ­£å‘è¯æ˜æ¨¡æ¿",
        "è¯·è¾“å…¥æ­£å‘è¯æ˜æ¨¡æ¿ï¼ˆç”¨ {A} å’Œ {B} ä½œä¸ºå ä½ç¬¦ï¼‰",
        "ä¸‹ä¸€æ­¥"
      );
      if (!forwardTemplate) return;
      
      let reverseTemplate = "";
      if (type === "equivalence") {
        reverseTemplate = await this.showInputDialog(
          "åå‘è¯æ˜æ¨¡æ¿",
          "è¯·è¾“å…¥åå‘è¯æ˜æ¨¡æ¿ï¼ˆç”¨ {A} å’Œ {B} ä½œä¸ºå ä½ç¬¦ï¼‰",
          "å®Œæˆ"
        );
        if (reverseTemplate === null) return;
      }
      
      const newTemplate = {
        id: "template_" + Date.now(),
        name: name,
        type: type,
        forwardTemplate: forwardTemplate,
        reverseTemplate: reverseTemplate,
        enabled: true,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      
      this.proofTemplates.templates.push(newTemplate);
      this.saveProofTemplates();
      
      MNUtil.showHUD(`âœ… æ¨¡æ¿"${name}"å·²æ·»åŠ `);
      
    } catch (error) {
      MNUtil.showHUD(`âŒ æ·»åŠ æ¨¡æ¿å¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * é€šè¿‡é€‰æ‹©ç¼–è¾‘æ¨¡æ¿
   */
  static async editTemplateBySelection() {
    try {
      const templates = this.getProofTemplates();
      if (templates.length === 0) {
        MNUtil.showHUD("âŒ æ²¡æœ‰å¯ç¼–è¾‘çš„æ¨¡æ¿");
        return;
      }
      
      const templateOptions = templates.map(t => t.name);
      const choice = await MNUtil.userSelect(
        "é€‰æ‹©è¦ç¼–è¾‘çš„æ¨¡æ¿",
        "è¯·é€‰æ‹©è¦ç¼–è¾‘çš„æ¨¡æ¿ï¼š",
        templateOptions
      );
      
      if (choice === 0) return;
      
      const template = templates[choice - 1];
      await this.editTemplate(template);
      
    } catch (error) {
      MNUtil.showHUD(`âŒ ç¼–è¾‘æ¨¡æ¿å¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * ç¼–è¾‘å•ä¸ªæ¨¡æ¿
   */
  static async editTemplate(template) {
    try {
      const editOptions = [
        "ğŸ“ ç¼–è¾‘åç§°",
        "ğŸ”„ ç¼–è¾‘ç±»å‹",
        "â¡ï¸ ç¼–è¾‘æ­£å‘æ¨¡æ¿",
        "â¬…ï¸ ç¼–è¾‘åå‘æ¨¡æ¿",
        "âœ… å®Œæˆç¼–è¾‘"
      ];
      
      while (true) {
        let info = `å½“å‰æ¨¡æ¿ä¿¡æ¯:\n`;
        info += `åç§°: ${template.name}\n`;
        info += `ç±»å‹: ${template.type}\n`;
        info += `æ­£å‘: ${template.forwardTemplate}\n`;
        info += `åå‘: ${template.reverseTemplate || '(æ— )'}\n`;
        
        const choice = await MNUtil.userSelect(
          `ç¼–è¾‘æ¨¡æ¿: ${template.name}`,
          info,
          editOptions
        );
        
        if (choice === 0 || choice === 5) break;
        
        switch (choice) {
          case 1: // ç¼–è¾‘åç§°
            const newName = await this.showInputDialog(
              "ç¼–è¾‘åç§°",
              `å½“å‰åç§°: ${template.name}`,
              "ç¡®å®š"
            );
            if (newName) template.name = newName;
            break;
            
          case 2: // ç¼–è¾‘ç±»å‹
            const typeOptions = ["ç­‰ä»·è¯æ˜", "è•´æ¶µè¯æ˜", "è‡ªå®šä¹‰è¯æ˜"];
            const typeChoice = await MNUtil.userSelect("é€‰æ‹©ç±»å‹", "è¯·é€‰æ‹©æ–°çš„ç±»å‹ï¼š", typeOptions);
            if (typeChoice > 0) {
              const typeMap = { 1: "equivalence", 2: "implication", 3: "custom" };
              template.type = typeMap[typeChoice];
            }
            break;
            
          case 3: // ç¼–è¾‘æ­£å‘æ¨¡æ¿
            const newForward = await this.showInputDialog(
              "ç¼–è¾‘æ­£å‘æ¨¡æ¿",
              `å½“å‰: ${template.forwardTemplate}`,
              "ç¡®å®š"
            );
            if (newForward) template.forwardTemplate = newForward;
            break;
            
          case 4: // ç¼–è¾‘åå‘æ¨¡æ¿
            const newReverse = await this.showInputDialog(
              "ç¼–è¾‘åå‘æ¨¡æ¿",
              `å½“å‰: ${template.reverseTemplate || '(æ— )'}`,
              "ç¡®å®š"
            );
            if (newReverse !== null) template.reverseTemplate = newReverse;
            break;
        }
        
        template.updatedAt = Date.now();
      }
      
      this.saveProofTemplates();
      MNUtil.showHUD(`âœ… æ¨¡æ¿"${template.name}"å·²æ›´æ–°`);
      
    } catch (error) {
      MNUtil.showHUD(`âŒ ç¼–è¾‘æ¨¡æ¿å¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * é€šè¿‡é€‰æ‹©åˆ é™¤æ¨¡æ¿
   */
  static async deleteTemplateBySelection() {
    try {
      const templates = this.getProofTemplates();
      if (templates.length === 0) {
        MNUtil.showHUD("âŒ æ²¡æœ‰å¯åˆ é™¤çš„æ¨¡æ¿");
        return;
      }
      
      const templateOptions = templates.map(t => t.name);
      const choice = await MNUtil.userSelect(
        "é€‰æ‹©è¦åˆ é™¤çš„æ¨¡æ¿",
        "è¯·é€‰æ‹©è¦åˆ é™¤çš„æ¨¡æ¿ï¼š",
        templateOptions
      );
      
      if (choice === 0) return;
      
      const template = templates[choice - 1];
      const confirmed = await MNUtil.confirm(
        "ç¡®è®¤åˆ é™¤",
        `ç¡®å®šè¦åˆ é™¤æ¨¡æ¿"${template.name}"å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`
      );
      
      if (confirmed) {
        this.proofTemplates.templates = templates.filter(t => t.id !== template.id);
        this.saveProofTemplates();
        MNUtil.showHUD(`âœ… æ¨¡æ¿"${template.name}"å·²åˆ é™¤`);
      }
      
    } catch (error) {
      MNUtil.showHUD(`âŒ åˆ é™¤æ¨¡æ¿å¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * é€šè¿‡é€‰æ‹©åˆ‡æ¢æ¨¡æ¿å¯ç”¨çŠ¶æ€
   */
  static async toggleTemplateBySelection() {
    try {
      const templates = this.getProofTemplates();
      if (templates.length === 0) {
        MNUtil.showHUD("âŒ æ²¡æœ‰å¯æ“ä½œçš„æ¨¡æ¿");
        return;
      }
      
      const templateOptions = templates.map(t => 
        `${t.enabled ? 'âœ…' : 'âŒ'} ${t.name}`
      );
      const choice = await MNUtil.userSelect(
        "å¯ç”¨/ç¦ç”¨æ¨¡æ¿",
        "è¯·é€‰æ‹©è¦åˆ‡æ¢çŠ¶æ€çš„æ¨¡æ¿ï¼š",
        templateOptions
      );
      
      if (choice === 0) return;
      
      const template = templates[choice - 1];
      template.enabled = !template.enabled;
      template.updatedAt = Date.now();
      
      this.saveProofTemplates();
      MNUtil.showHUD(`âœ… æ¨¡æ¿"${template.name}"å·²${template.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
      
    } catch (error) {
      MNUtil.showHUD(`âŒ åˆ‡æ¢æ¨¡æ¿çŠ¶æ€å¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * é‡ç½®ä¸ºé»˜è®¤æ¨¡æ¿
   */
  static async resetToDefaultTemplates() {
    try {
      const confirmed = await MNUtil.confirm(
        "é‡ç½®ç¡®è®¤",
        "ç¡®å®šè¦é‡ç½®ä¸ºé»˜è®¤æ¨¡æ¿å—ï¼Ÿè¿™å°†åˆ é™¤æ‰€æœ‰è‡ªå®šä¹‰æ¨¡æ¿ã€‚"
      );
      
      if (confirmed) {
        this.proofTemplates = this.getDefaultProofTemplates();
        this.saveProofTemplates();
        MNUtil.showHUD("âœ… å·²é‡ç½®ä¸ºé»˜è®¤æ¨¡æ¿");
      }
      
    } catch (error) {
      MNUtil.showHUD(`âŒ é‡ç½®æ¨¡æ¿å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * å¡ç‰‡çš„é¢„å¤„ç†
   */
  static processNote(note) {
    // KnowledgeBaseUtils.log("å¼€å§‹æ‰§è¡Œ processNote", "processNote", {
    //   noteId: note.noteId,
    //   noteTitle: note.noteTitle,
    //   isOldTemplate: this.isOldTemplateCard(note),
    //   ifTemplateMerged: this.ifTemplateMerged(note)
    // })

    if (this.isOldTemplateCard(note)) {
      // åˆ†æ”¯ Aï¼šæ—§æ¨¡æ¿å¡ç‰‡
      // KnowledgeBaseUtils.log("è¿›å…¥æ—§æ¨¡æ¿å¡ç‰‡åˆ†æ”¯", "processNote", {
      //   noteId: note.noteId
      // })

      let newNote = this.renewNote(note)
      // KnowledgeBaseUtils.log("å®Œæˆ renewNoteï¼ˆæ—§æ¨¡æ¿ï¼‰", "processNote", {
      //   step: "renewNote",
      //   noteId: note.noteId,
      //   newNoteId: newNote.noteId
      // })

      this.changeTitle(newNote)
      // KnowledgeBaseUtils.log("å®Œæˆ changeTitleï¼ˆæ—§æ¨¡æ¿ï¼‰", "processNote", {
      //   step: "changeTitle",
      //   noteId: newNote.noteId
      // })

      this.changeNoteColor(newNote)
      // KnowledgeBaseUtils.log("å®Œæˆ changeNoteColorï¼ˆæ—§æ¨¡æ¿ï¼‰", "processNote", {
      //   step: "changeNoteColor",
      //   noteId: newNote.noteId
      // })

      return newNote
    } else {
      if (this.ifTemplateMerged(note)) {
        // åˆ†æ”¯ Bï¼šå·²åˆå¹¶æ¨¡æ¿ï¼ˆé‡ç‚¹ç“¶é¢ˆåˆ†æ”¯ï¼‰
        // KnowledgeBaseUtils.log("è¿›å…¥å·²åˆå¹¶æ¨¡æ¿åˆ†æ”¯", "processNote", {
        //   noteId: note.noteId
        // })

        this.renewNote(note)
        // KnowledgeBaseUtils.log("å®Œæˆ renewNoteï¼ˆå·²åˆå¹¶æ¨¡æ¿ï¼‰", "processNote", {
        //   step: "renewNote",
        //   noteId: note.noteId
        // })

        this.changeTitle(note)
        // KnowledgeBaseUtils.log("å®Œæˆ changeTitleï¼ˆå·²åˆå¹¶æ¨¡æ¿ï¼‰", "processNote", {
        //   step: "changeTitle",
        //   noteId: note.noteId
        // })

        this.changeNoteColor(note)
        // KnowledgeBaseUtils.log("å®Œæˆ changeNoteColorï¼ˆå·²åˆå¹¶æ¨¡æ¿ï¼‰", "processNote", {
        //   step: "changeNoteColor",
        //   noteId: note.noteId
        // })

        this.linkParentNote(note)
        // KnowledgeBaseUtils.log("å®Œæˆ linkParentNoteï¼ˆå·²åˆå¹¶æ¨¡æ¿ï¼‰â­", "processNote", {
        //   step: "linkParentNote",
        //   noteId: note.noteId
        // })

        this.autoMoveNewContent(note) // è‡ªåŠ¨ç§»åŠ¨æ–°å†…å®¹åˆ°å¯¹åº”å­—æ®µ
        // KnowledgeBaseUtils.log("å®Œæˆ autoMoveNewContentï¼ˆå·²åˆå¹¶æ¨¡æ¿ï¼‰", "processNote", {
        //   step: "autoMoveNewContent",
        //   noteId: note.noteId
        // })

        return note
      } else {
        // åˆ†æ”¯ Cï¼šæ–°å¡ç‰‡
        // KnowledgeBaseUtils.log("è¿›å…¥æ–°å¡ç‰‡åˆ†æ”¯", "processNote", {
        //   noteId: note.noteId
        // })

        this.changeTitle(note)
        this.changeNoteColor(note)
        note.convertLinksToNewVersion()
        note.cleanupBrokenLinks()
        note.fixMergeProblematicLinks()

        let result = this.toNoExcerptVersion(note)
        // KnowledgeBaseUtils.log("å®Œæˆ toNoExcerptVersionï¼ˆæ–°å¡ç‰‡ï¼‰", "processNote", {
        //   step: "toNoExcerptVersion",
        //   noteId: note.noteId,
        //   resultNoteId: result.noteId
        // })

        return result
      }
    }
  }


  /**
   * é€‰ä¸­å¡ç‰‡çš„æ—§å­å­™å¡ç‰‡æ‰¹é‡åˆ¶å¡
   * 
   * 1. åªå¤„ç†å·²ç»åˆ¶è¿‡å¡çš„å¡ç‰‡
   */
  static oldChildrenMakeNotes(note) {
    let childDescendants = note.descendantNodes.descendant
    if (childDescendants.length>0) {
      MNUtil.undoGrouping(()=>{
        try {
          childDescendants.forEach(
            descendant => {
              if (this.isOldTemplateCard(descendant)) {
                // æ—§å¡ç‰‡
                let newDescendant = this.processOldTemplateCard(descendant)
                this.changeTitle(newDescendant)
              } else {
                // éæ—§å¡ç‰‡
                this.renewNote(descendant)
                this.changeTitle(descendant)
                this.linkParentNote(descendant)
              }
            }
          )
        } catch (error) {
          MNUtil.showHUD(error);
          MNLog.error(error, "KnowledgeBaseTemplate: oldChildrenMakeNotes");
        }
      })
    }
  }

  static checkProofInReview(note) {
    let proofAreaIndexArr = this.getHtmlCommentExcludingFieldBlockIndexArr(note, "è¯æ˜");
    let unreviewNotesArr = []
    if (proofAreaIndexArr.length > 0) {
      note.MNComments.forEach(
        (comment, index) => {
          if (comment.type === "linkComment" && proofAreaIndexArr.includes(index)) {
            let linkedNote = MNNote.new(comment.text)
            if (linkedNote && !MNUtil.isNoteInReview(linkedNote.noteId)) {
              unreviewNotesArr.push(linkedNote)
            }
          }
        }
      )
    }
    if (unreviewNotesArr.length > 0) {
      let config = {
        title: "è¯æ˜ç›¸å…³å¡ç‰‡ä¸­æœªåŠ å…¥å¤ä¹ å¡ç‰‡çš„",
        content: "",
        markdown: true,
        color: note.colorIndex
      }
      let newNote = note.createChildNote(config)
      unreviewNotesArr.forEach(
        note => {
          
          note.appendNoteLink(newNote, "From")
        }
      )
    }
  }

  /**
   * æŠŠå½’ç±»å¡ç‰‡è½¬ä¸ºå®šä¹‰å¡ç‰‡
   */
  static convertClassificationNoteToDefinitionNote(note) {
    try {
      if (!this.getNoteType(note) === "å½’ç±»") {
        MNUtil.showHUD("âŒ åªèƒ½è½¬æ¢å½’ç±»å¡ç‰‡");
        return;
      }
      let parsedTitle = this.parseNoteTitle(note)
      note.title = parsedTitle.content
    
      /**
       * æ›¿æ¢â€œåŒ…å«â€å­—æ®µä¸º"ç›¸å…³é“¾æ¥"
       */

      let includingHtmlCommentIndex = note.getIncludingHtmlCommentIndex("åŒ…å«")

      note.removeCommentByIndex(includingHtmlCommentIndex)

      this.cloneAndMergeById(note, "marginnote4app://note/557824A5-AD9F-4D5E-8254-3DA8C6F9D2B8")

      note.moveComment(note.comments.length - 1, includingHtmlCommentIndex)

      // æœ€åå†åˆ ï¼Œé˜²æ­¢å½±å“å‰é¢
      let deleteCommentIndexArr = this.getHtmlCommentIncludingFieldBlockIndexArr(note, "æ‰€å±")
      note.removeCommentsByIndexArr(deleteCommentIndexArr)

      this.changeTitle(note, false, "å®šä¹‰") // ä¿®æ”¹å¡ç‰‡æ ‡é¢˜
      this.changeNoteColor(note, "å®šä¹‰") // ä¿®æ”¹å¡ç‰‡é¢œè‰²
      this.linkParentNote(note) // é“¾æ¥å¹¿ä¹‰çš„çˆ¶å¡ç‰‡ï¼ˆå¯èƒ½æ˜¯é“¾æ¥å½’ç±»å¡ç‰‡ï¼‰
      this.refreshNotes(note) // åˆ·æ–°å¡ç‰‡

      return note
    } catch (error) {
      MNLog.error(error, "KnowledgeBaseTemplate: convertClassificationNoteToDefinitionNote");
    }
  }

  static mergeIntoSummaryNote(note) {
    let summaryNote = note.parentNote
    if (summaryNote.title == "summary" || summaryNote.title == "Summary") {
      MNUtil.undoGrouping(()=>{
        summaryNote.title = note.title
        note.title = ""
        summaryNote.colorIndex = note.colorIndex
        note.mergeInto(summaryNote)
      })
    }
  }
}

/**
 * çŸ¥è¯†åº“ç´¢å¼•å™¨ - ç”¨äºæ„å»ºå’Œç®¡ç†æœç´¢ç´¢å¼•
 */
class KnowledgeBaseIndexer {
  /**
   * æ¸…ç†æ–‡æœ¬ä¸­çš„é«˜äº®æ ‡è®°
   * MarginNote å†…éƒ¨ä½¿ç”¨ __HL_æ•°å­—_æ•°å­—__ æ ¼å¼æ ‡è®°æ–‡æœ¬æ ·å¼
   * è¿™äº›æ ‡è®°åœ¨æ„å»ºç´¢å¼•æ—¶éœ€è¦æ¸…ç†ï¼Œé¿å…æ˜¾ç¤ºä¹±ç 
   *
   * @param {string} text - è¦æ¸…ç†çš„æ–‡æœ¬
   * @returns {string} æ¸…ç†åçš„æ–‡æœ¬
   */
  static cleanHighlightMarkers(text) {
    if (!text) return "";
    // ç§»é™¤ MarginNote å†…éƒ¨çš„é«˜äº®æ ‡è®°ï¼š__HL_æ•°å­—_æ•°å­—__
    return text.replace(/__HL_\d+_\d+__/g, "");
  }

  /**
   * è§£ç  HTML å®ä½“ä¸ºåŸå§‹å­—ç¬¦
   * ç¡®ä¿å­˜å‚¨çš„æ ‡é¢˜æ˜¯åŸå§‹æ–‡æœ¬æ ¼å¼ï¼Œé¿å… HTML å®ä½“è¢«åŒé‡è½¬ä¹‰
   *
   * @param {string} text - å¯èƒ½åŒ…å« HTML å®ä½“çš„æ–‡æœ¬ï¼ˆå¦‚ &lt;ã€&gt;ã€&amp; ç­‰ï¼‰
   * @returns {string} - è§£ç åçš„åŸå§‹æ–‡æœ¬
   *
   * @example
   * // è¾“å…¥: "&lt;Tx, y&gt;=&lt;x, Sy&gt;"
   * // è¾“å‡º: "<Tx, y>=<x, Sy>"
   */
  static decodeHtmlEntities(text) {
    if (!text) return "";

    // HTML å®ä½“æ˜ å°„è¡¨ï¼ˆå¸¸ç”¨å®ä½“ï¼‰
    const entities = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '&quot;': '"',
      '&apos;': "'",
      '&nbsp;': ' ',
      '&copy;': 'Â©',
      '&reg;': 'Â®',
      '&trade;': 'â„¢'
    };

    // æ›¿æ¢å‘½åå®ä½“ã€åè¿›åˆ¶æ•°å­—å®ä½“å’Œåå…­è¿›åˆ¶æ•°å­—å®ä½“
    return text
      .replace(/&[a-zA-Z]+;/g, (match) => entities[match] || match)
      .replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec))
      .replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)));
  }

  /**
   * æ„å»ºæœç´¢ç´¢å¼•ï¼ˆå¼‚æ­¥åˆ†ç‰‡ç‰ˆæœ¬ï¼‰
   * @param {Array<string>|MNNote} rootNotes - æ ¹å¡ç‰‡
   * @param {Array<string>} targetTypes - ç›®æ ‡å¡ç‰‡ç±»å‹æ•°ç»„ï¼Œå¦‚ ["å®šä¹‰", "å‘½é¢˜", "å½’ç±»"]
   * @param {string} mode - ç´¢å¼•æ¨¡å¼: "light" (è½»é‡ï¼Œé»˜è®¤) æˆ– "full" (å…¨é‡ï¼Œå«åŒä¹‰è¯æ‰©å±•)
   * @returns {Promise<Object>} åŒ…å«metadataçš„ä¸»ç´¢å¼•å¯¹è±¡
   */
  static async buildSearchIndex(rootNotes, targetTypes = ["å®šä¹‰", "å‘½é¢˜", "ä¾‹å­", "åä¾‹", "å½’ç±»", "æ€æƒ³æ–¹æ³•", "é—®é¢˜"], mode = "light") {
    // æ˜¾ç¤ºæ„å»ºæç¤º
    MNUtil.showHUD(`æ­£åœ¨æ„å»º${mode === "full" ? "å…¨é‡" : "è½»é‡"}ç´¢å¼•...`);

    const BATCH_SIZE = 500;  // é™ä½åˆ° 500ï¼Œæ›´é¢‘ç¹åœ°æ¸…ç†å†…å­˜
    const TEMP_FILE_PREFIX = "kb-index-temp-";
    const PART_SIZE = 5000;  // æ¯ä¸ªæœ€ç»ˆåˆ†ç‰‡åŒ…å« 5000 ä¸ªå¡ç‰‡

    const manifest = {
      metadata: {
        version: "3.0",  // æ–°ç‰ˆæœ¬å·
        lastUpdated: new Date().toISOString(),
        updateTime: Math.floor(Date.now() / 1000),  // ğŸ†• æ·»åŠ ç§’çº§æ—¶é—´æˆ³
        totalCards: 0,
        targetTypes: targetTypes,
        partSize: PART_SIZE,
        totalParts: 0,
        tempFiles: []  // è®°å½•ä¸´æ—¶æ–‡ä»¶
      },
      parts: []
    };
    
    try {
      let tempFileCount = 0;
      let currentBatch = [];
      let processedCount = 0;
      let validCount = 0;
      let totalEstimatedCount = 0;
      const processedIds = new Set();  // ä½¿ç”¨ Set è€Œé Map èŠ‚çœå†…å­˜
      
      // å…ˆåˆ›å»ºæ‰€æœ‰ rootNote å¯¹è±¡å¹¶ç¼“å­˜ï¼ˆé¿å…é‡å¤åˆ›å»ºå¯¼è‡´ descendants ä¸¢å¤±ï¼‰
      const rootNoteObjects = [];
      for (const _rootNote of rootNotes) {
        const rootNote = MNNote.new(_rootNote);
        if (!rootNote) {
          MNLog.error({
            message: "æ— æ³•åˆ›å»º MNNote å¯¹è±¡ï¼Œè·³è¿‡æ­¤æ ¹å¡ç‰‡",
            source: "KnowledgeBaseIndexer"
          });
          continue;
        }

        // ğŸ†• æ·»åŠ è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
        MNLog.info({
          message: "å¼€å§‹å¤„ç†æ ¹å¡ç‰‡",
          source: "KnowledgeBaseIndexer",
          detail: {
            noteId: rootNote.noteId,
            noteTitle: rootNote.noteTitle,
            childNotesCount: rootNote.childNotes?.length || 0
          }
        });

        // ğŸ†• ä½¿ç”¨ try-catch æ•è· descendantNodes å¯èƒ½çš„æ ˆæº¢å‡ºé”™è¯¯
        let descendantResult;
        try {
          // è·å– descendants å¹¶ç¼“å­˜
          descendantResult = rootNote.descendantNodes;
        } catch (error) {
          // æ•è·æ ˆæº¢å‡ºé”™è¯¯ï¼ˆé€šå¸¸æ˜¯å¾ªç¯å¼•ç”¨å¯¼è‡´ï¼‰
          const errorMsg = error?.message || String(error);
          if (errorMsg.includes("Maximum call stack") || errorMsg.includes("stack")) {
            MNLog.error({
              message: "è·å– descendants æ—¶å‘ç”Ÿæ ˆæº¢å‡ºï¼ˆå¯èƒ½å­˜åœ¨å¾ªç¯å¼•ç”¨ï¼‰",
              source: "KnowledgeBaseIndexer",
              detail: {
                noteId: rootNote.noteId,
                noteTitle: rootNote.noteTitle,
                errorMessage: errorMsg,
                errorStack: error?.stack
              }
            });
          } else {
            MNLog.error({
              message: "è·å– descendants å¤±è´¥",
              source: "KnowledgeBaseIndexer",
              detail: {
                noteId: rootNote.noteId,
                noteTitle: rootNote.noteTitle,
                errorMessage: errorMsg,
                errorStack: error?.stack
              }
            });
          }
          continue;
        }

        // ğŸ†• æ£€æŸ¥ descendantNodes è¿”å›å€¼
        if (!descendantResult) {
          MNLog.error({
            message: "descendantNodes è¿”å› undefined",
            source: "KnowledgeBaseIndexer",
            detail: {
              noteId: rootNote.noteId,
              noteTitle: rootNote.noteTitle,
              hasChildNotes: !!rootNote.childNotes,
              childNotesType: typeof rootNote.childNotes
            }
          });
          continue;
        }

        const descendants = descendantResult.descendant || [];
        MNLog.info({
          message: "æˆåŠŸè·å– descendants",
          source: "KnowledgeBaseIndexer",
          detail: {
            noteId: rootNote.noteId,
            noteTitle: rootNote.noteTitle,
            descendantsCount: descendants.length
          }
        });

        totalEstimatedCount += descendants.length + 1;  // +1 æ˜¯æ ¹èŠ‚ç‚¹æœ¬èº«

        // ç¼“å­˜ rootNote å¯¹è±¡å’Œå®ƒçš„ descendants
        rootNoteObjects.push({
          rootNote: rootNote,
          descendants: descendants
        });
      }

      // ğŸ†• å…¨é‡æ¨¡å¼å¯åŠ¨æç¤ºï¼šå‘ŠçŸ¥ç”¨æˆ·åŒä¹‰è¯æ‰©å±•ä¼šè€—æ—¶è¾ƒé•¿
      if (mode === "full") {
        MNUtil.showHUD("ğŸ”„ å…¨é‡æ¨¡å¼ï¼šå°†è¿›è¡ŒåŒä¹‰è¯æ‰©å±•ï¼ˆè€—æ—¶è¾ƒé•¿ï¼Œè¯·è€å¿ƒç­‰å¾…ï¼‰");
        await MNUtil.delay(2);  // ç»™ç”¨æˆ· 2 ç§’é˜…è¯»æ—¶é—´
      }

      // æ˜¾ç¤ºåˆå§‹è¿›åº¦
      this.showProgressHUD(0, totalEstimatedCount, "å¼€å§‹æ„å»ºç´¢å¼•");
      
      // æµå¼å¤„ç†æ¯ä¸ªç¼“å­˜çš„æ ¹èŠ‚ç‚¹
      for (let rootIndex = 0; rootIndex < rootNoteObjects.length; rootIndex++) {
        const { rootNote, descendants } = rootNoteObjects[rootIndex];
        
        // å…ˆå¤„ç†æ ¹èŠ‚ç‚¹æœ¬èº«
        if (!processedIds.has(rootNote.noteId)) {
          const noteType = KnowledgeBaseTemplate.getNoteType(rootNote);
          if (noteType && targetTypes.includes(noteType)) {
            const entry = this.buildIndexEntry(rootNote, mode);
            if (entry) {
              currentBatch.push(entry);
              validCount++;
            }
          }
          processedIds.add(rootNote.noteId);
          processedCount++;
        }
        
        // åˆ†æ‰¹å¤„ç†å­å­™èŠ‚ç‚¹
        for (let i = 0; i < descendants.length; i++) {
          const descendant = descendants[i];
          
          // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜å½“å‰æ‰¹æ¬¡åˆ°ä¸´æ—¶æ–‡ä»¶
          if (currentBatch.length >= BATCH_SIZE) {
            // ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶
            const tempFileName = `${TEMP_FILE_PREFIX}${tempFileCount}.json`;
            const tempFilePath = MNUtil.tempFolder + "/" + tempFileName;
            
            MNUtil.writeJSON(tempFilePath, {
              batchNumber: tempFileCount,
              data: currentBatch,
              count: currentBatch.length
            });
            
            manifest.metadata.tempFiles.push(tempFileName);
            tempFileCount++;
            
            // æ¸…ç©ºå½“å‰æ‰¹æ¬¡ï¼Œé‡Šæ”¾å†…å­˜
            currentBatch = [];
            
            // æ˜¾ç¤ºè¿›åº¦
            this.showProgressHUD(processedCount, totalEstimatedCount, 
                                `å¤„ç†ä¸­... å·²ä¿å­˜ ${tempFileCount} ä¸ªä¸´æ—¶æ–‡ä»¶`);
            
            // ç»™ UI æ—¶é—´æ›´æ–°
            await MNUtil.delay(0.001);
          }
          
          // å¤„ç†å•ä¸ªèŠ‚ç‚¹
          const noteId = descendant.noteId || descendant;
          if (processedIds.has(noteId)) {
            processedCount++;
            continue;
          }
          
          // åªåœ¨éœ€è¦æ—¶åˆ›å»º MNNote å¯¹è±¡
          const mnNote = MNNote.new(descendant);
          if (!mnNote || !mnNote.noteId) {
            processedCount++;
            continue;
          }
          
          const noteType = KnowledgeBaseTemplate.getNoteType(mnNote);
          if (!noteType || !targetTypes.includes(noteType)) {
            processedCount++;
            processedIds.add(noteId);
            continue;
          }

          const entry = this.buildIndexEntry(mnNote, mode);
          if (entry) {
            currentBatch.push(entry);
            validCount++;
          }
          
          processedIds.add(noteId);
          processedCount++;

          // æ¯å¤„ç† 100 ä¸ªèŠ‚ç‚¹æ›´æ–°ä¸€æ¬¡è¿›åº¦
          if (processedCount % 100 === 0) {
            // ğŸ†• å…¨é‡æ¨¡å¼æç¤ºåŒä¹‰è¯æ‰©å±•
            const message = mode === "full"
              ? `å¤„ç†ä¸­ï¼ˆå«åŒä¹‰è¯æ‰©å±•ï¼‰... (${tempFileCount} ä¸ªä¸´æ—¶æ–‡ä»¶)`
              : `å¤„ç†ä¸­... (${tempFileCount} ä¸ªä¸´æ—¶æ–‡ä»¶)`;

            this.showProgressHUD(processedCount, totalEstimatedCount, message);
          }
        }
        
        // é‡Šæ”¾ descendants å¼•ç”¨ï¼Œå¸®åŠ©åƒåœ¾å›æ”¶
        descendants.length = 0;
      }
      
      // ä¿å­˜æœ€åä¸€æ‰¹åˆ°ä¸´æ—¶æ–‡ä»¶
      if (currentBatch.length > 0) {
        const tempFileName = `${TEMP_FILE_PREFIX}${tempFileCount}.json`;
        const tempFilePath = MNUtil.tempFolder + "/" + tempFileName;
        
        MNUtil.writeJSON(tempFilePath, {
          batchNumber: tempFileCount,
          data: currentBatch,
          count: currentBatch.length
        });
        
        manifest.metadata.tempFiles.push(tempFileName);
        tempFileCount++;
      }
      
      // åˆå¹¶ä¸´æ—¶æ–‡ä»¶åˆ°æœ€ç»ˆåˆ†ç‰‡
      MNUtil.showHUD(`æ­£åœ¨åˆå¹¶${mode === "full" ? "å…¨é‡" : "è½»é‡"}ç´¢å¼•æ–‡ä»¶...`);
      await this.mergeTempFilesToParts(manifest, mode);

      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      await this.cleanupTempFiles(manifest.metadata.tempFiles);

      // æ›´æ–°å…ƒæ•°æ®
      manifest.metadata.totalCards = validCount;

      // ä¿å­˜ä¸»ç´¢å¼•æ–‡ä»¶
      await this.saveIndexManifest(manifest, mode);

      // æ¸…ç©ºå¢é‡ç´¢å¼•ï¼ˆå…¨å±€ç´¢å¼•å·²åŒ…å«æ‰€æœ‰å¡ç‰‡ï¼‰
      this.clearIncrementalIndex();

      // ğŸ†• ä¿å­˜å½“å‰æ„å»ºçš„ç´¢å¼•æ¨¡å¼åˆ°é…ç½®ï¼ˆç¡®ä¿ WebView èƒ½æ­£ç¡®åŠ è½½ï¼‰
      KnowledgeBaseConfig.config.searchIndexMode = mode;
      KnowledgeBaseConfig.save();
      MNUtil.log(`âœ… å·²å°†æœç´¢ç´¢å¼•æ¨¡å¼è®¾ç½®ä¸º: ${mode}`);

      MNUtil.showHUD(`${mode === "full" ? "å…¨é‡" : "è½»é‡"}ç´¢å¼•æ„å»ºå®Œæˆï¼šå…± ${validCount} å¼ å¡ç‰‡ï¼Œ${manifest.metadata.totalParts} ä¸ªåˆ†ç‰‡`);

    } catch (error) {
      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      if (manifest.metadata.tempFiles && manifest.metadata.tempFiles.length > 0) {
        await this.cleanupTempFiles(manifest.metadata.tempFiles);
      }
      // ğŸ†• å¤„ç† error ä¸º undefined çš„æƒ…å†µ
      const errorMessage = error?.message || String(error) || "æœªçŸ¥é”™è¯¯";
      const errorDetails = {
        message: error?.message || "æœªçŸ¥é”™è¯¯",
        stack: error?.stack || "æ— å †æ ˆä¿¡æ¯",
        type: typeof error,
        raw: error
      };

      MNUtil.showHUD("æ„å»ºç´¢å¼•å¤±è´¥: " + errorMessage);
      MNLog.error({
        message: "ç´¢å¼•æ„å»ºå¤±è´¥",
        source: "KnowledgeBaseIndexer: buildSearchIndex",
        detail: errorDetails
      });
      return null;
    }
    
    return manifest;
  }
  
  /**
   * æ„å»ºå•ä¸ªå¡ç‰‡çš„ç´¢å¼•æ¡ç›®
   * @private
   * @param {MNNote} note - è¦å»ºç«‹ç´¢å¼•çš„å¡ç‰‡
   * @param {string} mode - ç´¢å¼•æ¨¡å¼: "light" (è½»é‡) æˆ– "full" (å…¨é‡ï¼Œå«åŒä¹‰è¯æ‰©å±•)
   */
  static buildIndexEntry(note, mode = "light") {
    // åŸºæœ¬é˜²å¾¡æ€§æ£€æŸ¥
    if (!note || !note.noteId) {
      KnowledgeBaseUtils.log(`é˜²å¾¡æ€§æ£€æŸ¥æ²¡é€šè¿‡`, "buildIndexEntry");
      return null;
    }

    // åˆå§‹åŒ–åŸºæœ¬æ¡ç›®ä¿¡æ¯
    let entry = {
      id: note.noteId,
      type: undefined,
      title: this.decodeHtmlEntities(this.cleanHighlightMarkers(note.title || "")),
      parentId: note.parentNoteId || null
    };

    try {
      // è·å–å¡ç‰‡ç±»å‹
      const noteType = KnowledgeBaseTemplate.getNoteType(note);
      entry.type = noteType;

      // âœ… è¿‡æ»¤æ‰ noteType ä¸º undefined çš„å¡ç‰‡
      if (!noteType) {
        // KnowledgeBaseUtils.log(`è·³è¿‡æ— ç±»å‹å¡ç‰‡: ${note.noteId}`, "buildIndexEntry");
        return null;
      }

      // è§£ææ ‡é¢˜
      const parsedTitle = KnowledgeBaseTemplate.parseNoteTitle(note) || {};

      // è·å–å…³é”®è¯
      const keywordsContent = KnowledgeBaseTemplate.getKeywordsFromNote(note) || "";

      // æ ¹æ®å¡ç‰‡ç±»å‹è®¾ç½®ä¸åŒå­—æ®µ
      if (noteType === "å½’ç±»") {
        entry.classificationSubtype = parsedTitle.type || "";
        entry.content = parsedTitle.content || "";
      } else {
        if (parsedTitle.prefixContent) {
          entry.prefix = parsedTitle.prefixContent;
        }
        if (parsedTitle.titleLinkWordsArr && parsedTitle.titleLinkWordsArr.length > 0) {
          entry.titleLinkWords = parsedTitle.titleLinkWordsArr.join("; ");
        }
      }

      // æ·»åŠ å…³é”®è¯
      if (keywordsContent) {
        entry.keywords = keywordsContent;
      }

      // æ„å»ºæœç´¢æ–‡æœ¬ï¼ˆåŸºç¡€ç‰ˆæœ¬ï¼‰
      entry.searchText = this.buildSearchText(parsedTitle, noteType, keywordsContent);

      // ğŸ†• å…¨é‡æ¨¡å¼ï¼šæ‰©å±•åŒä¹‰è¯
      if (mode === "full") {
        entry.searchText = this.expandSearchTextWithSynonyms(entry.searchText);
      }

      // âœ… è¿‡æ»¤æ‰æœç´¢æ–‡æœ¬ä¸ºç©ºæˆ–åªæœ‰ç±»å‹åçš„å¡ç‰‡
      // ç§»é™¤ç±»å‹ååï¼Œå¦‚æœæ²¡æœ‰å®è´¨æ€§å†…å®¹ï¼Œåˆ™è¿‡æ»¤æ‰
      const searchTextWithoutType = entry.searchText.replace(new RegExp(`^${noteType}\\s*`, 'i'), '').trim();
      if (!searchTextWithoutType) {
        // KnowledgeBaseUtils.log('ç§»é™¤ç±»å‹ååï¼Œå¦‚æœæ²¡æœ‰å®è´¨æ€§å†…å®¹', "KnowledgeBaseIndexer: buildIndexEntry");
        return null;
      }

      // ========================================
      // ğŸ“¦ é¢„å¤„ç†æ’é™¤è¯ç»„ä¿¡æ¯ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
      // ========================================
      //
      // åœ¨ç´¢å¼•æ„å»ºé˜¶æ®µï¼Œé¢„å…ˆåˆ†ææ¯å¼ å¡ç‰‡çš„æ’é™¤è¯æ±¡æŸ“æƒ…å†µï¼Œé¿å…æœç´¢æ—¶é‡å¤è®¡ç®—ã€‚
      //
      // ä¸ºä»€ä¹ˆéœ€è¦é¢„å¤„ç†ï¼Ÿ
      // 1. æ€§èƒ½ä¼˜åŒ–ï¼šç´¢å¼•æ„å»ºæ—¶è®¡ç®—ä¸€æ¬¡ï¼Œæœç´¢æ—¶ç›´æ¥ä½¿ç”¨ï¼ˆé¿å…é‡å¤åˆ†æï¼‰
      // 2. æ•°æ®ä¸€è‡´æ€§ï¼šç¡®ä¿ç´¢å¼•å’Œæœç´¢ä½¿ç”¨ç›¸åŒçš„æ’é™¤é€»è¾‘
      // 3. å¯è¿½æº¯æ€§ï¼šå¯åœ¨è°ƒè¯•æ—¶æŸ¥çœ‹æ¯å¼ å¡ç‰‡çš„æ’é™¤è¯ä¿¡æ¯
      //
      // entry.excludedGroups æ•°æ®ç»“æ„ï¼š
      // [
      //   {
      //     triggerWords: ["ğ”»", "å¼€å•ä½åœ†ç›˜", "å•ä½åœ†ç›˜"],  // å®Œæ•´è§¦å‘è¯åˆ—è¡¨ï¼ˆç»„è¯†åˆ«ï¼‰
      //     excludeWords: ["é—­å•ä½åœ†ç›˜"],                  // å¡ç‰‡åŒ…å«çš„æ’é™¤è¯
      //     affectedTriggers: ["å•ä½åœ†ç›˜"]                // è¢«æ±¡æŸ“çš„è§¦å‘è¯ï¼ˆæ’é™¤ä¾æ®ï¼‰
      //   }
      // ]
      //
      // æœç´¢æ—¶çš„ä½¿ç”¨é€»è¾‘ï¼š
      // - ç”¨æˆ·æœç´¢"å•ä½åœ†ç›˜"æ—¶ï¼Œæ¿€æ´»è¯¥æ’é™¤è¯ç»„
      // - ç³»ç»Ÿæ£€æŸ¥å¡ç‰‡çš„ affectedTriggers æ˜¯å¦åŒ…å«"å•ä½åœ†ç›˜"
      // - å¦‚æœåŒ…å«ï¼Œåˆ™æ’é™¤è¯¥å¡ç‰‡ï¼ˆå®Œå…¨æ±¡æŸ“ï¼‰
      // - å¦‚æœä¸åŒ…å«ï¼Œåˆ™ä¿ç•™è¯¥å¡ç‰‡ï¼ˆéƒ¨åˆ†æ±¡æŸ“æˆ–æ— æ±¡æŸ“ï¼‰
      //
      const applicableGroups = this.analyzeExclusionGroups(entry.searchText);
      if (applicableGroups.length > 0) {
        entry.excludedGroups = applicableGroups;
      }

      return entry;

    } catch (error) {
      // é™é»˜å¤±è´¥ï¼Œè¿”å› nullï¼ˆä¸ç´¢å¼•å‡ºé”™çš„å¡ç‰‡ï¼‰
      KnowledgeBaseUtils.addErrorLog(error, "KnowledgeBaseIndexer: buildIndexEntry");
      return null;
    }
  }
  
  /**
   * æ„å»ºæœç´¢æ–‡æœ¬
   * @private
   * @param {Object} parsedTitle - è§£æåçš„æ ‡é¢˜
   * @param {string} noteType - ç¬”è®°ç±»å‹
   * @param {string} keywordsContent - å…³é”®è¯å†…å®¹
   */
  static buildSearchText(parsedTitle, noteType, keywordsContent) {
    let searchableContent = "";
    
    if (noteType === "å½’ç±»") {
      // å½’ç±»å¡ç‰‡ï¼šä½¿ç”¨contentï¼ˆå¼•å·å†…çš„å†…å®¹ï¼‰+ ç±»å‹
      searchableContent = `${parsedTitle.content || ""} ${parsedTitle.type || ""}`.trim();
    } else {
      // å…¶ä»–å¡ç‰‡ç±»å‹ï¼ˆå®šä¹‰ã€å‘½é¢˜ç­‰ï¼‰ï¼šåŒ…å«å‰ç¼€å†…å®¹å’Œæ ‡é¢˜é“¾æ¥è¯
      let contentParts = [];
      
      // é‡è¦ï¼šæ·»åŠ å‰ç¼€å†…å®¹ï¼ˆè¿™æ˜¯å®šä¹‰å¡ç‰‡çš„ä¸»è¦å†…å®¹ï¼‰
      if (parsedTitle.prefixContent) {
        contentParts.push(parsedTitle.prefixContent);
      }
      
      // æ·»åŠ æ ‡é¢˜é“¾æ¥è¯
      if (parsedTitle.titleLinkWordsArr && parsedTitle.titleLinkWordsArr.length > 0) {
        contentParts.push(...parsedTitle.titleLinkWordsArr);
      }
      
      // å¦‚æœéƒ½æ²¡æœ‰ï¼Œä½¿ç”¨ content
      if (contentParts.length === 0 && parsedTitle.content) {
        contentParts.push(parsedTitle.content);
      }
      
      searchableContent = contentParts.join(" ");
    }
    
    // å¤„ç†å…³é”®è¯
    const keywordsForSearch = keywordsContent.replace(/[;ï¼›]/g, " ");

    // åœ¨æœç´¢æ–‡æœ¬ä¸­åŒ…å«ç±»å‹ä¿¡æ¯ï¼Œè¿™æ ·ç”¨æˆ·å¯ä»¥é€šè¿‡è¾“å…¥ç±»å‹åç§°æ¥ç­›é€‰
    const typeInfo = noteType ? `${noteType} ` : "";

    // ç®€åŒ–ç‰ˆï¼šç»„åˆç±»å‹ã€åŸå†…å®¹å’Œå…³é”®è¯
    const finalText = `${typeInfo}${searchableContent} ${keywordsForSearch}`.trim().toLowerCase();

    return finalText;
  }

  /**
   * æ‰©å±•æœç´¢æ–‡æœ¬ï¼ˆç´¢å¼•æ—¶é¢„å¤„ç†åŒä¹‰è¯ï¼‰
   * ç”¨äºå…¨é‡ç´¢å¼•æ¨¡å¼ï¼Œåœ¨æ„å»ºç´¢å¼•æ—¶é¢„å…ˆå±•å¼€æ‰€æœ‰åŒä¹‰è¯
   *
   * @param {string} text - åŸå§‹æœç´¢æ–‡æœ¬
   * @returns {string} æ‰©å±•åçš„æœç´¢æ–‡æœ¬ï¼ˆåŒ…å«æ‰€æœ‰åŒä¹‰è¯ï¼‰
   *
   * @example
   * expandSearchTextWithSynonyms("ä¸¤ä¸¤ä¸åŒ é›†åˆ")
   * // è¿”å›: "ä¸¤ä¸¤ä¸åŒ ä¸¤ä¸¤ä¸ç­‰ äº’ä¸ç›¸ç­‰ å„ä¸ç›¸åŒ é›†åˆ"
   */
  static expandSearchTextWithSynonyms(text) {
    if (!text || !text.trim()) return text;

    try {
      const expandedWords = new Set();
      const groups = SynonymManager.getSynonymGroups();

      // ğŸ†• æ–°é€»è¾‘ï¼šä½¿ç”¨å­ä¸²åŒ¹é…è€Œéç²¾ç¡®è¯åŒ¹é…
      // éå†æ‰€æœ‰åŒä¹‰è¯ç»„ï¼Œæ£€æŸ¥æ–‡æœ¬æ˜¯å¦åŒ…å«è¯¥ç»„ä¸­çš„ä»»æ„è¯
      groups.forEach(group => {
        const foundWord = group.words.find(word =>
          text.toLowerCase().includes(word.toLowerCase())
        );

        if (foundWord) {
          // å¦‚æœæ‰¾åˆ°åŒ¹é…ï¼Œæ·»åŠ è¯¥ç»„çš„æ‰€æœ‰åŒä¹‰è¯
          group.words.forEach(syn => {
            if (syn && syn.trim()) {
              expandedWords.add(syn.toLowerCase());
            }
          });

          // ç”Ÿæˆå±€éƒ¨æ›¿æ¢å˜ä½“ï¼ˆæ”¯æŒ ||x|| â†’ â€–xâ€–ï¼‰
          if (group.partialReplacement) {
            const partialVariants = KnowledgeBaseTemplate.generatePartialReplacements(text, group);
            partialVariants.forEach(variant => {
              if (variant && variant.trim()) {
                // å°†æ–‡æœ¬å˜ä½“æ‹†åˆ†ä¸ºå•è¯ï¼Œé€ä¸ªæ·»åŠ åˆ°é›†åˆä¸­ï¼ˆé¿å…å®Œæ•´å¥å­é€ æˆé‡å¤ï¼‰
                const words = variant.split(/\s+/).filter(w => w.length > 0);
                words.forEach(word => expandedWords.add(word.toLowerCase()));
              }
            });
          }
        }
      });

      // æ·»åŠ åŸå§‹æ–‡æœ¬çš„æ‰€æœ‰è¯ï¼ˆä¿ç•™åŸæœ‰å†…å®¹ï¼‰
      const originalWords = text.split(/\s+/).filter(w => w.length > 0);
      originalWords.forEach(word => expandedWords.add(word));

      // å°†æ‰©å±•åçš„è¯æ±‡é‡æ–°ç»„åˆï¼ˆä½¿ç”¨ç©ºæ ¼åˆ†éš”ï¼‰
      return Array.from(expandedWords).join(" ");

    } catch (error) {
      // æ‰©å±•å¤±è´¥æ—¶è¿”å›åŸæ–‡æœ¬
      KnowledgeBaseUtils.addErrorLog(error, "KnowledgeBaseIndexer: expandSearchTextWithSynonyms");
      return text;
    }
  }

  /**
   * æ‰©å±•æœç´¢æŸ¥è¯¢ï¼ˆæœç´¢æ—¶åŠ¨æ€å¤„ç†åŒä¹‰è¯ï¼‰
   * @param {string} query - ç”¨æˆ·è¾“å…¥çš„æœç´¢è¯
   * @param {boolean} useSynonyms - æ˜¯å¦ä½¿ç”¨åŒä¹‰è¯æ‰©å±•
   * @returns {string} æ‰©å±•åçš„æœç´¢æŸ¥è¯¢
   */
  static expandSearchQuery(query, useSynonyms = false) {
    if (!useSynonyms || !query) return query;
    
    try {
      // å…ˆæ£€æŸ¥æ˜¯å¦å·²ç»åŒ…å«æœç´¢è¯­æ³•ç¬¦å·ï¼Œå¦‚æœæœ‰åˆ™ä¸æ‰©å±•
      if (query.includes('væ–¹æ ¹') || query.includes('//') || query.includes(';;') || query.includes('!!') || query.includes('[[') || query.includes("{{")) {
        return query;
      }
      
      // ä¸è¿›è¡Œåˆ†è¯ï¼ä¿æŒç”¨æˆ·è¾“å…¥çš„å®Œæ•´æ€§
      // åªå°è¯•ä¸ºæ•´ä¸ªæŸ¥è¯¢è¯æŸ¥æ‰¾åŒä¹‰è¯
      const expandedTerms = new Set([query.toLowerCase()]);
      
      // å°è¯•è·å–æ•´ä¸ªæŸ¥è¯¢è¯çš„åŒä¹‰è¯
      const synonyms = SynonymManager.expandKeyword(query, true);
      synonyms.forEach(s => expandedTerms.add(s.toLowerCase()));
      
      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒä¹‰è¯ï¼ˆåªæœ‰åŸè¯ï¼‰ï¼Œç›´æ¥è¿”å›åŸè¯
      if (expandedTerms.size === 1) {
        return query;
      }
      
      // ä½¿ç”¨ ;; (OR) è¿æ¥åŸè¯å’ŒåŒä¹‰è¯
      // è¿™æ ·å¯ä»¥åŒ¹é…åŸè¯æˆ–å…¶åŒä¹‰è¯
      return Array.from(expandedTerms).join(";;");
    } catch (error) {
      MNUtil.log(`æ‰©å±•æœç´¢æŸ¥è¯¢å¤±è´¥: ${error.message}`);
      return query;
    }
  }
  
  /**
   * è¿‡æ»¤æœç´¢ç»“æœï¼ˆæœç´¢æ—¶åŠ¨æ€å¤„ç†æ’é™¤è¯ï¼‰
   * @param {Array} results - æœç´¢ç»“æœæ•°ç»„
   * @param {boolean} useExclusion - æ˜¯å¦ä½¿ç”¨æ’é™¤è¯è¿‡æ»¤
   * @returns {Array} è¿‡æ»¤åçš„ç»“æœ
   */
  static filterSearchResults(results, useExclusion = false) {
    if (!useExclusion || !results || results.length === 0) return results;
    
    try {
      const exclusionGroups = ExclusionManager.getExclusionGroups();
      
      return results.filter(result => {
        // æ£€æŸ¥æ˜¯å¦åº”è¯¥è¢«æ’é™¤
        const searchText = result.searchText || "";
        const applicableGroups = this.analyzeExclusionGroups(searchText, exclusionGroups);
        
        // å¦‚æœæ²¡æœ‰é€‚ç”¨çš„æ’é™¤è¯ç»„ï¼Œä¿ç•™è¿™ä¸ªç»“æœ
        if (applicableGroups.length === 0) {
          return true;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¿…é¡»åŒ…å«ä½†æœªåŒ…å«çš„è¯
        for (const group of applicableGroups) {
          if (group.mustInclude && group.mustInclude.length > 0) {
            const hasMustInclude = group.mustInclude.some(word => 
              searchText.includes(word.toLowerCase())
            );
            if (!hasMustInclude) {
              return false;  // æ’é™¤è¿™ä¸ªç»“æœ
            }
          }
        }
        
        return true;  // ä¿ç•™è¿™ä¸ªç»“æœ
      });
    } catch (error) {
      MNUtil.log(`è¿‡æ»¤æœç´¢ç»“æœå¤±è´¥: ${error.message}`);
      return results;
    }
  }

  /**
   * åˆ†ææœç´¢æ–‡æœ¬ä¸­çš„æ’é™¤è¯ç»„ï¼Œè¯†åˆ«"å®Œå…¨æ±¡æŸ“"å’Œ"éƒ¨åˆ†æ±¡æŸ“"æƒ…å†µ
   *
   * @description
   * è¯¥æ–¹æ³•æ‰«æå¡ç‰‡çš„æœç´¢æ–‡æœ¬ï¼Œåˆ¤æ–­æ˜¯å¦åŒ…å«æ’é™¤è¯ï¼Œå¹¶åŒºåˆ†ä¸¤ç§æ±¡æŸ“æƒ…å†µï¼š
   *
   * **å®Œå…¨æ±¡æŸ“ï¼ˆComplete Pollutionï¼‰**ï¼š
   * - å¡ç‰‡æ–‡æœ¬åŒ…å«æ’é™¤è¯ï¼Œä¸”è§¦å‘è¯åœ¨ç§»é™¤æ’é™¤è¯åæ¶ˆå¤±
   * - ç¤ºä¾‹ï¼šå¡ç‰‡åŒ…å«"é—­å•ä½åœ†ç›˜"ï¼Œç§»é™¤å"å•ä½åœ†ç›˜"ä¸ç‹¬ç«‹å­˜åœ¨
   * - ç»“æœï¼šè¯¥å¡ç‰‡åº”è¢«æ’é™¤ï¼ˆè§¦å‘è¯å®Œå…¨ä¾é™„äºæ’é™¤è¯ï¼‰
   *
   * **éƒ¨åˆ†æ±¡æŸ“ï¼ˆPartial Pollutionï¼‰**ï¼š
   * - å¡ç‰‡æ–‡æœ¬åŒ…å«æ’é™¤è¯ï¼Œä½†è§¦å‘è¯ä»ç‹¬ç«‹å­˜åœ¨
   * - ç¤ºä¾‹ï¼šå¡ç‰‡åŒæ—¶åŒ…å«"é—­å•ä½åœ†ç›˜"å’Œç‹¬ç«‹çš„"å•ä½åœ†ç›˜"
   * - ç»“æœï¼šè¯¥å¡ç‰‡åº”ä¿ç•™ï¼ˆè§¦å‘è¯æœ‰ç‹¬ç«‹å‡ºç°ï¼‰
   *
   * è¿”å›çš„å¯¹è±¡ä¸­åŒ…å«ä¸¤ä¸ªå…³é”®å­—æ®µï¼š
   * - **triggerWords**: è¯¥æ’é™¤è¯ç»„çš„æ‰€æœ‰è§¦å‘è¯ï¼ˆå®Œæ•´åˆ—è¡¨ï¼Œç”¨äºç»„è¯†åˆ«ï¼‰
   * - **affectedTriggers**: å—åˆ°æ±¡æŸ“çš„è§¦å‘è¯åˆ—è¡¨ï¼ˆä»…åŒ…å«å®Œå…¨æ±¡æŸ“çš„è§¦å‘è¯ï¼‰
   *
   * @param {string} searchText - è¦åˆ†æçš„æœç´¢æ–‡æœ¬ï¼ˆå°å†™ï¼‰
   * @param {Array} [exclusionGroups=null] - é¢„åŠ è½½çš„æ’é™¤è¯ç»„ï¼ˆå¯é€‰ï¼Œä¸ä¼ åˆ™è‡ªåŠ¨è·å–ï¼‰
   *
   * @returns {Array<Object>} é€‚ç”¨çš„æ’é™¤è¯ç»„æ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å«ï¼š
   * @returns {string[]} return[].triggerWords - è¯¥ç»„çš„æ‰€æœ‰è§¦å‘è¯ï¼ˆå®Œæ•´åˆ—è¡¨ï¼‰
   * @returns {string[]} return[].excludeWords - åŒ¹é…åˆ°çš„æ’é™¤è¯åˆ—è¡¨
   * @returns {string[]} return[].affectedTriggers - å—æ±¡æŸ“çš„è§¦å‘è¯ï¼ˆå®Œå…¨æ±¡æŸ“ï¼Œéœ€æ’é™¤ï¼‰
   *
   * @example
   * // åœºæ™¯1ï¼šå®Œå…¨æ±¡æŸ“
   * const text1 = "é—­å•ä½åœ†ç›˜çš„æ€§è´¨";
   * const result1 = analyzeExclusionGroups(text1);
   * // result1[0].triggerWords = ["ğ”»", "å¼€å•ä½åœ†ç›˜", "å•ä½åœ†ç›˜"]
   * // result1[0].affectedTriggers = ["å•ä½åœ†ç›˜"]  // è¢«å®Œå…¨æ±¡æŸ“
   *
   * // åœºæ™¯2ï¼šéƒ¨åˆ†æ±¡æŸ“ï¼ˆè§¦å‘è¯ç‹¬ç«‹å­˜åœ¨ï¼‰
   * const text2 = "é—­å•ä½åœ†ç›˜æ˜¯å•ä½åœ†ç›˜çš„é—­åŒ…";
   * const result2 = analyzeExclusionGroups(text2);
   * // result2[0].triggerWords = ["ğ”»", "å¼€å•ä½åœ†ç›˜", "å•ä½åœ†ç›˜"]
   * // result2[0].affectedTriggers = []  // è§¦å‘è¯ç‹¬ç«‹å­˜åœ¨ï¼Œä¸æ’é™¤
   *
   * @see shouldExcludeCard - ä½¿ç”¨è¯¥æ–¹æ³•åˆ¤æ–­æ˜¯å¦æ’é™¤å¡ç‰‡
   * @see buildIndexEntry - åœ¨ç´¢å¼•æ„å»ºæ—¶è°ƒç”¨ï¼Œé¢„å¤„ç†å¡ç‰‡çš„æ’é™¤ä¿¡æ¯
   */
  static analyzeExclusionGroups(searchText, exclusionGroups = null) {
    const applicableGroups = [];
    // ä½¿ç”¨ä¼ å…¥çš„æ’é™¤è¯ç»„æˆ–æŒ‰éœ€è·å–
    const groups = exclusionGroups || KnowledgeBaseTemplate.getExclusionGroups();

    for (const group of groups) {
      // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦åŒ…å«è¯¥ç»„çš„ä»»ä½•æ’é™¤è¯
      let containsExcludeWord = false;
      let matchedExcludeWords = [];

      for (const excludeWord of group.excludeWords) {
        if (searchText.includes(excludeWord.toLowerCase())) {
          containsExcludeWord = true;
          matchedExcludeWords.push(excludeWord);
        }
      }

      if (containsExcludeWord) {
        // ğŸ”‘ å…³é”®é€»è¾‘ï¼šæ£€æŸ¥è§¦å‘è¯æ˜¯å¦ç‹¬ç«‹å­˜åœ¨ï¼ˆé€šè¿‡ç§»é™¤æ’é™¤è¯æ¥åˆ¤æ–­ï¼‰
        // ä¾‹å¦‚ï¼šæ–‡æœ¬"é—­å•ä½åœ†ç›˜"ï¼Œç§»é™¤"é—­"åå‰©ä½™"å•ä½åœ†ç›˜"ï¼Œè¯´æ˜"å•ä½åœ†ç›˜"è¢«æ±¡æŸ“
        let tempText = searchText;
        for (const excludeWord of matchedExcludeWords) {
          // å°†æ’é™¤è¯æ›¿æ¢ä¸ºå ä½ç¬¦ï¼Œæ¨¡æ‹Ÿ"ç§»é™¤æ’é™¤è¯"çš„æ•ˆæœ
          tempText = tempText.replace(new RegExp(excludeWord.toLowerCase(), 'gi'), '###EXCLUDED###');
        }

        // ğŸ¯ åˆ†æè§¦å‘è¯çš„æ±¡æŸ“æƒ…å†µ
        // affectedTriggers: è®°å½•è¢«å®Œå…¨æ±¡æŸ“çš„è§¦å‘è¯ï¼ˆç§»é™¤æ’é™¤è¯åæ¶ˆå¤±ï¼‰
        const affectedTriggers = [];
        for (const trigger of group.triggerWords) {
          // âŒ è§¦å‘è¯åœ¨ç§»é™¤æ’é™¤è¯åæ¶ˆå¤± â†’ å®Œå…¨æ±¡æŸ“ï¼Œéœ€æ’é™¤
          if (!tempText.includes(trigger.toLowerCase())) {
            affectedTriggers.push(trigger);
          }
          // âœ… è§¦å‘è¯åœ¨ç§»é™¤æ’é™¤è¯åä»å­˜åœ¨ â†’ éƒ¨åˆ†æ±¡æŸ“æˆ–ç‹¬ç«‹å­˜åœ¨ï¼Œä¿ç•™
        }

        // åªæœ‰å­˜åœ¨å®Œå…¨æ±¡æŸ“çš„è§¦å‘è¯æ—¶ï¼Œæ‰è®°å½•è¯¥ç»„
        if (affectedTriggers.length > 0) {
          applicableGroups.push({
            triggerWords: group.triggerWords,      // å®Œæ•´è§¦å‘è¯åˆ—è¡¨ï¼ˆç”¨äºç»„è¯†åˆ«ï¼‰
            excludeWords: matchedExcludeWords,    // åŒ¹é…åˆ°çš„æ’é™¤è¯
            affectedTriggers: affectedTriggers    // å—æ±¡æŸ“çš„è§¦å‘è¯ï¼ˆæ’é™¤ä¾æ®ï¼‰
          });
        }
      }
    }

    return applicableGroups;
  }
  
  /**
   * æ˜¾ç¤ºè¿›åº¦æ¡å¼ HUD
   */
  static showProgressHUD(current, total, message = "å¤„ç†ä¸­") {
    const percent = Math.round((current / total) * 100);
    const progressBar = this.createProgressBar(percent);
    MNUtil.showHUD(`${message}\n${progressBar}\n${current}/${total} (${percent}%)`);
  }
  
  /**
   * åˆ›å»ºè¿›åº¦æ¡
   */
  static createProgressBar(percent) {
    const barLength = 20;
    const filled = Math.round(barLength * percent / 100);
    const empty = barLength - filled;
    return "â–ˆ".repeat(filled) + "â–‘".repeat(empty);
  }
  
  /**
   * åˆå¹¶ä¸´æ—¶æ–‡ä»¶åˆ°æœ€ç»ˆåˆ†ç‰‡
   * @param {Object} manifest - ä¸»ç´¢å¼•å¯¹è±¡
   * @param {string} mode - ç´¢å¼•æ¨¡å¼: "light" (è½»é‡) æˆ– "full" (å…¨é‡)
   */
  static async mergeTempFilesToParts(manifest, mode = "light") {
    const PART_SIZE = mode === "full" ? 3000 : 5000;  // å…¨é‡æ¨¡å¼å‡å°‘åˆ†ç‰‡å¤§å°
    let currentPart = [];
    let partNumber = 1;

    // ğŸ†• è·å–æ€»æ–‡ä»¶æ•°ï¼Œç”¨äºè¿›åº¦æ˜¾ç¤º
    const totalTempFiles = manifest.metadata.tempFiles.length;

    try {
      // ğŸ†• æ˜¾ç¤ºåˆå¹¶é˜¶æ®µåˆå§‹æç¤º
      this.showProgressHUD(70, 100, `å¼€å§‹åˆå¹¶ ${totalTempFiles} ä¸ªä¸´æ—¶æ–‡ä»¶...`);
      await MNUtil.delay(0.5);  // çŸ­æš‚å»¶è¿Ÿç¡®ä¿ HUD æ˜¾ç¤º

      for (let i = 0; i < totalTempFiles; i++) {
        const tempFileName = manifest.metadata.tempFiles[i];
        const tempFilePath = MNUtil.tempFolder + "/" + tempFileName;

        // ğŸ†• æ˜¾ç¤ºè¯¦ç»†åˆå¹¶è¿›åº¦ï¼ˆ70% - 95% åŒºé—´ï¼‰
        const mergeProgress = 70 + (i / totalTempFiles) * 25;
        this.showProgressHUD(
          Math.round(mergeProgress),
          100,
          `åˆå¹¶æ–‡ä»¶ ${i + 1}/${totalTempFiles}`
        );

        // è¯»å–ä¸´æ—¶æ–‡ä»¶
        const tempData = MNUtil.readJSON(tempFilePath);
        if (!tempData || !tempData.data) continue;

        // æ·»åŠ åˆ°å½“å‰åˆ†ç‰‡
        for (const entry of tempData.data) {
          currentPart.push(entry);

          // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜åˆ†ç‰‡
          if (currentPart.length >= PART_SIZE) {
            const { filename, sizeMB } = await this.saveIndexPart(currentPart, partNumber, mode);
            manifest.parts.push({
              partNumber: partNumber,
              filename: filename,
              cardCount: currentPart.length,
              sizeMB: sizeMB  // è®°å½•æ–‡ä»¶å¤§å°
            });

            currentPart = [];
            partNumber++;

            // ğŸ”§ ç§»é™¤æ­¤å¤„çš„ç®€å• HUDï¼Œå› ä¸ºå¾ªç¯å¼€å§‹å·²æ˜¾ç¤ºè¯¦ç»†è¿›åº¦æ¡
            // MNUtil.showHUD(`æ­£åœ¨ç”Ÿæˆç¬¬ ${partNumber} ä¸ªåˆ†ç‰‡...`);
          }
        }
      }

      // ä¿å­˜æœ€åä¸€ä¸ªåˆ†ç‰‡
      if (currentPart.length > 0) {
        const { filename, sizeMB } = await this.saveIndexPart(currentPart, partNumber, mode);
        manifest.parts.push({
          partNumber: partNumber,
          filename: filename,
          cardCount: currentPart.length,
          sizeMB: sizeMB  // è®°å½•æ–‡ä»¶å¤§å°
        });
      }

      manifest.metadata.totalParts = partNumber;

    } catch (error) {
      MNLog.error(error, "KnowledgeBaseIndexer: mergeTempFilesToParts");
      throw error;
    }
  }
  
  /**
   * æ¸…ç†ä¸´æ—¶æ–‡ä»¶
   * @param {Array<string>} tempFiles - ä¸´æ—¶æ–‡ä»¶åæ•°ç»„
   */
  static async cleanupTempFiles(tempFiles) {
    if (!tempFiles || tempFiles.length === 0) return;
    
    // MarginNote çš„ API å¯èƒ½ä¸æ”¯æŒåˆ é™¤æ–‡ä»¶
    // ä½†ä¸´æ—¶æ–‡ä»¶åœ¨ tempFolder ä¸­ï¼Œç³»ç»Ÿä¼šå®šæœŸæ¸…ç†
    // è¿™é‡Œåªæ˜¯è®°å½•ä¸€ä¸‹æ¸…ç†æ„å›¾
    for (const fileName of tempFiles) {
      try {
        const filePath = MNUtil.tempFolder + "/" + fileName;
        // å¦‚æœ API æ”¯æŒåˆ é™¤ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ åˆ é™¤é€»è¾‘
        // ç›®å‰åªæ˜¯å ä½ï¼Œé¿å…ä¸´æ—¶æ–‡ä»¶ç´¯ç§¯
      } catch (error) {
        // å¿½ç•¥åˆ é™¤é”™è¯¯
      }
    }
  }
  
  /**
   * ä¿å­˜ç´¢å¼•åˆ†ç‰‡
   * @param {Array} partData - åˆ†ç‰‡æ•°æ®
   * @param {number} partNumber - åˆ†ç‰‡ç¼–å·
   * @param {string} mode - ç´¢å¼•æ¨¡å¼: "light" (è½»é‡) æˆ– "full" (å…¨é‡)
   * @returns {Object} - è¿”å› { filename, sizeMB }
   */
  static async saveIndexPart(partData, partNumber, mode = "light") {
    try {
      const filename = `kb-search-index-${mode}-part-${partNumber}.json`;
      const filepath = MNUtil.dbFolder + "/data/" + filename;

      const partContent = {
        partNumber: partNumber,
        data: partData,
        count: partData.length,
        mode: mode  // è®°å½•æ¨¡å¼
      };

      // æ£€æµ‹æ–‡ä»¶å¤§å°
      const jsonString = JSON.stringify(partContent);
      const sizeMB = jsonString.length / (1024 * 1024);

      if (sizeMB > 10) {
        MNUtil.showHUD(`âš ï¸ è­¦å‘Šï¼šåˆ†ç‰‡ ${partNumber} å¤§å° ${sizeMB.toFixed(2)} MB`);
      }

      MNUtil.writeJSON(filepath, partContent);
      return { filename, sizeMB };
    } catch (error) {
      MNUtil.showHUD("ä¿å­˜åˆ†ç‰‡å¤±è´¥: " + error.message);
      MNLog.error(error, "KnowledgeBaseIndexer: saveIndexPart");
      throw error;
    }
  }
  
  /**
   * ä¿å­˜ä¸»ç´¢å¼•æ–‡ä»¶
   * @param {Object} manifest - ç´¢å¼•æ¸…å•å¯¹è±¡
   * @param {string} mode - ç´¢å¼•æ¨¡å¼: "light" (è½»é‡) æˆ– "full" (å…¨é‡)
   * @returns {string} - æ–‡ä»¶è·¯å¾„
   */
  static async saveIndexManifest(manifest, mode = "light") {
    try {
      const filepath = MNUtil.dbFolder + `/data/kb-search-index-${mode}-manifest.json`;
      // åœ¨ manifest ä¸­æ·»åŠ æ¨¡å¼æ ‡è®°
      manifest.metadata = manifest.metadata || {};
      manifest.metadata.mode = mode;
      // æ›´æ–°æ—¶é—´æˆ³ä¸ºç´¢å¼•å®Œæˆæ—¶é—´
      manifest.metadata.updateTime = Math.floor(Date.now() / 1000);  // ç§’çº§æ—¶é—´æˆ³
      manifest.metadata.lastUpdated = new Date().toISOString();  // ISO æ ¼å¼
      MNUtil.writeJSON(filepath, manifest);
      return filepath;
    } catch (error) {
      MNUtil.showHUD("ä¿å­˜ä¸»ç´¢å¼•å¤±è´¥: " + error.message);
      MNLog.error(error, "KnowledgeBaseIndexer: saveIndexManifest");
      throw error;
    }
  }
  
  /**
   * åŠ è½½ä¸»ç´¢å¼•æ–‡ä»¶
   * @param {string} mode - ç´¢å¼•æ¨¡å¼: "light" (è½»é‡) æˆ– "full" (å…¨é‡)
   * @param {boolean} fallbackToLight - å¦‚æœ full æ¨¡å¼åŠ è½½å¤±è´¥ï¼Œæ˜¯å¦é™çº§åˆ° light æ¨¡å¼
   * @returns {Object|null} - ç´¢å¼•æ¸…å•å¯¹è±¡ï¼ŒåŠ è½½å¤±è´¥è¿”å› null
   */
  static loadIndexManifest(mode = "light", fallbackToLight = true) {
    try {
      const filepath = MNUtil.dbFolder + `/data/kb-search-index-${mode}-manifest.json`;
      const manifest = MNUtil.readJSON(filepath);

      if (manifest) {
        return manifest;
      }

      // å¦‚æœæœªæ‰¾åˆ°ä¸”å¯ç”¨é™çº§
      if (!manifest && mode === "full" && fallbackToLight) {
        MNUtil.showHUD("æœªæ‰¾åˆ°å…¨é‡ç´¢å¼•ï¼Œä½¿ç”¨è½»é‡ç´¢å¼•");
        const lightPath = MNUtil.dbFolder + "/data/kb-search-index-light-manifest.json";
        return MNUtil.readJSON(lightPath);
      }

      return null;
    } catch (error) {
      MNLog.error(error, `KnowledgeBaseIndexer: loadIndexManifest (mode: ${mode})`);

      // é™çº§é€»è¾‘
      if (mode === "full" && fallbackToLight) {
        try {
          MNUtil.showHUD("å…¨é‡ç´¢å¼•åŠ è½½å¤±è´¥ï¼Œé™çº§åˆ°è½»é‡ç´¢å¼•");
          const lightPath = MNUtil.dbFolder + "/data/kb-search-index-light-manifest.json";
          return MNUtil.readJSON(lightPath);
        } catch (fallbackError) {
          MNLog.error(fallbackError, "KnowledgeBaseIndexer: loadIndexManifest fallback failed");
        }
      }

      return null;
    }
  }
  
  /**
   * åŠ è½½ç´¢å¼•åˆ†ç‰‡
   */
  static loadIndexPart(filename) {
    try {
      const filepath = MNUtil.dbFolder + "/data/" + filename;
      return MNUtil.readJSON(filepath);
    } catch (error) {
      MNLog.error(error, "KnowledgeBaseIndexer: loadIndexPart");
      return null;
    }
  }
  
  /**
   * ä¿å­˜ç´¢å¼•åˆ°æ–‡ä»¶ï¼ˆå‘åå…¼å®¹ï¼‰
   */
  static saveIndex(index, filename = "kb-search-index.json") {
    try {
      const filepath = MNUtil.dbFolder + "/data/" + filename;
      MNUtil.writeJSON(filepath, index);
      MNUtil.showHUD(`ç´¢å¼•å·²ä¿å­˜åˆ° ${filename}`);
      return filepath;
    } catch (error) {
      MNUtil.showHUD("ä¿å­˜ç´¢å¼•å¤±è´¥: " + error.message);
      MNLog.error(error, "KnowledgeBaseIndexer: saveIndex");
      return null;
    }
  }
  
  /**
   * åŠ è½½ç´¢å¼•ï¼ˆå‘åå…¼å®¹ï¼‰
   */
  static loadIndex(filename = "kb-search-index.json") {
    try {
      const filepath = MNUtil.dbFolder + "/data/" + filename;
      return MNUtil.readJSON(filepath);
    } catch (error) {
      MNLog.error(error, "KnowledgeBaseIndexer: loadIndex");
      return null;
    }
  }

  /**
   * åŠ è½½å¢é‡ç´¢å¼•
   * @returns {Object|null} å¢é‡ç´¢å¼•å¯¹è±¡ï¼Œå¤±è´¥è¿”å› null
   */
  static loadIncrementalIndex() {
    try {
      const filepath = MNUtil.dbFolder + "/data/kb-incremental-index.json";
      const data = MNUtil.readJSON(filepath);
      return data || null;
    } catch (error) {
      // æ–‡ä»¶ä¸å­˜åœ¨æ—¶è¿”å› nullï¼Œè¿™æ˜¯æ­£å¸¸æƒ…å†µ
      return null;
    }
  }
  
  /**
   * ä¿å­˜å¢é‡ç´¢å¼•
   * @param {Object} data - å¢é‡ç´¢å¼•æ•°æ®
   * @returns {boolean} ä¿å­˜æˆåŠŸè¿”å› true
   */
  static saveIncrementalIndex(data) {
    try {
      const filepath = MNUtil.dbFolder + "/data/kb-incremental-index.json";
      MNUtil.writeJSON(filepath, data);
      return true;
    } catch (error) {
      MNUtil.showHUD("ä¿å­˜å¢é‡ç´¢å¼•å¤±è´¥: " + error.message);
      MNLog.error(error, "KnowledgeBaseIndexer: saveIncrementalIndex");
      return false;
    }
  }
  
  /**
   * æ·»åŠ å•å¼ å¡ç‰‡åˆ°å¢é‡ç´¢å¼•
   * å¦‚æœå¡ç‰‡å·²å­˜åœ¨ï¼Œä¼šåˆ é™¤æ—§æ¡ç›®å¹¶æ·»åŠ æ–°æ¡ç›®
   * @param {MNNote} note - è¦æ·»åŠ çš„å¡ç‰‡
   * @returns {boolean} æ·»åŠ æˆåŠŸè¿”å› true
   */
  static addToIncrementalIndex(note) {
    try {
      // 1. åŠ è½½ç°æœ‰å¢é‡ç´¢å¼•
      let incrementalIndex = this.loadIncrementalIndex();
      
      // 2. å¦‚æœç´¢å¼•ä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–æ–°ç´¢å¼•
      if (!incrementalIndex) {
        incrementalIndex = {
          metadata: {
            version: "incremental-1.0",
            lastUpdated: new Date().toISOString(),
            cardCount: 0
          },
          cards: []
        };
      }
      
      // 3. æ£€æŸ¥å¡ç‰‡æ˜¯å¦å·²å­˜åœ¨ï¼Œå­˜åœ¨åˆ™åˆ é™¤æ—§æ¡ç›®
      const noteId = note.noteId;
      const existingIndex = incrementalIndex.cards.findIndex(card => card.id === noteId);
      if (existingIndex !== -1) {
        incrementalIndex.cards.splice(existingIndex, 1);
        MNUtil.log(`å¢é‡ç´¢å¼•ï¼šç§»é™¤å¡ç‰‡ ${noteId} çš„æ—§æ¡ç›®`);
      }
      
      // 4. æ„å»ºæ–°çš„ç´¢å¼•æ¡ç›®
      const entry = this.buildIndexEntry(note);
      if (!entry) {
        MNUtil.showHUD("æ— æ³•ä¸ºè¯¥å¡ç‰‡æ„å»ºç´¢å¼•æ¡ç›®");
        return false;
      }
      
      // 5. æ·»åŠ æ–°æ¡ç›®
      incrementalIndex.cards.push(entry);
      
      // 6. æ›´æ–°å…ƒæ•°æ®
      incrementalIndex.metadata.lastUpdated = new Date().toISOString();
      incrementalIndex.metadata.cardCount = incrementalIndex.cards.length;
      
      // 7. ä¿å­˜å¢é‡ç´¢å¼•
      const saved = this.saveIncrementalIndex(incrementalIndex);
      
      if (saved) {
        // MNUtil.showHUD(`å·²æ·»åŠ åˆ°å¢é‡ç´¢å¼• (å…± ${incrementalIndex.metadata.cardCount} å¼ )`);
        return true;
      } else {
        return false;
      }
      
    } catch (error) {
      MNUtil.showHUD("æ·»åŠ åˆ°å¢é‡ç´¢å¼•å¤±è´¥: " + error.message);
      MNLog.error(error, "KnowledgeBaseIndexer: addToIncrementalIndex");
      return false;
    }
  }
  
  /**
   * æ¸…ç©ºå¢é‡ç´¢å¼•
   * @returns {boolean} æ¸…ç©ºæˆåŠŸè¿”å› true
   */
  static clearIncrementalIndex() {
    try {
      const filepath = MNUtil.dbFolder + "/data/kb-incremental-index.json";
      
      // åˆå§‹åŒ–ç©ºçš„å¢é‡ç´¢å¼•
      const emptyIndex = {
        metadata: {
          version: "incremental-1.0",
          lastUpdated: new Date().toISOString(),
          cardCount: 0
        },
        cards: []
      };
      
      MNUtil.writeJSON(filepath, emptyIndex);
      MNUtil.log("å¢é‡ç´¢å¼•å·²æ¸…ç©º");
      return true;
    } catch (error) {
      MNLog.error(error, "KnowledgeBaseIndexer: clearIncrementalIndex");
      return false;
    }
  }
}

/**
 * å¿«é€Ÿæœç´¢å™¨ - åŸºäºç´¢å¼•çš„å¿«é€Ÿæœç´¢
 */
class KnowledgeBaseSearcher {
  constructor(indexOrManifest, incrementalIndex = null) {
    // åˆ¤æ–­æ˜¯æ–°ç‰ˆåˆ†ç‰‡ç´¢å¼•è¿˜æ˜¯æ—§ç‰ˆå•æ–‡ä»¶ç´¢å¼•
    if (indexOrManifest && indexOrManifest.metadata) {
      if (indexOrManifest.metadata.version !== "1.0" && indexOrManifest.parts) {
        // æ–°ç‰ˆåˆ†ç‰‡ç´¢å¼•
        this.manifest = indexOrManifest;
        this.index = null;  // åˆ†ç‰‡æ¨¡å¼ä¸é¢„åŠ è½½æ•°æ®
        this.mode = 'sharded';
      } else {
        // æ—§ç‰ˆå•æ–‡ä»¶ç´¢å¼•
        this.index = indexOrManifest;
        this.manifest = null;
        this.mode = 'legacy';
      }
    } else {
      this.index = null;
      this.manifest = null;
      this.mode = 'unknown';
    }

    // ä¿å­˜å¢é‡ç´¢å¼•
    this.incrementalIndex = incrementalIndex;
  }

  static lastSearchTypes
  static lastSearchKeyword
  // åˆå§‹åŒ–æœç´¢å†å²ï¼ˆæœ€å¤šä¿å­˜5æ¡ï¼‰
  static searchHistory = []
  static maxSearchHistory = 5
  /**
   * å»é™¤å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ç©ºç™½å­—ç¬¦ï¼Œç”¨äºæœç´¢åŒ¹é…
   * @param {string} str
   * @returns {string}
   */
  static normalizeForMatch(str) {
    return (str || '').replace(/\s+/g, '');
  }

  /**
   * åˆ¤æ–­åœ¨å…è®¸å¿½ç•¥ç©ºç™½å·®å¼‚æ—¶ï¼ŒåŸºå‡†æ–‡æœ¬æ˜¯å¦åŒ…å«ç›®æ ‡è¯
   * @param {string} base - å·²è½¬ä¸ºå°å†™çš„åŸå§‹æ–‡æœ¬
   * @param {string} normalizedBase - å»é™¤ç©ºç™½åçš„æ–‡æœ¬
   * @param {string} term - å¾…åŒ¹é…çš„å…³é”®è¯
   * @returns {boolean}
   */
  static includesWithNormalized(base, normalizedBase, term) {
    if (!term) return false;
    if (base.includes(term)) {
      return true;
    }

    const normalizedTerm = this.normalizeForMatch(term);
    return normalizedTerm.length > 0 && normalizedBase.includes(normalizedTerm);
  }

  /**
   * åˆ¤æ–­æŸä¸ªå­—æ®µæ˜¯å¦åŒ…å«ç›®æ ‡è¯ï¼Œä¼šè‡ªåŠ¨å¤„ç†å¤§å°å†™å’Œç©ºç™½
   * @param {string} field
   * @param {string} term
   * @returns {boolean}
   */
  static fieldIncludes(field, term) {
    if (!field) return false;
    const lowerField = field.toLowerCase();
    return this.includesWithNormalized(lowerField, this.normalizeForMatch(lowerField), term);
  }
  
  /**
   * ä»æ–‡ä»¶åŠ è½½ç´¢å¼•å¹¶åˆ›å»ºæœç´¢å™¨
   */
  static async loadFromFile(filename = "kb-search-index.json") {
    // åŠ è½½å¢é‡ç´¢å¼•
    const incrementalIndex = KnowledgeBaseIndexer.loadIncrementalIndex();
    if (incrementalIndex && incrementalIndex.metadata.cardCount > 0) {
      MNUtil.log(`åŠ è½½å¢é‡ç´¢å¼•ï¼š${incrementalIndex.metadata.cardCount} å¼ å¡ç‰‡`);
    }

    // é¦–å…ˆå°è¯•åŠ è½½æ–°ç‰ˆåˆ†ç‰‡ç´¢å¼•
    const manifest = KnowledgeBaseIndexer.loadIndexManifest();
    if (manifest && manifest.metadata) {
      MNUtil.log("åŠ è½½åˆ†ç‰‡ç´¢å¼•æ¨¡å¼");
      return new KnowledgeBaseSearcher(manifest, incrementalIndex);
    }

    // å‘åå…¼å®¹ï¼šå°è¯•åŠ è½½æ—§ç‰ˆå•æ–‡ä»¶ç´¢å¼•
    const index = KnowledgeBaseIndexer.loadIndex(filename);
    if (index) {
      MNUtil.log("åŠ è½½å•æ–‡ä»¶ç´¢å¼•æ¨¡å¼ï¼ˆæ—§ç‰ˆï¼‰");
      return new KnowledgeBaseSearcher(index, incrementalIndex);
    }

    return null;
  }

  /**
   * ä»ä¸­é—´çŸ¥è¯†åº“ç´¢å¼•åŠ è½½æœç´¢å™¨
   */
  static async loadFromIntermediateKB() {
    // åŠ è½½å¢é‡ç´¢å¼•
    const incrementalIndex = IntermediateKnowledgeIndexer.loadIncrementalIndex();
    if (incrementalIndex && incrementalIndex.metadata.cardCount > 0) {
      MNUtil.log(`åŠ è½½ä¸­é—´çŸ¥è¯†åº“å¢é‡ç´¢å¼•ï¼š${incrementalIndex.metadata.cardCount} å¼ å¡ç‰‡`);
    }

    // åŠ è½½ä¸­é—´çŸ¥è¯†åº“çš„åˆ†ç‰‡ç´¢å¼•
    const manifest = IntermediateKnowledgeIndexer.loadIndexManifest();
    if (manifest && manifest.metadata) {
      MNUtil.log("åŠ è½½ä¸­é—´çŸ¥è¯†åº“åˆ†ç‰‡ç´¢å¼•");
      return new KnowledgeBaseSearcher(manifest, incrementalIndex);
    }

    return null;
  }
  
  /**
   * è§£ææœç´¢æŸ¥è¯¢è¯­æ³•
   * @param {string} query - ç”¨æˆ·è¾“å…¥çš„æŸ¥è¯¢å­—ç¬¦ä¸²
   * @returns {Object} è§£æåçš„æŸ¥è¯¢ç»“æ„
   */
  static parseSearchQuery(query) {
    const result = {
      andGroups: [],    // AND æ¡ä»¶ç»„
      orGroups: [],     // OR æ¡ä»¶ç»„  
      excludeTerms: [], // æ’é™¤è¯
      exactPhrases: []  // ç²¾ç¡®çŸ­è¯­
    };
    
    // 1. å…ˆæå–ç²¾ç¡®åŒ¹é…çŸ­è¯­ [[xxx]]
    const exactMatches = query.match(/\[\[([^\]]+)\]\]/g) || [];
    exactMatches.forEach(match => {
      const phrase = match.replace(/\[\[|\]\]/g, '');
      result.exactPhrases.push(phrase.toLowerCase());
      // ä»åŸæŸ¥è¯¢ä¸­ç§»é™¤ï¼Œé¿å…é‡å¤å¤„ç†
      query = query.replace(match, ' ');
    });
    
    // 2. å¤„ç†æ’é™¤è¯ !!xxx
    const excludeMatches = query.match(/!![^\s]+/g) || [];
    excludeMatches.forEach(match => {
      result.excludeTerms.push(match.substring(2).toLowerCase());
      query = query.replace(match, ' ');
    });
    
    // 3. å¤„ç† OR è¿ç®— ;;
    if (query.includes(';;')) {
      result.orGroups = query.split(';;').map(s => s.trim().toLowerCase()).filter(s => s);
      return result; // OR è¿ç®—ä¼˜å…ˆçº§æœ€ä½ï¼Œæœ‰ OR å°±ä¸å¤„ç† AND
    }
    
    // 4. å¤„ç† AND è¿ç®—ï¼ˆå¢å¼ºç©ºæ ¼æ”¯æŒï¼‰
    const separators = ['//', 'væ–¹æ ¹'];
    const hasSeparator = separators.some(sep => query.includes(sep));

    if (hasSeparator) {
      // ä½¿ç”¨æ˜¾å¼åˆ†éš”ç¬¦ï¼ˆ// æˆ– væ–¹æ ¹ï¼‰
      const regexPattern = separators.map(sep => 
        sep.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      ).join('|');
      const regex = new RegExp(regexPattern);
      
      result.andGroups = query.split(regex).map(s => s.trim().toLowerCase()).filter(s => s);
    } else {
      // æ™ºèƒ½ç©ºæ ¼åˆ†å‰²é€»è¾‘
      if (query.includes('  ')) {
        // æœ‰åŒç©ºæ ¼æˆ–æ›´å¤šï¼šç”¨åŒç©ºæ ¼åŠä»¥ä¸Šåˆ†å‰²ï¼Œå•ç©ºæ ¼ä¿ç•™
        result.andGroups = query.split(/\s{2,}/).map(s => s.trim().toLowerCase()).filter(s => s);
      } else if (query.includes(' ')) {
        // åªæœ‰å•ç©ºæ ¼ï¼šç”¨å•ç©ºæ ¼åˆ†å‰²
        result.andGroups = query.split(' ').map(s => s.trim().toLowerCase()).filter(s => s);
      } else {
        // æ²¡æœ‰ç©ºæ ¼ï¼šæ•´ä¸ªæŸ¥è¯¢ä½œä¸ºä¸€ä¸ª AND ç»„
        const trimmed = query.trim().toLowerCase();
        if (trimmed) {
          result.andGroups = [trimmed];
        }
      }
    }
    
    return result;
  }
  
  /**
   * åˆ¤æ–­æ–‡æœ¬æ˜¯å¦åŒ¹é…æŸ¥è¯¢æ¡ä»¶
   * @param {string} searchText - è¦æœç´¢çš„æ–‡æœ¬
   * @param {Object} parsedQuery - è§£æåçš„æŸ¥è¯¢å¯¹è±¡
   * @returns {boolean} æ˜¯å¦åŒ¹é…
   */
  static matchesQuery(searchText, parsedQuery) {
    const text = (searchText || '').toLowerCase();
    const normalizedText = this.normalizeForMatch(text);
    const includesTerm = term => this.includesWithNormalized(text, normalizedText, term);
    const matchWithSynonyms = term => {
      if (!term) return false;
      if (includesTerm(term)) {
        return true;
      }
      try {
        const synonymCandidates = SynonymManager.expandKeyword(term, true) || [];
        for (const candidate of synonymCandidates) {
          if (!candidate) continue;
          const candidateLower = candidate.toLowerCase();
          if (candidateLower === term) continue;
          if (includesTerm(candidateLower)) {
            return true;
          }
        }
      } catch (error) {
        MNUtil.log(`åŒä¹‰è¯åŒ¹é…å¤±è´¥: ${error.message}`);
      }
      return false;
    };

    // 1. æ£€æŸ¥æ’é™¤è¯
    for (const excludeTerm of parsedQuery.excludeTerms) {
      if (includesTerm(excludeTerm)) {
        return false; // åŒ…å«æ’é™¤è¯ï¼Œä¸åŒ¹é…
      }
    }

    // 2. æ£€æŸ¥ç²¾ç¡®çŸ­è¯­
    for (const phrase of parsedQuery.exactPhrases) {
      if (!includesTerm(phrase)) {
        return false; // ç¼ºå°‘å¿…éœ€çš„ç²¾ç¡®çŸ­è¯­
      }
    }

    // 3. æ£€æŸ¥ OR æ¡ä»¶
    if (parsedQuery.orGroups.length > 0) {
      return parsedQuery.orGroups.some(term => matchWithSynonyms(term));
    }

    // 4. æ£€æŸ¥ AND æ¡ä»¶ï¼ˆé»˜è®¤ï¼‰
    if (parsedQuery.andGroups.length > 0) {
      return parsedQuery.andGroups.every(group => matchWithSynonyms(group));
    }

    return parsedQuery.exactPhrases.length > 0; // åªæœ‰ç²¾ç¡®çŸ­è¯­æ—¶ï¼Œå·²ç»åœ¨æ­¥éª¤2æ£€æŸ¥è¿‡
  }
  
  /**
   * åœ¨ç´¢å¼•ä¸­æœç´¢
   * @param {string} keyword - æœç´¢å…³é”®è¯
   * @param {Object} options - æœç´¢é€‰é¡¹
   * @param {Array<string>} options.types - é™å®šå¡ç‰‡ç±»å‹
   * @param {Array<string>} options.classificationSubtypes - é™å®šå½’ç±»å¡ç‰‡çš„ç»†åˆ†ç±»å‹
   * @param {number} options.limit - ç»“æœæ•°é‡é™åˆ¶
   * @returns {Promise<Array>} æœç´¢ç»“æœæ•°ç»„
   */
  async search(keyword, options = {}) {
    const { types, classificationSubtypes, limit = 100 } = options;
    let results = [];
    
    try {
      // è§£ææœç´¢æŸ¥è¯¢
      const parsedQuery = KnowledgeBaseSearcher.parseSearchQuery(keyword);
      
      // å¦‚æœè§£æåæ²¡æœ‰ä»»ä½•æœ‰æ•ˆæ¡ä»¶ï¼Œè¿”å›ç©º
      if (parsedQuery.andGroups.length === 0 && 
          parsedQuery.orGroups.length === 0 && 
          parsedQuery.exactPhrases.length === 0) {
        return [];
      }
      
      // è·å–ç”¨æˆ·è¾“å…¥çš„å…³é”®è¯ï¼ˆç”¨äºæ’é™¤è¯æ£€æŸ¥ï¼‰
      const userKeywords = keyword.split(/\s+/).filter(k => k.length > 0);
      
      // è·å–æ¿€æ´»çš„æ’é™¤è¯ä¿¡æ¯
      const exclusionInfo = KnowledgeBaseTemplate.getActiveExclusions(userKeywords);
      const hasActiveExclusions = exclusionInfo.groups.length > 0;
      
      if (hasActiveExclusions) {
        MNUtil.log(`æ¿€æ´»çš„æ’é™¤è¯ç»„: ${exclusionInfo.groups.map(g => g.name).join(", ")}`);
      }
      
      // æ ¹æ®æ¨¡å¼é€‰æ‹©æœç´¢æ–¹å¼
      if (this.mode === 'sharded') {
        // åˆ†ç‰‡æ¨¡å¼ï¼šé€ä¸ªåŠ è½½åˆ†ç‰‡è¿›è¡Œæœç´¢
        for (const partInfo of this.manifest.parts) {
          if (results.length >= limit) {
            break; // å¦‚æœç»“æœå·²å¤Ÿï¼Œæå‰ç»“æŸ
          }
          
          // æ˜¾ç¤ºæœç´¢è¿›åº¦
          MNUtil.showHUD(`æœç´¢åˆ†ç‰‡ ${partInfo.partNumber}/${this.manifest.metadata.totalParts}`);
          
          // åŠ è½½åˆ†ç‰‡
          const part = KnowledgeBaseIndexer.loadIndexPart(partInfo.filename);
          if (!part || !part.data) {
            continue;
          }
          
          // åœ¨å½“å‰åˆ†ç‰‡ä¸­æœç´¢
          const partResults = this.searchInData(part.data, parsedQuery, {
            types,
            classificationSubtypes,
            limit: limit - results.length,
            exclusionInfo,
            hasActiveExclusions,
            userKeywords
          });
          
          results = results.concat(partResults);
          
          // è®©å‡ºæ§åˆ¶æƒç»™ UIï¼ˆé¿å…å¡æ­»ï¼‰
          await MNUtil.delay(0.01);
        }
      } else if (this.mode === 'legacy') {
        // æ—§ç‰ˆæ¨¡å¼ï¼šç›´æ¥æœç´¢å•æ–‡ä»¶ç´¢å¼•
        if (!this.index || !this.index.searchData) {
          MNUtil.showHUD("ç´¢å¼•æœªåŠ è½½");
          return [];
        }
        
        results = this.searchInData(this.index.searchData, parsedQuery, {
          types,
          classificationSubtypes,
          limit,
          exclusionInfo,
          hasActiveExclusions,
          userKeywords
        });
      } else {
        MNUtil.showHUD("ç´¢å¼•æ ¼å¼æœªçŸ¥");
        return [];
      }

      // æœç´¢å¢é‡ç´¢å¼•ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      if (this.incrementalIndex && this.incrementalIndex.cards && this.incrementalIndex.cards.length > 0) {
        MNUtil.log(`æœç´¢å¢é‡ç´¢å¼•ï¼š${this.incrementalIndex.cards.length} å¼ å¡ç‰‡`);

        const incrementalResults = this.searchInData(this.incrementalIndex.cards, parsedQuery, {
          types,
          classificationSubtypes,
          limit: limit - results.length,
          exclusionInfo,
          hasActiveExclusions,
          userKeywords
        });

        // åˆå¹¶ç»“æœå¹¶å»é‡ï¼ˆæŒ‰ noteIdï¼‰
        const existingIds = new Set(results.map(r => r.id));
        for (const result of incrementalResults) {
          if (!existingIds.has(result.id)) {
            results.push(result);
            existingIds.add(result.id);
          }
        }
      }

    } catch (error) {
      MNUtil.showHUD("æœç´¢å¤±è´¥: " + error.message);
      MNLog.error(error, "KnowledgeBaseSearcher: search");
    }

    return results.slice(0, limit);
  }
  
  /**
   * åœ¨æ•°æ®é›†ä¸­æœç´¢ï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰
   * @private
   */
  searchInData(searchData, parsedQuery, options) {
    const { types, classificationSubtypes, limit, exclusionInfo, hasActiveExclusions, userKeywords } = options;
    const results = [];
    
    try {
      // éå†æ•°æ®è¿›è¡Œæœç´¢
      for (let entry of searchData) {
        // ç±»å‹è¿‡æ»¤
        if (types && types.length > 0 && !types.includes(entry.type)) {
          continue;
        }
        
        // å½’ç±»ç»†åˆ†ç±»å‹è¿‡æ»¤
        if (classificationSubtypes && classificationSubtypes.length > 0) {
          if (entry.type === "å½’ç±»" && !classificationSubtypes.includes(entry.classificationSubtype)) {
            continue;
          }
        }
        
        // ä½¿ç”¨æ–°çš„åŒ¹é…é€»è¾‘
        if (entry.searchText && KnowledgeBaseSearcher.matchesQuery(entry.searchText, parsedQuery)) {
          // æ£€æŸ¥æ’é™¤è¯ï¼ˆä½¿ç”¨é¢„å¤„ç†çš„æ’é™¤ä¿¡æ¯ï¼‰
          let shouldExclude = false;
          
          if (hasActiveExclusions && entry.excludedGroups && entry.excludedGroups.length > 0) {
            // æ£€æŸ¥å¡ç‰‡çš„æ’é™¤ç»„æ˜¯å¦ä¸æ¿€æ´»çš„æ’é™¤ç»„åŒ¹é…
            for (const activeGroup of exclusionInfo.groups) {
              for (const cardGroup of entry.excludedGroups) {
                if (cardGroup.groupId === activeGroup.id) {
                  // æ£€æŸ¥è§¦å‘è¯æ˜¯å¦åœ¨å—å½±å“çš„è§¦å‘è¯åˆ—è¡¨ä¸­
                  const hasAffectedTrigger = activeGroup.triggerWords.some(trigger => 
                    cardGroup.affectedTriggers.includes(trigger)
                  );
                  
                  if (hasAffectedTrigger) {
                    shouldExclude = true;
                    MNUtil.log(`æ’é™¤å¡ç‰‡ "${entry.title}": åŒ¹é…æ’é™¤ç»„ "${cardGroup.groupName}"`);
                    break;
                  }
                }
              }
              if (shouldExclude) break;
            }
          }
          
          // å¦‚æœä¸åº”è¯¥æ’é™¤ï¼Œåˆ™æ·»åŠ åˆ°ç»“æœ
          if (!shouldExclude) {
            // ä¸ºäº†è¯„åˆ†ï¼Œéœ€è¦ä¼ é€’å®Œæ•´çš„ entry å¯¹è±¡
            const score = this.calculateScoreWithParsedQuery(parsedQuery, entry);
            
            results.push({
              id: entry.id,
              type: entry.type,
              classificationSubtype: entry.classificationSubtype,
              title: entry.title,
              parentId: entry.parentId,  // åŒ…å«çˆ¶ID
              prefix: entry.prefix,       // åŒ…å«å‰ç¼€ï¼ˆç”¨ä½œè·¯å¾„æ˜¾ç¤ºï¼‰
              content: entry.content,     // å½’ç±»å¡ç‰‡çš„å†…å®¹
              titleLinkWords: entry.titleLinkWords, // ç”¨äºè¯„åˆ†
              keywords: entry.keywords,   // ç”¨äºè¯„åˆ†
              score: score
            });
            
            if (results.length >= limit) {
              break;
            }
          }
        }
      }
      
      // æŒ‰ç›¸å…³æ€§æ’åº
      results.sort((a, b) => b.score - a.score);
      
    } catch (error) {
      MNLog.error(error, "KnowledgeBaseSearcher: searchInData");
    }
    
    return results.slice(0, limit);
  }
  
  /**
   * è®¡ç®—åŒ¹é…åˆ†æ•°ï¼ˆæ—§ç‰ˆæœ¬ï¼Œä¿ç•™å…¼å®¹æ€§ï¼‰
   * @private
   */
  calculateScore(keyword, entry) {
    let score = 0;
    const keywordLower = (keyword || '').toLowerCase();
    const normalizedKeyword = KnowledgeBaseSearcher.normalizeForMatch(keywordLower);
    const searchTextLower = (entry.searchText || '').toLowerCase();
    const normalizedSearchText = KnowledgeBaseSearcher.normalizeForMatch(searchTextLower);

    // å®Œå…¨åŒ¹é…å¾—åˆ†æœ€é«˜
    if (
      searchTextLower === keywordLower ||
      (normalizedKeyword.length > 0 && normalizedSearchText === normalizedKeyword)
    ) {
      score += 100;
    }

    // åœ¨æ ‡é¢˜é“¾æ¥è¯ä¸­åŒ¹é…
    if (KnowledgeBaseSearcher.fieldIncludes(entry.titleLinkWords, keywordLower)) {
      score += 50;
    }

    // åœ¨å…³é”®è¯å­—æ®µä¸­åŒ¹é…
    if (KnowledgeBaseSearcher.fieldIncludes(entry.keywords, keywordLower)) {
      score += 30;
    }

    // åœ¨å‰ç¼€å†…å®¹ä¸­åŒ¹é…
    if (KnowledgeBaseSearcher.fieldIncludes(entry.prefix, keywordLower)) {
      score += 20;
    }

    // åŸºç¡€åŒ¹é…åˆ†
    if (KnowledgeBaseSearcher.includesWithNormalized(searchTextLower, normalizedSearchText, keywordLower)) {
      score += 10;
    }

    return score;
  }
  
  /**
   * ä½¿ç”¨è§£æåçš„æŸ¥è¯¢è®¡ç®—åŒ¹é…åˆ†æ•°
   * @param {Object} parsedQuery - è§£æåçš„æŸ¥è¯¢å¯¹è±¡
   * @param {Object} entry - ç´¢å¼•æ¡ç›®
   * @returns {number} åŒ¹é…åˆ†æ•°
   */
  calculateScoreWithParsedQuery(parsedQuery, entry) {
    let score = 0;
    const searchText = (entry.searchText || '').toLowerCase();
    const normalizedSearchText = KnowledgeBaseSearcher.normalizeForMatch(searchText);
    const titleLinkWords = (entry.titleLinkWords || '').toLowerCase();
    const normalizedTitleLinkWords = KnowledgeBaseSearcher.normalizeForMatch(titleLinkWords);
    const prefix = (entry.prefix || '').toLowerCase();
    const normalizedPrefix = KnowledgeBaseSearcher.normalizeForMatch(prefix);
    const keywords = (entry.keywords || '').toLowerCase();
    const normalizedKeywords = KnowledgeBaseSearcher.normalizeForMatch(keywords);

    const includesInSearch = term => KnowledgeBaseSearcher.includesWithNormalized(searchText, normalizedSearchText, term);
    const includesInTitleLink = term => KnowledgeBaseSearcher.includesWithNormalized(titleLinkWords, normalizedTitleLinkWords, term);
    const includesInPrefix = term => KnowledgeBaseSearcher.includesWithNormalized(prefix, normalizedPrefix, term);
    const includesInKeywords = term => KnowledgeBaseSearcher.includesWithNormalized(keywords, normalizedKeywords, term);

    // 1. ç²¾ç¡®çŸ­è¯­åŒ¹é…å¾—åˆ†æœ€é«˜ï¼ˆæ¯ä¸ªçŸ­è¯­100åˆ†ï¼‰
    parsedQuery.exactPhrases.forEach(phrase => {
      if (includesInSearch(phrase)) {
        score += 100;
      }
      // é¢å¤–åŠ åˆ†ï¼šå¦‚æœç²¾ç¡®çŸ­è¯­å‡ºç°åœ¨æ ‡é¢˜é“¾æ¥è¯ä¸­
      if (includesInTitleLink(phrase)) {
        score += 50;
      }
    });

    // 2. AND ç»„åŒ¹é…ï¼ˆæ¯ä¸ªè¯ç‹¬ç«‹è¯„åˆ†ï¼‰
    parsedQuery.andGroups.forEach(group => {
      const groupLower = group.toLowerCase();
      
      // åœ¨æ ‡é¢˜é“¾æ¥è¯ä¸­åŒ¹é…
      if (includesInTitleLink(groupLower)) {
        score += 50;
      }
      
      // åœ¨å‰ç¼€å†…å®¹ä¸­åŒ¹é…
      if (includesInPrefix(groupLower)) {
        score += 30;
      }
      
      // åœ¨å…³é”®è¯å­—æ®µä¸­åŒ¹é…
      if (includesInKeywords(groupLower)) {
        score += 20;
      }
      
      // åŸºç¡€åŒ¹é…åˆ†
      if (includesInSearch(groupLower)) {
        score += 10;
      }
    });

    // 3. OR ç»„åŒ¹é…ï¼ˆåŒ¹é…çš„è¶Šå¤šåˆ†æ•°è¶Šé«˜ï¼‰
    if (parsedQuery.orGroups.length > 0) {
      const matchedOrTerms = parsedQuery.orGroups.filter(term => includesInSearch(term));
      score += matchedOrTerms.length * 25; // æ¯ä¸ªåŒ¹é…çš„ OR è¯åŠ  25 åˆ†
    }
    
    // 4. æ’é™¤è¯æƒ©ç½šï¼ˆç†è®ºä¸Šä¸åº”è¯¥åˆ°è¿™é‡Œï¼Œå› ä¸ºå·²ç»è¢«è¿‡æ»¤äº†ï¼‰
    // è¿™é‡Œä¸éœ€è¦å¤„ç†ï¼ŒmatchesQuery å·²ç»è¿‡æ»¤äº†
    
    // 5. é¢å¤–åŠ åˆ†ï¼šå¦‚æœå¤šä¸ªæ¡ä»¶éƒ½æ»¡è¶³
    const totalConditions = parsedQuery.exactPhrases.length + 
                          parsedQuery.andGroups.length + 
                          parsedQuery.orGroups.length;
    if (totalConditions > 1) {
      score += totalConditions * 5; // å¤šæ¡ä»¶å¥–åŠ±
    }
    
    return score;
  }
  
  /**
   * è·å–æœç´¢ç»“æœçš„è¯¦ç»†ä¿¡æ¯
   * @param {Array} searchResults - searchæ–¹æ³•è¿”å›çš„ç»“æœ
   * @returns {Array<MNNote>} å¡ç‰‡å¯¹è±¡æ•°ç»„
   */
  getDetailedResults(searchResults) {
    const notes = [];
    
    searchResults.forEach(result => {
      const note = MNNote.new(result.id);
      if (note) {
        // é™„åŠ æœç´¢ç›¸å…³ä¿¡æ¯
        note._searchScore = result.score;
        note._searchType = result.type;
        notes.push(note);
      }
    });
    
    return notes;
  }

  static async showSearchResults(results, searcher, searchOptions = {}, focusMode = true, defaultHandle = true) {
    try {
      // æ„å»ºç»“æœé€‰é¡¹
      const options = results.map((result, index) => {
        const typeLabel = result.classificationSubtype 
          ? `[${result.type}-${result.classificationSubtype}]`
          : `[${result.type}-${result.prefix}]`;
        
        // è·å–æ˜¾ç¤ºçš„æ ‡é¢˜ï¼ˆä¼˜å…ˆç”¨ç®€çŸ­å½¢å¼ï¼‰
        let displayTitle = result.classificationSubtype 
          ? `${result.content}`
          : ``;
        
        // æˆªå–æ ‡é¢˜é¿å…è¿‡é•¿
        if (displayTitle.length > 40) {
          displayTitle = displayTitle.substring(0, 40) + "...";
        }

        if (!result.classificationSubtype){
          displayTitle = displayTitle + result.titleLinkWords
        }
        
        return `${index + 1}. ${typeLabel} ${displayTitle}`;
      });
      
      // æ·»åŠ è¿”å›å’Œåˆ†äº«é€‰é¡¹
      // options.unshift("ğŸ”™ è¿”å›æœç´¢");
      
      // æ˜¾ç¤ºç»“æœåˆ—è¡¨
      let selectResult = await MNUtil.userSelect(
        `æœç´¢ç»“æœ (${results.length} ä¸ª)`,
        "é€‰æ‹©è¦æŸ¥çœ‹çš„å¡ç‰‡ï¼š",
        options,
      );

      if (selectResult === 0) {
        // è¿”å›æœç´¢ï¼Œä¿ç•™ä¹‹å‰çš„é…ç½®
        const config = {
          defaultTypes: searchOptions.types,
          enableTypeSelection: searchOptions.config ? searchOptions.config.enableTypeSelection : true
        };
        this.showSearchDialog(searcher, config, focusMode, defaultHandle);
      } else if (selectResult > 0) {
        const selectedResult = results[selectResult - 1];
        const note = MNNote.new(selectedResult.id);
        if (note) {
          // è°ƒç”¨æ–°çš„ç»Ÿä¸€å¤„ç†æ–¹æ³•
          const enhancedOptions = Object.assign({}, searchOptions, {
            results: results,
            searcher: searcher,
            focusMode: focusMode,
            isFromHistory: searchOptions.isFromHistory
          });
          if (defaultHandle) {
            this.handleSelectedCard(note, selectedResult, enhancedOptions);
          } else {
            return note;
          }
        }
      }
      
    } catch (error) {
      MNUtil.showHUD("æ˜¾ç¤ºç»“æœå¤±è´¥: " + error.message);
      MNLog.error(error, "MNKnowledgeBase: showSearchResults");
    }
  }


  /**
   * å¤„ç†é€‰ä¸­çš„å¡ç‰‡ï¼Œæ˜¾ç¤ºæ“ä½œèœå•
   */
  static async handleSelectedCard(note, searchResult, searchOptions = {}) {
    try {
      if (!note) {
        MNUtil.showHUD("âŒ æ— æ•ˆçš„å¡ç‰‡");
        return;
      }

      // æ„å»ºæ“ä½œèœå•é€‰é¡¹
      const menuOptions = [
        "ğŸ“‹ å¤åˆ¶ Markdown é“¾æ¥",
        "ğŸ“‹ å¤åˆ¶å¡ç‰‡ URL",
        "ğŸ—ºï¸ åœ¨è„‘å›¾ä¸­å®šä½",
        "ğŸªŸ åœ¨æµ®çª—ä¸­å®šä½",
        "ğŸ“Œ Pin åˆ°ä½ç½®",
        "ğŸ”— åˆå¹¶å‰ªè´´æ¿å¡ç‰‡åˆ°æ‘˜å½•åŒº",
        "ğŸ”™ è¿”å›æœç´¢ç»“æœ"
      ];

      const actionChoice = await MNUtil.userSelect(
        "é€‰æ‹©æ“ä½œ",
        `å¡ç‰‡: ${searchResult ? searchResult.title : note.noteTitle}`,
        menuOptions
      );

      switch(actionChoice) {
        case 0: // å–æ¶ˆ
          // è¿”å›æœç´¢ç»“æœåˆ—è¡¨
          if (searchOptions.results && searchOptions.searcher) {
            KnowledgeBaseSearcher.showSearchResults(searchOptions.results, searchOptions.searcher, searchOptions);
          }
          break;
          
        case 1: // å¤åˆ¶ Markdown é“¾æ¥
          KnowledgeBaseTemplate.copyMarkdownLinkWithQuickPhrases(note);
          break;
        case 2:
          MNUtil.copy(note.noteURL);
          MNUtil.showHUD("å·²å¤åˆ¶" + note.noteURL, 1);
          break;
        case 3: // åœ¨è„‘å›¾ä¸­å®šä½
          if (MNUtil.mindmapView) {
            note.focusInMindMap();
          } else {
            MNUtil.showHUD("å½“å‰ä¸åœ¨è„‘å›¾è§†å›¾");
          }
          break;
          
        case 4: // åœ¨æµ®çª—ä¸­å®šä½
          if (MNUtil.mindmapView) {
            note.focusInFloatMindMap();
          } else {
            MNUtil.showHUD("å½“å‰ä¸åœ¨è„‘å›¾è§†å›¾");
          }
          break;
          
        case 5: // Pin åˆ°ä½ç½®
          // æ˜¾ç¤ºä½ç½®é€‰æ‹©å­èœå•
          const pinOptions = [
            "ğŸ“ Midway Top",
            "ğŸ“ Midway Bottom",
            "ğŸ“ Focus Top",
            "ğŸ“ Focus Bottom",
            "ğŸ”™ è¿”å›"
          ];

          const pinChoice = await MNUtil.userSelect(
            "é€‰æ‹© Pin ä½ç½®",
            "é€‰æ‹©è¦ Pin åˆ°çš„ä½ç½®ï¼š",
            pinOptions
          );

          if (pinChoice > 0 && pinChoice <= 4) {
            const sections = ["midway", "midway", "focus", "focus"];
            const positions = ["top", "bottom", "top", "bottom"];
            const section = sections[pinChoice - 1];
            const position = positions[pinChoice - 1];

            // å‘é€å¹¿æ’­æ¶ˆæ¯ç»™ mnpinner
            MNUtil.postNotification("AddonBroadcast", {
              message: `mnpinner?action=pin&id=${encodeURIComponent(note.noteId)}&section=${section}&position=${position}`
            });

            MNUtil.showHUD(`âœ… å·²å‘é€ Pin è¯·æ±‚åˆ° ${section} ${position}`);
          } else if (pinChoice === 5) {
            // è¿”å›ä¸»èœå•
            this.handleSelectedCard(note, searchResult, searchOptions);
          }
          break;

        case 6: // åˆå¹¶å‰ªè´´æ¿å¡ç‰‡åˆ°æ‘˜å½•åŒº
          try {
            // è·å–å‰ªè´´æ¿å†…å®¹
            const clipboardContent = MNUtil.clipboardText;
            if (!clipboardContent) {
              MNUtil.showHUD("âŒ å‰ªè´´æ¿ä¸ºç©º");
              return;
            }

            // å°è¯•è§£æä¸º MarginNote å¡ç‰‡
            let clipboardNote = null;

            // æ£€æŸ¥æ˜¯å¦ä¸º MarginNote URL
            if (clipboardContent.includes("marginnote")) {
              clipboardNote = MNNote.new(clipboardContent);
            } else if (clipboardContent.match(/^[A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12}$/i)) {
              // æ£€æŸ¥æ˜¯å¦ä¸º UUID æ ¼å¼çš„ noteId
              clipboardNote = MNNote.new(clipboardContent);
            }

            if (!clipboardNote) {
              MNUtil.showHUD("âŒ å‰ªè´´æ¿å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„å¡ç‰‡ ID æˆ– URL");
              return;
            }

            // æ‰§è¡Œåˆå¹¶æ“ä½œ
            MNUtil.undoGrouping(() => {
              // åˆå¹¶åˆ°é€‰ä¸­å¡ç‰‡
              clipboardNote.mergeInto(note);

              // è‡ªåŠ¨ç§»åŠ¨åˆ°æ‘˜å½•åŒº
              KnowledgeBaseTemplate.autoMoveNewContentToField(note, "æ‘˜å½•");
            });

            MNUtil.showHUD("âœ… å·²åˆå¹¶å‰ªè´´æ¿å¡ç‰‡åˆ°æ‘˜å½•åŒº");
          } catch (error) {
            MNUtil.showHUD("âŒ åˆå¹¶å¤±è´¥: " + error.message);
            MNLog.error(error, "MNKnowledgeBase: mergeClipboardCard");
          }
          break;

        case 7: // è¿”å›æœç´¢ç»“æœ
          if (searchOptions.results && searchOptions.searcher) {
            KnowledgeBaseSearcher.showSearchResults(searchOptions.results, searchOptions.searcher, searchOptions);
          }
          break;
      }
      
    } catch (error) {
      MNUtil.showHUD("æ“ä½œå¤±è´¥: " + error.message);
      MNLog.error(error, "MNKnowledgeBase: handleSelectedCard");
    }
  }

  static async showSearchDialog(searcher, config = {}, focusMode, defaultHandle = true) {
    try {
      // é»˜è®¤é…ç½®
      const defaultConfig = {
        enableTypeSelection: true,      // æ˜¯å¦å…è®¸é€‰æ‹©ç±»å‹
        defaultTypes: null,              // é»˜è®¤æœç´¢ç±»å‹ï¼ˆnullè¡¨ç¤ºå…¨éƒ¨ï¼‰
        showAdvancedOptions: false,     // æ˜¯å¦æ˜¾ç¤ºé«˜çº§é€‰é¡¹
        presetKey: null                  // é¢„è®¾é”®å
      };
      
      const searchConfig = Object.assign({}, defaultConfig, config);
      
      // æ­¥éª¤1ï¼šç±»å‹é€‰æ‹©ï¼ˆå¦‚æœå¯ç”¨ï¼‰
      let selectedTypes = searchConfig.defaultTypes;
      if (searchConfig.enableTypeSelection && !selectedTypes) {
        selectedTypes = await this.selectSearchTypes();
        if (selectedTypes === "cancel") return; // ç”¨æˆ·å–æ¶ˆ
      }
      
      // æ­¥éª¤2ï¼šè·å–æœç´¢æ¨¡å¼é…ç½®
      const searchModeConfig = KnowledgeBaseTemplate.getSearchConfig();
      const modeNames = {
        exact: "ç²¾ç¡®",
        synonym: "åŒä¹‰è¯",
        exclude: "æ’é™¤è¯",
        full: "å®Œæ•´"
      };
      const modeText = modeNames[searchModeConfig.mode] || "ç²¾ç¡®";
      
      // æ­¥éª¤3ï¼šæ„å»ºæ ‡é¢˜ä¿¡æ¯
      let typeInfo = "(å…¨éƒ¨ç±»å‹)";
      if (searchConfig.presetKey) {
        const preset = SearchConfig.typePresets[searchConfig.presetKey];
        typeInfo = preset ? `${preset.icon} ${preset.name}` : `(${selectedTypes.length}ç§ç±»å‹)`;
      } else if (selectedTypes) {
        typeInfo = `(${selectedTypes.length}ç§ç±»å‹)`;
      }
      
      // æ­¥éª¤4ï¼šå…³é”®è¯è¾“å…¥
      let userInput = await MNUtil.userInput(
        `å¿«é€Ÿæœç´¢ ${typeInfo} [${modeText}æ¨¡å¼]`,
        "è¯·è¾“å…¥æœç´¢å…³é”®è¯ï¼š",
        ["å–æ¶ˆ", "æœç´¢"]
      );
      
      if (userInput.button === 1) {
        let keyword = userInput.input.trim();
        if (!keyword) return;
        
        // æ­¥éª¤5ï¼šæ ¹æ®é…ç½®æ‰©å±•æŸ¥è¯¢è¯
        let expandedKeyword = keyword;
        if (searchModeConfig.useSynonyms) {
          expandedKeyword = KnowledgeBaseIndexer.expandSearchQuery(keyword, true);
          MNUtil.log(`æ‰©å±•åçš„æŸ¥è¯¢: ${expandedKeyword}`);
        }
        
        // æ­¥éª¤6ï¼šæ‰§è¡Œæœç´¢
        return this.performFastSearch(searcher, expandedKeyword, {
          types: selectedTypes,
          config: searchConfig,
          searchModeConfig: searchModeConfig,
          originalKeyword: keyword
        }, focusMode, defaultHandle);
      }
    } catch (error) {
      MNUtil.showHUD("æœç´¢å¯¹è¯æ¡†é”™è¯¯: " + error.message);
      MNLog.error(error, "MNKnowledgeBase: showSearchDialog");
    }
  }

  /**
   * é€‰æ‹©æœç´¢ç±»å‹
   */
  static async selectSearchTypes() {
    try {
      const options = SearchConfig.getSearchTypeOptions();
      const displayOptions = options.map(opt => opt.name);
      displayOptions.push("âš™ï¸ è‡ªå®šä¹‰é€‰æ‹©...");
      
      const choice = await MNUtil.userSelect(
        "é€‰æ‹©æœç´¢èŒƒå›´",
        "è¯·é€‰æ‹©è¦æœç´¢çš„å¡ç‰‡ç±»å‹ï¼š",
        displayOptions
      );
      
      if (choice === 0) return "cancel";
      
      if (choice < options.length + 1) {
        // é€‰æ‹©äº†é¢„è®¾
        return options[choice - 1].types;
      } else {
        // è‡ªå®šä¹‰é€‰æ‹©
        return await this.selectCustomTypes();
      }
    } catch (error) {
      MNLog.error(error, "MNKnowledgeBase: selectSearchTypes");
      return null; // è¿”å›nullè¡¨ç¤ºæœç´¢å…¨éƒ¨
    }
  }

    /**
   * è‡ªå®šä¹‰ç±»å‹é€‰æ‹©
   */
  static async selectCustomTypes() {
    const allTypes = ["å®šä¹‰", "å‘½é¢˜", "ä¾‹å­", "åä¾‹", "å½’ç±»", "æ€æƒ³æ–¹æ³•", "é—®é¢˜", "æ€è·¯", "æ€»ç»“"];
    const selectedTypes = [];
    
    // ä½¿ç”¨å¤šæ¬¡å•é€‰æ¥æ¨¡æ‹Ÿå¤šé€‰
    for (let type of allTypes) {
      const choice = await MNUtil.userSelect(
        "è‡ªå®šä¹‰ç±»å‹é€‰æ‹©",
        `æ˜¯å¦åŒ…å«"${type}"ç±»å‹ï¼Ÿ\nå·²é€‰æ‹©ï¼š${selectedTypes.join(", ") || "æ— "}`,
        ["è·³è¿‡", "é€‰æ‹©", "å®Œæˆé€‰æ‹©"]
      );

      if (choice === 0 || choice === 3)  return;
      
      if (choice === 2) {
        selectedTypes.push(type);
      } else if (choice === 1) {
        break; 
      } 
    }
    
    return selectedTypes.length > 0 ? selectedTypes : null;
  }

  /**
   * æ‰§è¡Œå¿«é€Ÿæœç´¢ï¼ˆå¢å¼ºç‰ˆï¼‰
   */
  static async performFastSearch(searcher, keyword, options = {}, focusMode = true, defaultHandle = true) {
    try {
      // æ„å»ºæœç´¢å‚æ•°
      const searchOptions = {
        limit: 50,
        types: options.types || null
      };
      
      // è®°å½•æœç´¢å†å²ï¼ˆä½¿ç”¨åŸå§‹å…³é”®è¯ï¼‰
      this.lastSearchKeyword = options.originalKeyword || keyword;
      this.lastSearchTypes = options.types;
      
      // æ‰§è¡Œæœç´¢
      let results = await searcher.search(keyword, searchOptions);
      
      // æ ¹æ®é…ç½®åº”ç”¨æ’é™¤è¯è¿‡æ»¤
      if (options.searchModeConfig && options.searchModeConfig.useExclusion) {
        const beforeCount = results.length;
        results = KnowledgeBaseIndexer.filterSearchResults(results, true);
        const afterCount = results.length;
        if (beforeCount > afterCount) {
          MNUtil.log(`æ’é™¤è¯è¿‡æ»¤: ${beforeCount} â†’ ${afterCount} ä¸ªç»“æœ`);
        }
      }
      
      if (results.length === 0) {
        const typeInfo = options.types ? `(${options.types.join(", ")})` : "(å…¨éƒ¨ç±»å‹)";
        const originalKeyword = options.originalKeyword || keyword;
        MNUtil.showHUD(`æœªæ‰¾åˆ°åŒ¹é… "${originalKeyword}" çš„å¡ç‰‡ ${typeInfo}`);
        return;
      }
      
      // ä¿å­˜æœç´¢å†å²ï¼ˆæ ¹æ® focusMode ç¡®å®šæ¨¡å¼åç§°ï¼‰
      let modeName = "è„‘å›¾å®šä½";
      if (focusMode === false) {
        modeName = "æµ®çª—å®šä½";
      } else if (focusMode === 'markdown') {
        modeName = "å¤åˆ¶é“¾æ¥";
      }
      
      const historyEntry = {
        keyword: options.originalKeyword || keyword,
        types: options.types || null,
        results: results.slice(0, 50), // åªä¿å­˜å‰50æ¡ç»“æœ
        timestamp: Date.now(),
        mode: modeName,
        searchModeConfig: options.searchModeConfig || {}
      };
      
      // æ·»åŠ åˆ°å†å²è®°å½•å¼€å¤´
      this.searchHistory.unshift(historyEntry);
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      if (this.searchHistory.length > this.maxSearchHistory) {
        this.searchHistory = this.searchHistory.slice(0, this.maxSearchHistory);
      }
      
      // æ˜¾ç¤ºæœç´¢ç»“æœ
      return this.showSearchResults(results, searcher, options, focusMode, defaultHandle);
      
    } catch (error) {
      MNUtil.showHUD("æœç´¢æ‰§è¡Œå¤±è´¥: " + error.message);
      MNLog.error(error, "MNKnowledgeBase: performFastSearch");
    }
  }
}

/**
 * æœç´¢é…ç½®ç®¡ç†ç±»
 */
class SearchConfig {
  /**
   * é¢„å®šä¹‰çš„æœç´¢ç±»å‹ç»„åˆï¼ˆå¼•ç”¨é…ç½®å¯¹è±¡ï¼‰
   */
  static typePresets = kbSearchConfig.typePresets;

  /**
   * è·å–å¯ç´¢å¼•çš„æ‰€æœ‰ç±»å‹åˆ—è¡¨
   * @param {Array<string>} customTypes - è‡ªå®šä¹‰ç±»å‹åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰
   * @returns {Array<string>} ç±»å‹æ•°ç»„
   */
  static getIndexableTypes(customTypes = null) {
    if (customTypes && Array.isArray(customTypes)) {
      return customTypes;
    }
    // é»˜è®¤è¿”å›çŸ¥è¯†åº“ä¸­æœ€å¸¸ç”¨çš„ç±»å‹
    return ["å®šä¹‰", "å‘½é¢˜", "ä¾‹å­", "åä¾‹", "å½’ç±»", "æ€æƒ³æ–¹æ³•", "é—®é¢˜"];
  }

  /**
   * è·å–æœç´¢ç±»å‹é€‰é¡¹ï¼ˆç”¨äºUIæ˜¾ç¤ºï¼‰
   * @returns {Array<{name: string, value: string, types: Array}>} 
   */
  static getSearchTypeOptions() {
    return Object.entries(this.typePresets).map(([key, preset]) => ({
      name: `${preset.icon} ${preset.name}`,
      value: key,
      types: preset.types
    }));
  }

  /**
   * æ ¹æ®é¢„è®¾é”®è·å–ç±»å‹åˆ—è¡¨
   * @param {string} presetKey - é¢„è®¾é”®å
   * @returns {Array<string>|null} ç±»å‹æ•°ç»„
   */
  static getTypesByPreset(presetKey) {
    return this.typePresets[presetKey]?.types || null;
  }
}

/**
 * åŒä¹‰è¯ç®¡ç†ç±»
 */
class SynonymManager {
  /**
   * ç¼“å­˜çš„åŒä¹‰è¯ç»„ï¼ˆé¿å…é‡å¤åˆå¹¶ï¼‰
   */
  static _cachedGroups = null;
  
  /**
   * é»˜è®¤åŒä¹‰è¯ç»„ï¼ˆç²¾ç®€ç»“æ„ï¼‰
   */
  static synonymGroups = kbSearchConfig.synonymGroups;
  
  // è·å–æ‰€æœ‰åŒä¹‰è¯ç»„ï¼ˆåˆå¹¶é»˜è®¤å’Œç”¨æˆ·è‡ªå®šä¹‰ï¼‰
  static getSynonymGroups() {
    return this.synonymGroups;
  }

  /**
   * æ„å»ºåŒä¹‰è¯ç´¢å¼•ï¼ˆä¼˜åŒ–æŸ¥æ‰¾æ€§èƒ½ï¼‰
   * @private
   */
  static buildSynonymIndex() {
    if (this._synonymIndex) return this._synonymIndex;
    
    this._synonymIndex = new Map();
    const groups = this.getSynonymGroups();
    groups.forEach(group => {
      // å°†æ¯ä¸ªè¯æ˜ å°„åˆ°å®ƒæ‰€åœ¨çš„è¯ç»„
      group.words.forEach(word => {
        this._synonymIndex.set(word, group.words);
      });
    });
    return this._synonymIndex;
  }

  /**
   * æ‰©å±•å…³é”®è¯ï¼ˆè·å–æ‰€æœ‰åŒä¹‰è¯ï¼‰
   * @param {string} keyword - åŸå§‹å…³é”®è¯
   * @param {boolean} includeSelf - æ˜¯å¦åŒ…å«åŸè¯
   * @returns {Array<string>} æ‰©å±•åçš„è¯æ±‡æ•°ç»„
   */
  static expandKeyword(keyword, includeSelf = true) {
    const index = this.buildSynonymIndex();
    const group = index.get(keyword);
    
    if (!group) {
      return includeSelf ? [keyword] : [];
    }
    
    if (includeSelf) {
      return [...group];
    } else {
      return group.filter(word => word !== keyword);
    }
  }
}

// æ’é™¤è¯ç®¡ç†å™¨
class ExclusionManager {
  // é»˜è®¤æ’é™¤è¯ç»„æ•°æ®ï¼ˆå¼•ç”¨é…ç½®å¯¹è±¡ï¼‰
  static exclusionGroups = kbSearchConfig.exclusionGroups;

  // è·å–æ‰€æœ‰æ’é™¤è¯ç»„
  static getExclusionGroups() {
    return this.exclusionGroups;
  }
}

/**
 * ä¸­é—´çŸ¥è¯†åº“ç´¢å¼•å™¨
 * ç”¨äºå¤„ç†æœªå®Œå…¨åˆ¶å¡çš„ä¸­é—´çŠ¶æ€çŸ¥è¯†å¡ç‰‡
 */
class IntermediateKnowledgeIndexer {
  /**
   * æ„å»ºä¸­é—´çŸ¥è¯†åº“çš„æœç´¢ç´¢å¼•
   * @param {Array} rootNotes - æ ¹å¡ç‰‡æ•°ç»„
   */
  static async buildSearchIndex(rootNotes) {
    const BATCH_SIZE = 500;
    const TEMP_FILE_PREFIX = "intermediate-kb-temp-";
    const PART_SIZE = 5000;

    MNLog.log(`[ä¸­é—´çŸ¥è¯†åº“] buildSearchIndex å¼€å§‹ï¼Œè¾“å…¥æ ¹å¡ç‰‡æ•°: ${rootNotes.length}`);

    const manifest = {
      metadata: {
        version: "1.0",
        type: "intermediate", // æ ‡è®°ä¸ºä¸­é—´çŸ¥è¯†åº“
        lastUpdated: new Date().toISOString(),
        updateTime: Math.floor(Date.now() / 1000),  // ğŸ†• æ·»åŠ ç§’çº§æ—¶é—´æˆ³
        totalCards: 0,
        partSize: PART_SIZE,
        totalParts: 0,
        tempFiles: []
      },
      parts: []
    };

    try {
      let tempFileCount = 0;
      let currentBatch = [];
      let processedCount = 0;
      let validCount = 0;
      let totalEstimatedCount = 0;
      let errorCount = 0;  // æ·»åŠ é”™è¯¯è®¡æ•°
      const processedIds = new Set();

      // ç¼“å­˜æ‰€æœ‰æ ¹èŠ‚ç‚¹
      const rootNoteObjects = [];

      for (const _rootNote of rootNotes) {
        const rootNote = MNNote.new(_rootNote);
        if (!rootNote) {
          continue;
        }

        const descendants = rootNote.descendantNodes?.descendant || [];
        totalEstimatedCount += descendants.length + 1;

        rootNoteObjects.push({
          rootNote: rootNote,
          descendants: descendants
        });
      }

      MNLog.log(`[ä¸­é—´çŸ¥è¯†åº“] æ”¶é›†åˆ° ${totalEstimatedCount} å¼ åä»£å¡ç‰‡ï¼ˆåŒ…å«æ ¹å¡ç‰‡ï¼‰`);

      // æ˜¾ç¤ºåˆå§‹è¿›åº¦
      MNUtil.showHUD(`å¼€å§‹æ„å»ºä¸­é—´çŸ¥è¯†åº“ç´¢å¼•ï¼ˆå…± ${totalEstimatedCount} å¼ å¡ç‰‡ï¼‰`);

      // å¤„ç†æ¯ä¸ªæ ¹èŠ‚ç‚¹åŠå…¶å­å­™
      for (let rootIndex = 0; rootIndex < rootNoteObjects.length; rootIndex++) {
        const { rootNote, descendants } = rootNoteObjects[rootIndex];

        // å¤„ç†æ ¹èŠ‚ç‚¹
        if (!processedIds.has(rootNote.noteId)) {
          const entry = this.buildIndexEntry(rootNote);
          if (entry) {
            currentBatch.push(entry);
            validCount++;
          }
          processedIds.add(rootNote.noteId);
          processedCount++;
        }

        // å¤„ç†å­å­™èŠ‚ç‚¹
        for (let i = 0; i < descendants.length; i++) {
          const descendant = descendants[i];

          // ä¿å­˜å½“å‰æ‰¹æ¬¡
          if (currentBatch.length >= BATCH_SIZE) {
            const tempFileName = `${TEMP_FILE_PREFIX}${tempFileCount}.json`;
            const tempFilePath = MNUtil.tempFolder + "/" + tempFileName;

            MNUtil.writeJSON(tempFilePath, {
              batchNumber: tempFileCount,
              data: currentBatch,
              count: currentBatch.length
            });

            manifest.metadata.tempFiles.push(tempFileName);
            tempFileCount++;
            currentBatch = [];

            MNUtil.showHUD(`å¤„ç†ä¸­... å·²ä¿å­˜ ${tempFileCount} ä¸ªä¸´æ—¶æ–‡ä»¶`);
            await MNUtil.delay(0.001);
          }

          // å¤„ç†å•ä¸ªèŠ‚ç‚¹
          const noteId = descendant.noteId || descendant;
          if (processedIds.has(noteId)) {
            processedCount++;
            continue;
          }

          const mnNote = MNNote.new(descendant);
          if (!mnNote || !mnNote.noteId) {
            processedCount++;
            continue;
          }

          try {
            const entry = this.buildIndexEntry(mnNote);
            if (entry) {
              currentBatch.push(entry);
              validCount++;
            }
          } catch (error) {
            errorCount++;
            // æ¯1000ä¸ªé”™è¯¯è®°å½•ä¸€æ¬¡
            if (errorCount % 1000 === 0) {
              MNLog.log(`[ä¸­é—´çŸ¥è¯†åº“] ç´¯è®¡é”™è¯¯: ${errorCount} ä¸ªï¼Œå½“å‰noteId: ${mnNote.noteId}`);
            }
          }

          processedIds.add(noteId);
          processedCount++;

          // æ¯1000ä¸ªè®°å½•ä¸€æ¬¡è¿›åº¦
          if (processedCount % 1000 === 0) {
            MNLog.log(`[ä¸­é—´çŸ¥è¯†åº“] è¿›åº¦: ${processedCount}/${totalEstimatedCount}, æœ‰æ•ˆ: ${validCount}, é”™è¯¯: ${errorCount}`);
          }
        }

        descendants.length = 0;
      }

      // ä¿å­˜æœ€åä¸€æ‰¹
      if (currentBatch.length > 0) {
        const tempFileName = `${TEMP_FILE_PREFIX}${tempFileCount}.json`;
        const tempFilePath = MNUtil.tempFolder + "/" + tempFileName;

        MNUtil.writeJSON(tempFilePath, {
          batchNumber: tempFileCount,
          data: currentBatch,
          count: currentBatch.length
        });

        manifest.metadata.tempFiles.push(tempFileName);
        tempFileCount++;
      }

      // åˆå¹¶ä¸´æ—¶æ–‡ä»¶åˆ°æœ€ç»ˆåˆ†ç‰‡
      MNUtil.showHUD("æ­£åœ¨åˆå¹¶ä¸­é—´çŸ¥è¯†åº“ç´¢å¼•æ–‡ä»¶...");
      await this.mergeTempFilesToParts(manifest);

      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      await this.cleanupTempFiles(manifest.metadata.tempFiles);

      // æ›´æ–°å…ƒæ•°æ®
      manifest.metadata.totalCards = validCount;

      MNLog.log(`[ä¸­é—´çŸ¥è¯†åº“] ç´¢å¼•æ„å»ºç»Ÿè®¡: å¤„ç†=${processedCount}, æœ‰æ•ˆ=${validCount}, è·³è¿‡=${processedCount - validCount}`);

      // ä¿å­˜ä¸»ç´¢å¼•æ–‡ä»¶
      await this.saveIndexManifest(manifest);

      // æ¸…ç©ºå¢é‡ç´¢å¼•ï¼ˆå…¨å±€ç´¢å¼•å·²åŒ…å«æ‰€æœ‰å¡ç‰‡ï¼‰
      this.clearIncrementalIndex();

      MNUtil.showHUD(`ä¸­é—´çŸ¥è¯†åº“ç´¢å¼•æ„å»ºå®Œæˆï¼šå…± ${validCount} å¼ å¡ç‰‡ï¼Œ${manifest.metadata.totalParts} ä¸ªåˆ†ç‰‡`);
      MNLog.log(`[ä¸­é—´çŸ¥è¯†åº“] âœ… ç´¢å¼•æ„å»ºå®Œæˆ: ${validCount} å¼ å¡ç‰‡ï¼Œ${manifest.metadata.totalParts} ä¸ªåˆ†ç‰‡`);

    } catch (error) {
      if (manifest.metadata.tempFiles && manifest.metadata.tempFiles.length > 0) {
        await this.cleanupTempFiles(manifest.metadata.tempFiles);
      }
      // ğŸ†• å¤„ç† error ä¸º undefined çš„æƒ…å†µ
      const errorMessage = error?.message || String(error) || "æœªçŸ¥é”™è¯¯";
      const errorDetails = {
        message: error?.message || "æœªçŸ¥é”™è¯¯",
        stack: error?.stack || "æ— å †æ ˆä¿¡æ¯",
        type: typeof error,
        raw: error
      };

      MNUtil.showHUD("æ„å»ºä¸­é—´çŸ¥è¯†åº“ç´¢å¼•å¤±è´¥: " + errorMessage);
      MNLog.error({
        message: "ä¸­é—´çŸ¥è¯†åº“ç´¢å¼•æ„å»ºå¤±è´¥",
        source: "IntermediateKnowledgeIndexer: buildSearchIndex",
        detail: errorDetails
      });
      return null;
    }

    return manifest;
  }

  /**
   * æ„å»ºå•ä¸ªå¡ç‰‡çš„ç´¢å¼•æ¡ç›®
   * ä¸çŸ¥è¯†åº“ä¸åŒï¼Œè¿™é‡Œä¸åˆ¤æ–­å¡ç‰‡ç±»å‹ï¼Œç»Ÿä¸€å¤„ç†æ‰€æœ‰å¡ç‰‡
   */
  static buildIndexEntry(note) {
    // KnowledgeBaseTemplate.renewLinks(note);

    const SOURCE = "IntermediateKnowledgeIndexer.buildIndexEntry";

    // // æ·»åŠ è°ƒè¯•æ—¥å¿—
    // MNLog.debug("=== buildIndexEntry START ===", SOURCE);
    // MNLog.debug({
    //   message: "å¼€å§‹æ„å»ºç´¢å¼•æ¡ç›®",
    //   noteExists: !!note,
    //   noteId: note?.noteId,
    //   title: note?.title
    // }, SOURCE);

    // if (!note || !note.noteId) {
    //   MNLog.debug("Note æ— æ•ˆï¼Œè¿”å› null", SOURCE);
    //   return null;
    // }

    // æ£€æŸ¥ MNComment æ˜¯å¦å­˜åœ¨
    // MNLog.debug({
    //   message: "æ£€æŸ¥ MNComment ç±»",
    //   typeofMNComment: typeof MNComment,
    //   hasFrom: typeof MNComment?.from === 'function',
    //   hasGetCommentType: typeof MNComment?.getCommentType === 'function'
    // }, SOURCE);

    // ç¡®ä¿ MNComments å·²åˆå§‹åŒ–
    // if (!note.MNComments) {
    //   MNLog.debug({
    //     message: "MNComments æœªåˆå§‹åŒ–ï¼Œæ­£åœ¨å¤„ç†",
    //     hasComments: !!note.comments,
    //     commentsLength: note.comments?.length || 0,
    //     commentsType: Array.isArray(note.comments) ? 'array' : typeof note.comments
    //   }, SOURCE);

    //   // å°è¯•ç”Ÿæˆ MNComments
    //   if (note.comments && note.comments.length > 0) {
    //     try {
    //       // å…ˆè®°å½•åŸå§‹è¯„è®ºçš„è¯¦ç»†ä¿¡æ¯
    //       MNLog.debug({
    //         message: "åŸå§‹è¯„è®ºè¯¦æƒ…",
    //         firstComment: note.comments[0] ? {
    //           type: note.comments[0].type,
    //           hasText: !!note.comments[0].text,
    //           keys: Object.keys(note.comments[0])
    //         } : null,
    //         detail: JSON.stringify(note.comments.slice(0, 2))
    //       }, SOURCE);

    //       // æ£€æŸ¥ MNComment æ˜¯å¦å¯ç”¨
    //       if (typeof MNComment !== 'undefined' && typeof MNComment.from === 'function') {
    //         MNLog.debug("ä½¿ç”¨ MNComment.from åˆ›å»º MNComments", SOURCE);
    //         note.MNComments = note.comments.map((comment, index) => {
    //           try {
    //             if (!comment) {
    //               MNLog.warn(`è¯„è®º ${index} ä¸º undefinedï¼Œè·³è¿‡`, SOURCE);
    //               return null;
    //             }
    //             return MNComment.from(comment);
    //           } catch (innerError) {
    //             MNLog.error({
    //               message: `å¤„ç†è¯„è®º ${index} å¤±è´¥`,
    //               error: innerError.message,
    //               comment: comment,
    //               detail: innerError.stack
    //             }, SOURCE);
    //             return null;
    //           }
    //         }).filter(c => c !== null);
    //       } else if (typeof MNComment !== 'undefined' && typeof MNComment.getCommentType === 'function') {
    //         // å¤‡é€‰æ–¹æ¡ˆï¼šä½¿ç”¨ getCommentType æ–¹æ³•
    //         MNLog.debug("ä½¿ç”¨ MNComment.getCommentType å¤„ç†", SOURCE);
    //         note.MNComments = note.comments.map((comment, index) => {
    //           try {
    //             if (!comment) {
    //               MNLog.warn(`è¯„è®º ${index} ä¸º undefinedï¼Œè·³è¿‡`, SOURCE);
    //               return null;
    //             }
    //             // ç¡®ä¿ comment å­˜åœ¨å†è°ƒç”¨ getCommentType
    //             const commentType = MNComment.getCommentType(comment);
    //             return {
    //               type: commentType,
    //               text: comment.text || "",
    //               ...comment
    //             };
    //           } catch (innerError) {
    //             MNLog.error({
    //               message: `getCommentType å¤„ç†è¯„è®º ${index} å¤±è´¥`,
    //               error: innerError.message,
    //               comment: comment,
    //               detail: innerError.stack
    //             }, SOURCE);
    //             // é™çº§å¤„ç†
    //             return {
    //               type: comment.type || "unknown",
    //               text: comment.text || "",
    //               ...comment
    //             };
    //           }
    //         }).filter(c => c !== null);
    //       } else {
    //         // æœ€ç»ˆå¤‡é€‰ï¼šç›´æ¥ä½¿ç”¨åŸå§‹ comments
    //         MNLog.debug("MNComment ä¸å¯ç”¨ï¼Œä½¿ç”¨åŸå§‹ comments", SOURCE);
    //         note.MNComments = note.comments.filter(c => c !== null && c !== undefined);
    //       }
    //       MNLog.info({
    //         message: "MNComments åˆ›å»ºæˆåŠŸ",
    //         length: note.MNComments.length
    //       }, SOURCE);
    //     } catch (e) {
    //       MNLog.error({
    //         message: "åˆ›å»º MNComments å¤±è´¥",
    //         error: e.message,
    //         stack: e.stack,
    //         commentsLength: note.comments?.length
    //       }, SOURCE);
    //       note.MNComments = note.comments || [];
    //     }
    //   } else {
    //     MNLog.debug("æ²¡æœ‰æ‰¾åˆ°è¯„è®ºï¼Œè®¾ç½®ç©ºæ•°ç»„", SOURCE);
    //     note.MNComments = [];
    //   }
    // } else {
    //   MNLog.debug({
    //     message: "MNComments å·²åˆå§‹åŒ–",
    //     length: note.MNComments.length
    //   }, SOURCE);
    // }


    // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡æœ¬å†…å®¹ï¼ˆæ ‡é¢˜æˆ–æ–‡æœ¬è¯„è®ºï¼‰
    const hasTitle = note.title && note.title.trim();
    const hasTextComment = this.hasTextComment(note);

    // è·³è¿‡æ— æ–‡æœ¬å†…å®¹çš„å¡ç‰‡
    if (!hasTitle && !hasTextComment) {
      return null;
    }

    KnowledgeBaseTemplate.renewLinks(note); // å¤„ç†å¤±æ•ˆé“¾æ¥

    // æ„å»ºç´¢å¼•æ¡ç›®
    const entry = {
      id: note.noteId,
      title: this.decodeHtmlEntities(KnowledgeBaseIndexer.cleanHighlightMarkers(note.title || "")),
      parentId: note.parentNoteId || null,
      searchText: this.buildSearchText(note)
    };

    // åˆ¤æ–­æ˜¯å¦å·²åˆ¶å¡
    const isTemplated = KnowledgeBaseTemplate.ifTemplateMerged(note);
    entry.isTemplated = isTemplated;

    // è®¾ç½®å¡ç‰‡ç±»å‹
    if (isTemplated) {
      // å·²åˆ¶å¡ï¼šè·å–å®é™…ç±»å‹ï¼ˆå®šä¹‰ã€å‘½é¢˜ç­‰ï¼‰
      try {
        const noteType = KnowledgeBaseTemplate.getNoteType(note);
        if (noteType) {
          entry.type = noteType;
        }
      } catch (e) {
        // å¿½ç•¥é”™è¯¯
      }
    } else {
      // æœªåˆ¶å¡ï¼šç»Ÿä¸€æ ‡è®°ä¸º"ä¸­é—´çŸ¥è¯†"
      entry.type = "ä¸­é—´çŸ¥è¯†";
    }

    return entry;
  }

  /**
   * æ£€æŸ¥å¡ç‰‡æ˜¯å¦åŒ…å«æ–‡æœ¬è¯„è®º
   */
  static hasTextComment(note) {
    if (!note.MNComments || note.MNComments.length === 0) {
      return false;
    }

    try {
      return note.MNComments.some((comment, index) => {
        // æ£€æŸ¥ comment æ˜¯å¦æœ‰æ•ˆ
        if (!comment) {
          return false;
        }

        // ç¡®ä¿ comment.type å­˜åœ¨
        const commentType = comment.type || "unknown";

        if (commentType === "textComment" || commentType === "markdownComment") {
          return comment.text && comment.text.trim();
        }
        if (commentType === "HtmlComment") {
          // æ£€æŸ¥æ˜¯å¦æœ‰å…³é”®è¯å­—æ®µ
          const match = comment.text && comment.text.match(/^å…³é”®è¯[:\uff1a]\s*(.*)$/);
          return match && match[1].trim();
        }
        return false;
      });
    } catch (e) {
      return false;
    }
  }

  /**
   * è§£ç  HTML å®ä½“ä¸ºåŸå§‹å­—ç¬¦
   * ç¡®ä¿å­˜å‚¨çš„æ ‡é¢˜æ˜¯åŸå§‹æ–‡æœ¬æ ¼å¼ï¼Œé¿å… HTML å®ä½“è¢«åŒé‡è½¬ä¹‰
   *
   * @param {string} text - å¯èƒ½åŒ…å« HTML å®ä½“çš„æ–‡æœ¬ï¼ˆå¦‚ &lt;ã€&gt;ã€&amp; ç­‰ï¼‰
   * @returns {string} - è§£ç åçš„åŸå§‹æ–‡æœ¬
   *
   * @example
   * // è¾“å…¥: "&lt;Tx, y&gt;=&lt;x, Sy&gt;"
   * // è¾“å‡º: "<Tx, y>=<x, Sy>"
   */
  static decodeHtmlEntities(text) {
    if (!text) return "";

    // HTML å®ä½“æ˜ å°„è¡¨ï¼ˆå¸¸ç”¨å®ä½“ï¼‰
    const entities = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '&quot;': '"',
      '&apos;': "'",
      '&nbsp;': ' ',
      '&copy;': 'Â©',
      '&reg;': 'Â®',
      '&trade;': 'â„¢'
    };

    // æ›¿æ¢å‘½åå®ä½“ã€åè¿›åˆ¶æ•°å­—å®ä½“å’Œåå…­è¿›åˆ¶æ•°å­—å®ä½“
    return text
      .replace(/&[a-zA-Z]+;/g, (match) => entities[match] || match)
      .replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec))
      .replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)));
  }

  /**
   * æ„å»ºæœç´¢æ–‡æœ¬
   * æå–æ ‡é¢˜å’Œæ‰€æœ‰æ–‡æœ¬è¯„è®ºå†…å®¹
   */
  static buildSearchText(note) {
    const textParts = [];

    try {
      // è·å–å¡ç‰‡ç±»å‹
      const noteType = KnowledgeBaseTemplate.getNoteType(note);
      const typeInfo = noteType ? `${noteType} ` : "";

      // æ·»åŠ æ ‡é¢˜ï¼ˆæ¸…ç†é«˜äº®æ ‡è®°ï¼‰
      if (note.title) {
        textParts.push(KnowledgeBaseIndexer.cleanHighlightMarkers(note.title));
      }

      // å¤„ç†è¯„è®º
      if (note.MNComments && note.MNComments.length > 0) {
        for (let i = 0; i < note.MNComments.length; i++) {
          const comment = note.MNComments[i];

          // æ£€æŸ¥ comment æ˜¯å¦æœ‰æ•ˆ
          if (!comment) {
            continue;
          }

          // è·å– comment typeï¼Œæä¾›é»˜è®¤å€¼
          const commentType = comment.type || "unknown";

          if (commentType === "textComment") {
            if (comment.text && comment.text.trim()) {
              textParts.push(KnowledgeBaseIndexer.cleanHighlightMarkers(comment.text.trim()));
            }
          } else if (commentType === "markdownComment") {
            if (comment.text && comment.text.trim()) {
              // å»é™¤ markdown é“¾æ¥ï¼Œåªä¿ç•™æ–‡å­—
              const textWithoutLinks = comment.text.replace(
                /\[([^\]]+)\]\(marginnote4app:\/\/[^)]+\)/g,
                '$1'
              );
              textParts.push(KnowledgeBaseIndexer.cleanHighlightMarkers(textWithoutLinks.trim()));
            }
          } else if (commentType === "HtmlComment") {
            // åªæå–å…³é”®è¯å­—æ®µ
            const match = comment.text && comment.text.match(/^å…³é”®è¯[:\uff1a]\s*(.*)$/);
            if (match && match[1].trim()) {
              textParts.push(KnowledgeBaseIndexer.cleanHighlightMarkers(match[1].trim()));
            }
          }
        }
      }

      // åˆå¹¶æ‰€æœ‰æ–‡æœ¬å¹¶è½¬æ¢ä¸ºå°å†™ï¼Œåœ¨å¼€å¤´åŠ å…¥ç±»å‹ä¿¡æ¯
      const result = typeInfo + textParts.join(" ").toLowerCase();

      return result;
    } catch (e) {
      // è¿”å›è‡³å°‘åŒ…å«æ ‡é¢˜çš„æ–‡æœ¬
      return (note.title || "").toLowerCase();
    }
  }

  // ========== ä»¥ä¸‹æ–¹æ³•å¤ç”¨æˆ–ä¿®æ”¹è‡ª KnowledgeBaseIndexer ==========

  /**
   * åˆå¹¶ä¸´æ—¶æ–‡ä»¶åˆ°åˆ†ç‰‡
   */
  static async mergeTempFilesToParts(manifest) {
    try {
      const PART_SIZE = manifest.metadata.partSize || 5000;
      let currentPart = [];
      let partNumber = 0;

      for (const tempFileName of manifest.metadata.tempFiles) {
        const tempFilePath = MNUtil.tempFolder + "/" + tempFileName;
        const tempData = MNUtil.readJSON(tempFilePath);
        if (!tempData || !tempData.data) {
          continue;
        }

        for (const entry of tempData.data) {
          currentPart.push(entry);

          if (currentPart.length >= PART_SIZE) {
            const filename = await this.saveIndexPart(partNumber, currentPart);
            manifest.parts.push({
              partNumber: partNumber,
              filename: filename,
              count: currentPart.length
            });
            currentPart = [];
            partNumber++;
          }
        }
      }

      if (currentPart.length > 0) {
        const filename = await this.saveIndexPart(partNumber, currentPart);
        manifest.parts.push({
          partNumber: partNumber,
          filename: filename,
          count: currentPart.length
        });
        partNumber++;
      }

      manifest.metadata.totalParts = partNumber;

    } catch (error) {
      MNLog.error(error, "IntermediateKnowledgeIndexer: mergeTempFilesToParts");
      throw error;
    }
  }

  /**
   * ä¿å­˜ç´¢å¼•åˆ†ç‰‡
   */
  static async saveIndexPart(partNumber, partData) {
    try {
      const filename = `intermediate-kb-index-part-${partNumber}.json`;
      const filepath = MNUtil.dbFolder + "/data/" + filename;
      const payload = {
        partNumber: partNumber,
        data: partData,
        count: partData.length
      };
      MNUtil.writeJSON(filepath, payload);
      return filename;
    } catch (error) {
      MNLog.error(error, "IntermediateKnowledgeIndexer: saveIndexPart");
      throw error;
    }
  }

  /**
   * ä¿å­˜ä¸»ç´¢å¼•æ¸…å•
   */
  static async saveIndexManifest(manifest) {
    try {
      const filepath = MNUtil.dbFolder + "/data/intermediate-kb-index-manifest.json";
      // æ›´æ–°æ—¶é—´æˆ³ä¸ºç´¢å¼•å®Œæˆæ—¶é—´
      manifest.metadata = manifest.metadata || {};
      manifest.metadata.updateTime = Math.floor(Date.now() / 1000);  // ç§’çº§æ—¶é—´æˆ³
      manifest.metadata.lastUpdated = new Date().toISOString();  // ISO æ ¼å¼
      MNUtil.writeJSON(filepath, manifest);
    } catch (error) {
      MNLog.error(error, "IntermediateKnowledgeIndexer: saveIndexManifest");
      throw error;
    }
  }

  /**
   * æ¸…ç†ä¸´æ—¶æ–‡ä»¶
   */
  static async cleanupTempFiles(tempFiles) {
    // ä¸´æ—¶æ–‡ä»¶ä¼šåœ¨ä¸´æ—¶ç›®å½•è‡ªåŠ¨æ¸…ç†
    // MNUtil ä¸æä¾›åˆ é™¤æ–‡ä»¶çš„æ–¹æ³•
  }

  /**
   * åŠ è½½ç´¢å¼•æ¸…å•
   */
  static loadIndexManifest() {
    try {
      const filepath = MNUtil.dbFolder + "/data/intermediate-kb-index-manifest.json";
      return MNUtil.readJSON(filepath);
    } catch (error) {
      MNLog.error(error, "IntermediateKnowledgeIndexer: loadIndexManifest");
      return null;
    }
  }

  /**
   * åŠ è½½ç´¢å¼•åˆ†ç‰‡
   */
  static loadIndexPart(filename) {
    try {
      const filepath = MNUtil.dbFolder + "/data/" + filename;
      return MNUtil.readJSON(filepath);
    } catch (error) {
      MNLog.error(error, "IntermediateKnowledgeIndexer: loadIndexPart");
      return null;
    }
  }


  /**
   * åŠ è½½å¢é‡ç´¢å¼•
   * @returns {Object|null} å¢é‡ç´¢å¼•å¯¹è±¡ï¼Œå¤±è´¥è¿”å› null
   */
  static loadIncrementalIndex() {
    try {
      const filepath = MNUtil.dbFolder + "/data/intermediate-kb-incremental-index.json";
      const data = MNUtil.readJSON(filepath);
      return data || null;
    } catch (error) {
      // æ–‡ä»¶ä¸å­˜åœ¨æ—¶è¿”å› nullï¼Œè¿™æ˜¯æ­£å¸¸æƒ…å†µ
      return null;
    }
  }

  /**
   * ä¿å­˜å¢é‡ç´¢å¼•
   * @param {Object} data - å¢é‡ç´¢å¼•æ•°æ®
   * @returns {boolean} ä¿å­˜æˆåŠŸè¿”å› true
   */
  static saveIncrementalIndex(data) {
    try {
      const filepath = MNUtil.dbFolder + "/data/intermediate-kb-incremental-index.json";
      MNUtil.writeJSON(filepath, data);
      return true;
    } catch (error) {
      MNUtil.showHUD("ä¿å­˜ä¸­é—´çŸ¥è¯†åº“å¢é‡ç´¢å¼•å¤±è´¥: " + error.message);
      MNLog.error(error, "IntermediateKnowledgeIndexer: saveIncrementalIndex");
      return false;
    }
  }

  /**
   * æ·»åŠ å•å¼ å¡ç‰‡åˆ°å¢é‡ç´¢å¼•
   * å¦‚æœå¡ç‰‡å·²å­˜åœ¨ï¼Œä¼šåˆ é™¤æ—§æ¡ç›®å¹¶æ·»åŠ æ–°æ¡ç›®
   * @param {MNNote} note - è¦æ·»åŠ çš„å¡ç‰‡
   * @returns {boolean} æ·»åŠ æˆåŠŸè¿”å› true
   */
  static addToIncrementalIndex(note) {
    try {
      // 1. åŠ è½½ç°æœ‰å¢é‡ç´¢å¼•
      let incrementalIndex = this.loadIncrementalIndex();

      // 2. å¦‚æœç´¢å¼•ä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–æ–°ç´¢å¼•
      if (!incrementalIndex) {
        incrementalIndex = {
          metadata: {
            version: "intermediate-incremental-1.0",
            lastUpdated: new Date().toISOString(),
            cardCount: 0
          },
          cards: []
        };
      }

      // 3. æ£€æŸ¥å¡ç‰‡æ˜¯å¦å·²å­˜åœ¨ï¼Œå­˜åœ¨åˆ™åˆ é™¤æ—§æ¡ç›®
      const noteId = note.noteId;
      const existingIndex = incrementalIndex.cards.findIndex(card => card.id === noteId);
      if (existingIndex !== -1) {
        incrementalIndex.cards.splice(existingIndex, 1);
        MNUtil.log(`ä¸­é—´çŸ¥è¯†åº“å¢é‡ç´¢å¼•ï¼šç§»é™¤å¡ç‰‡ ${noteId} çš„æ—§æ¡ç›®`);
      }

      // 4. æ„å»ºæ–°çš„ç´¢å¼•æ¡ç›®
      const entry = this.buildIndexEntry(note);
      if (!entry) {
        MNUtil.showHUD("æ— æ³•ä¸ºè¯¥å¡ç‰‡æ„å»ºç´¢å¼•æ¡ç›®");
        return false;
      }

      // 5. æ·»åŠ æ–°æ¡ç›®
      incrementalIndex.cards.push(entry);

      // 6. æ›´æ–°å…ƒæ•°æ®
      incrementalIndex.metadata.lastUpdated = new Date().toISOString();
      incrementalIndex.metadata.cardCount = incrementalIndex.cards.length;

      // 7. ä¿å­˜å¢é‡ç´¢å¼•
      const saved = this.saveIncrementalIndex(incrementalIndex);

      if (saved) {
        MNUtil.showHUD(`å·²æ·»åŠ åˆ°ä¸­é—´çŸ¥è¯†åº“å¢é‡ç´¢å¼• (å…± ${incrementalIndex.metadata.cardCount} å¼ )`, 0.5);
        return true;
      } else {
        return false;
      }

    } catch (error) {
      MNUtil.showHUD("æ·»åŠ åˆ°ä¸­é—´çŸ¥è¯†åº“å¢é‡ç´¢å¼•å¤±è´¥: " + error.message);
      MNLog.error(error, "IntermediateKnowledgeIndexer: addToIncrementalIndex");
      return false;
    }
  }

  /**
   * æ¸…ç©ºå¢é‡ç´¢å¼•
   * @returns {boolean} æ¸…ç©ºæˆåŠŸè¿”å› true
   */
  static clearIncrementalIndex() {
    try {
      const filepath = MNUtil.dbFolder + "/data/intermediate-kb-incremental-index.json";

      // åˆå§‹åŒ–ç©ºçš„å¢é‡ç´¢å¼•
      const emptyIndex = {
        metadata: {
          version: "intermediate-incremental-1.0",
          lastUpdated: new Date().toISOString(),
          cardCount: 0
        },
        cards: []
      };

      MNUtil.writeJSON(filepath, emptyIndex);
      MNUtil.log("ä¸­é—´çŸ¥è¯†åº“å¢é‡ç´¢å¼•å·²æ¸…ç©º");
      return true;
    } catch (error) {
      MNLog.error(error, "IntermediateKnowledgeIndexer: clearIncrementalIndex");
      return false;
    }
  }
}


class KnowledgeBaseUtils {
  static errorLog = []
  static webViewController = null  // å­˜å‚¨æ§åˆ¶å™¨å®ä¾‹

  /**
   * æ£€æŸ¥å¹¶åˆ›å»º WebView æ§åˆ¶å™¨ï¼ˆå•ä¾‹æ¨¡å¼ - å‚è€ƒ mnliteratureï¼‰
   *
   * è¿™æ˜¯å»¶è¿Ÿåˆå§‹åŒ–ç­–ç•¥ï¼Œé¿å…åœ¨ sceneWillConnect ä¸­åˆ›å»ºæ§åˆ¶å™¨å¯¼è‡´å´©æºƒ
   */
  static checkWebViewController() {
    // å•ä¾‹æ¨¡å¼ï¼šå¦‚æœæ§åˆ¶å™¨ä¸å­˜åœ¨åˆ™åˆ›å»º
    if (!this.webViewController) {
      // åˆ›å»ºè§†å›¾æ§åˆ¶å™¨å®ä¾‹
      this.webViewController = knowledgebaseWebController.new()
      // åˆå§‹çŠ¶æ€è®¾ä¸ºéšè—ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æ‰“å¼€
      this.webViewController.view.hidden = true
    }
    // ç¡®ä¿è§†å›¾åœ¨æ­£ç¡®çš„çˆ¶è§†å›¾ä¸­
    if (!MNUtil.isDescendantOfStudyView(this.webViewController.view)) {
      MNUtil.studyView.addSubview(this.webViewController.view)
    }
  }

  static log(message, source, detail, level = "INFO"){
    MNUtil.log({message:message, detail:detail, source:"MN KnowledgeBase:" + source , level:level})
  }
  
  static addErrorLog(error, source, info){
    MNUtil.showHUD("MN KnowledgeBase Error ("+source+"): "+error)
    let tem = {source:source,time:(new Date(Date.now())).toString()}
    if (error.detail) {
      tem.error = {message:error.message,detail:error.detail}
    }else{
      tem.error = error.message
    }
    if (info) {
      tem.info = info
    }
    this.errorLog.push(tem)
    MNUtil.copy(this.errorLog)
    if (typeof MNUtil.log !== 'undefined') {
      MNUtil.log({
        source:"MN KnowledgeBase",
        level:"error",
        message:source,
        detail:tem,
      })
    }
  }
}

class KnowledgeBaseNetwork {
  /**
   * OCR å¸¸è§è¯†åˆ«é”™è¯¯çº æ­£è§„åˆ™
   * ç”¨äºæé«˜æ•°å­¦ç¬¦å·ã€ä¸‹æ ‡ã€ä¸Šæ ‡ç­‰çš„è¯†åˆ«å‡†ç¡®æ€§
   */
  static OCRCorrectionRules = `
## å¸¸è§ OCR è¯†åˆ«é”™è¯¯çº æ­£è§„åˆ™

### ä¸‹æ ‡é—®é¢˜
- X1, Y2, Z3 ç­‰ â†’ Xâ‚, Yâ‚‚, Zâ‚ƒï¼ˆä½¿ç”¨ Unicode ä¸‹æ ‡å­—ç¬¦ï¼‰
- a_i, x_n, y_k â†’ aáµ¢, xâ‚™, yâ‚–
- å®Œæ•´çš„ Unicode ä¸‹æ ‡å­—ç¬¦é›†ï¼šâ‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚Šâ‚‹â‚Œâ‚â‚â‚â‚‘â‚’â‚“â‚”â‚•â‚–â‚—â‚˜â‚™â‚šâ‚›â‚œ

### ä¸Šæ ‡é—®é¢˜
- x2, y3, z4 â†’ xÂ², yÂ³, zâ´ï¼ˆä½¿ç”¨ Unicode ä¸Šæ ‡å­—ç¬¦ï¼‰
- xn, an â†’ xâ¿, aâ¿
- å®Œæ•´çš„ Unicode ä¸Šæ ‡å­—ç¬¦é›†ï¼šâ°Â¹Â²Â³â´âµâ¶â·â¸â¹âºâ»â¼â½â¾â¿â±
- ç§¯åˆ†æˆ–è€…æ±‚å’Œçš„ä¸Šé™ä¸éœ€è¦ ^, æ¯”å¦‚ Î£â‚™â‚Œâ‚âˆ å°±è¡Œï¼Œä¸è¦å†™æˆ  Î£â‚™â‚Œâ‚^âˆ

### å¸Œè…Šå­—æ¯è¯†åˆ«
- Î± alpha, Î² beta, Î³ gamma, Î´ delta, Îµ epsilon
- Î¶ zeta, Î· eta, Î¸ theta, Î¹ iota, Îº kappa
- Î» lambda, Î¼ mu, Î½ nu, Î¾ xi, Î¿ omicron
- Ï€ pi, Ï rho, Ïƒ sigma, Ï„ tau, Ï… upsilon
- Ï• phi, Ï‡ chi, Ïˆ psi, Ï‰ omega
- Î“ Gamma, Î” Delta, Î˜ Theta, Î› Lambda, Î Xi
- Î  Pi, Î£ Sigma, Î¦ Phi, Î¨ Psi, Î© Omega

å°¤å…¶æ˜¯ Ï•ï¼Œè¦æ³¨æ„ä¼˜å…ˆä½¿ç”¨ Ï• è€Œä¸æ˜¯ Ï†

### æ•°å­¦è¿ç®—ç¬¦
- Ã— ä¹˜å·ï¼ˆä¸æ˜¯å­—æ¯ xï¼‰, Â· ç‚¹ä¹˜, Ã· é™¤å·
- â‰¤ å°äºç­‰äº, â‰¥ å¤§äºç­‰äº, â‰  ä¸ç­‰äº, â‰ˆ çº¦ç­‰äº
- âˆˆ å±äº, âˆ‰ ä¸å±äº, âŠ‚ çœŸåŒ…å«, âŠ† åŒ…å«, âˆª å¹¶, âˆ© äº¤
- âˆ€ ä»»æ„, âˆƒ å­˜åœ¨, âˆ„ ä¸å­˜åœ¨
- âˆ« ç§¯åˆ†, âˆ® ç¯è·¯ç§¯åˆ†, âˆ‚ åå¾®åˆ†, âˆ‡ æ¢¯åº¦
- âˆ‘ æ±‚å’Œ, âˆ æ±‚ç§¯, âˆš æ ¹å·, âˆ æ— ç©·

### ç®­å¤´å’Œå…³ç³»ç¬¦å·
- â†’ å³ç®­å¤´, â† å·¦ç®­å¤´, â†” åŒå‘ç®­å¤´
- â‡’ æ¨å‡º, â‡ æ¨è‡ª, â‡” ç­‰ä»·
- â†¦ æ˜ å°„åˆ°

### é›†åˆç¬¦å·
- â„• è‡ªç„¶æ•°é›†, â„¤ æ•´æ•°é›†, â„š æœ‰ç†æ•°é›†
- â„ å®æ•°é›†, â„‚ å¤æ•°é›†

### æ‹¬å·å’Œåˆ†éš”ç¬¦
- () åœ†æ‹¬å·, [] æ–¹æ‹¬å·, {} èŠ±æ‹¬å·
- âŸ¨âŸ© å°–æ‹¬å·ï¼ˆç”¨äºå†…ç§¯ï¼‰, âŒˆâŒ‰ ä¸Šå–æ•´, âŒŠâŒ‹ ä¸‹å–æ•´
- | | ç»å¯¹å€¼/èŒƒæ•°, â€– â€– èŒƒæ•°

### å¸¸è§è¯¯è¯†åˆ«æ¨¡å¼
- "1" å¯èƒ½è¢«è¯†åˆ«ä¸ºå­—æ¯ "l" æˆ– "I"
- "0" å¯èƒ½è¢«è¯†åˆ«ä¸ºå­—æ¯ "O" æˆ– "o"
- "Ã—"ï¼ˆä¹˜å·ï¼‰å¯èƒ½è¢«è¯†åˆ«ä¸ºå­—æ¯ "x"
- "âˆˆ"ï¼ˆå±äºï¼‰å¯èƒ½è¢«è¯†åˆ«ä¸º "E" æˆ– "Ñ”"
- æ³¨æ„åŒºåˆ†ï¼š0Oï¼ˆæ•°å­—é›¶/å­—æ¯Oï¼‰, 1lIï¼ˆæ•°å­—ä¸€/å°å†™l/å¤§å†™Iï¼‰

### ç©ºæ ¼å¤„ç†
- æ•°å­¦è¡¨è¾¾å¼ä¸­çš„è¿ç®—ç¬¦ä¸¤ä¾§é€šå¸¸æœ‰ç©ºæ ¼ï¼ša + b, x = 1
- å‡½æ•°åå’Œæ‹¬å·ä¹‹é—´æ— ç©ºæ ¼ï¼šf(x), sin(Î¸)
- ä¸‹æ ‡ã€ä¸Šæ ‡ä¸åŸºç¡€å­—ç¬¦æ— ç©ºæ ¼ï¼šxâ‚, yÂ²
`

  /**
   * OCR åºå·ç»Ÿä¸€è½¬æ¢è§„åˆ™
   * å°†å„ç§åºå·æ ¼å¼ç»Ÿä¸€è½¬æ¢ä¸ºå¸¦åœˆæ•°å­—
   */
  static OCRNumberingRules = `
## åºå·ç»Ÿä¸€è½¬æ¢è§„åˆ™

**æ ¸å¿ƒåŸåˆ™**ï¼šå°†æ‰€æœ‰åºå·æ ¼å¼ç»Ÿä¸€è½¬æ¢ä¸ºå¸¦åœˆæ•°å­—ï¼Œä¿æŒè¾“å‡ºæ ¼å¼ä¸€è‡´æ€§ã€‚

### è½¬æ¢è§„åˆ™

#### 1. é˜¿æ‹‰ä¼¯æ•°å­—åºå·
- \`1.\` \`2.\` \`3.\` â†’ â‘  â‘¡ â‘¢
- \`(1)\` \`(2)\` \`(3)\` â†’ â‘  â‘¡ â‘¢
- \`1)\` \`2)\` \`3)\` â†’ â‘  â‘¡ â‘¢

#### 2. ç½—é©¬æ•°å­—åºå·ï¼ˆå°å†™ï¼‰
- \`(i)\` \`(ii)\` \`(iii)\` â†’ â‘  â‘¡ â‘¢
- \`(iv)\` \`(v)\` \`(vi)\` â†’ â‘£ â‘¤ â‘¥
- \`(vii)\` \`(viii)\` \`(ix)\` \`(x)\` â†’ â‘¦ â‘§ â‘¨ â‘©
- \`i.\` \`ii.\` \`iii.\` â†’ â‘  â‘¡ â‘¢

#### 3. ç½—é©¬æ•°å­—åºå·ï¼ˆå¤§å†™ï¼‰
- \`(I)\` \`(II)\` \`(III)\` â†’ â‘  â‘¡ â‘¢
- \`(IV)\` \`(V)\` \`(VI)\` â†’ â‘£ â‘¤ â‘¥
- \`I.\` \`II.\` \`III.\` â†’ â‘  â‘¡ â‘¢

#### 4. å­—æ¯åºå·ï¼ˆå°å†™ï¼‰
- \`(a)\` \`(b)\` \`(c)\` â†’ â‘  â‘¡ â‘¢
- \`a)\` \`b)\` \`c)\` â†’ â‘  â‘¡ â‘¢
- \`a.\` \`b.\` \`c.\` â†’ â‘  â‘¡ â‘¢

#### 5. å­—æ¯åºå·ï¼ˆå¤§å†™ï¼‰
- \`(A)\` \`(B)\` \`(C)\` â†’ â‘  â‘¡ â‘¢
- \`A)\` \`B)\` \`C)\` â†’ â‘  â‘¡ â‘¢
- \`A.\` \`B.\` \`C.\` â†’ â‘  â‘¡ â‘¢

### å¸¦åœˆæ•°å­—å­—ç¬¦é›†
- 1-20ï¼šâ‘  â‘¡ â‘¢ â‘£ â‘¤ â‘¥ â‘¦ â‘§ â‘¨ â‘© â‘ª â‘« â‘¬ â‘­ â‘® â‘¯ â‘° â‘± â‘² â‘³
- 21-50ï¼šã‰‘ ã‰’ ã‰“ ã‰” ã‰• ã‰– ã‰— ã‰˜ ã‰™ ã‰š ã‰› ã‰œ ã‰ ã‰ ã‰Ÿ ãŠ± ãŠ² ãŠ³ ãŠ´ ãŠµ ãŠ¶ ãŠ· ãŠ¸ ãŠ¹ ãŠº ãŠ» ãŠ¼ ãŠ½ ãŠ¾ ãŠ¿

### å¤„ç†ç¤ºä¾‹

**ç¤ºä¾‹ 1ï¼šè¯æ˜æ­¥éª¤**
- è¾“å…¥ï¼š1. é¦–å…ˆè¯æ˜å……åˆ†æ€§ 2. ç„¶åè¯æ˜å¿…è¦æ€§
- âœ… è¾“å‡ºï¼šâ‘  é¦–å…ˆè¯æ˜å……åˆ†æ€§ â‘¡ ç„¶åè¯æ˜å¿…è¦æ€§

**ç¤ºä¾‹ 2ï¼šå®šç†æ¡ä»¶**
- è¾“å…¥ï¼š(i) f æ˜¯è¿ç»­çš„ (ii) f æ˜¯å¯å¾®çš„
- âœ… è¾“å‡ºï¼šâ‘  f æ˜¯è¿ç»­çš„ â‘¡ f æ˜¯å¯å¾®çš„

**ç¤ºä¾‹ 3ï¼šåˆ†ç±»è®¨è®º**
- è¾“å…¥ï¼š(a) å½“ x>0 æ—¶ (b) å½“ x<0 æ—¶
- âœ… è¾“å‡ºï¼šâ‘  å½“ x>0 æ—¶ â‘¡ å½“ x<0 æ—¶

### æ³¨æ„äº‹é¡¹
- ä¿æŒåºå·çš„é¡ºåºå¯¹åº”å…³ç³»
- å¦‚æœåŸæ–‡ä½¿ç”¨ä¸åŒå±‚çº§çš„åºå·ï¼ˆå¦‚ 1. (a) (i)ï¼‰ï¼Œç»Ÿä¸€è½¬æ¢ä¸ºå¸¦åœˆæ•°å­—
- åºå·åçš„å†…å®¹ä¿æŒä¸å˜
- å¦‚æœåºå·è¶…è¿‡ 50ï¼Œç»§ç»­ä½¿ç”¨é˜¿æ‹‰ä¼¯æ•°å­—æ ¼å¼ï¼ˆå¦‚ 51. 52.ï¼‰
`

  /**
   * OCR äººåå¤„ç†è§„åˆ™
   * æ‰€æœ‰ OCR æç¤ºè¯å…±äº«çš„äººåå¤„ç†è§„èŒƒ
   */
  static OCRNameHandlingRules = `
**äººåå¤„ç†è§„åˆ™**ï¼š
- âœ… äººåå§‹ç»ˆä¿æŒåŸæ–‡æ‹¼å†™ï¼šClark, Aleksandrov, Fourier, Cauchy
- âœ… ä¸“ä¸šæœ¯è¯­ä¸­çš„äººåä¿æŒåŸæ–‡ï¼šClark measure â†’ Clark æµ‹åº¦ï¼ˆä¸æ˜¯"å…‹æ‹‰å…‹æµ‹åº¦"ï¼‰
- âœ… å¥å­ä¸­çš„äººåä¿æŒåŸæ–‡ï¼šç”± Clark ç ”ç©¶ï¼ˆä¸æ˜¯"ç”±å…‹æ‹‰å…‹ç ”ç©¶"ï¼‰
- âœ… äººåæ‰€æœ‰æ ¼ä¿æŒåŸæ–‡ï¼šClark's theorem â†’ Clark å®šç†
- âœ… å¸¸è§æ•°å­¦å®¶äººåç¤ºä¾‹ï¼š
  - Fourier, Laplace, Cauchy, Riemann, Lebesgue
  - Banach, Hilbert, Sobolev, Schwartz, HÃ¶lder
  - Clark, Aleksandrov, Kolmogorov, Chebyshev
`

  /**
   * OCR ç©ºæ ¼å¤„ç†è§„åˆ™
   * æ‰€æœ‰ OCR æç¤ºè¯å…±äº«çš„ç©ºæ ¼å¤„ç†è§„èŒƒ
   */
  static OCRSpaceHandlingRules = `
**è§„åˆ™ Aï¼šæ•°å­¦å…¬å¼å†…ç´§å‡‘ï¼Œç§»é™¤å¤šä½™ç©ºæ ¼**
---
âŒ é”™è¯¯ï¼š|a + b| / (1 + |a + b|) â‰¤ |a| / (1 + |a|)
âœ… æ­£ç¡®ï¼š|a+b|/(1+|a+b|)â‰¤|a|/(1+|a|)
---

**è§„åˆ™ Bï¼šæ–‡æœ¬é—´ä¿ç•™å¿…è¦ç©ºæ ¼**
---
âŒ é”™è¯¯ï¼šTheorem1.1(StrongLaw)
âœ… æ­£ç¡®ï¼šTheorem 1.1 (Strong Law)

âŒ é”™è¯¯ï¼šè®¾a,bâˆˆR,åˆ™æœ‰
âœ… æ­£ç¡®ï¼šè®¾ a, bâˆˆR, åˆ™æœ‰
---
`

  /**
   * OCR å¸¸ç”¨æœ¯è¯­å¯¹ç…§è¡¨
   * ä¸­è‹±æ–‡æ•°å­¦æœ¯è¯­å¯¹ç…§
   */
  static OCRTerminologyMapping = `
**å¸¸ç”¨æœ¯è¯­å¯¹ç…§**ï¼š
- Theorem â†’ å®šç† | Lemma â†’ å¼•ç† | Corollary â†’ æ¨è®º | Proposition â†’ å‘½é¢˜
- Definition â†’ å®šä¹‰ | Proof â†’ è¯æ˜ | Example â†’ ä¾‹å­ | Exercise â†’ ç»ƒä¹ 
- Limit â†’ æé™ | Convergence â†’ æ”¶æ•› | Derivative â†’ å¯¼æ•° | Integral â†’ ç§¯åˆ†
- Continuous â†’ è¿ç»­ | Differentiable â†’ å¯å¾® | Measurable â†’ å¯æµ‹
`

  /**
   * OCR ç»“æœåå¤„ç†æ­£åˆ™æ›¿æ¢è§„åˆ™
   */
  static OCRPostProcessingRules = kbOCRConfig.postProcessingRules;

  /**
   * å¯¹ OCR ç»“æœè¿›è¡Œåå¤„ç†
   * @param {string} ocrResult - OCR åŸå§‹ç»“æœ
   * @returns {string} å¤„ç†åçš„ç»“æœ
   */
  static postProcessOCRResult(ocrResult) {
    if (!ocrResult) return ocrResult

    let result = ocrResult

    // ä¾æ¬¡åº”ç”¨æ‰€æœ‰æ›¿æ¢è§„åˆ™
    this.OCRPostProcessingRules.forEach(rule => {
      result = result.replace(rule.pattern, rule.replacement)
    })

    return result
  }

  static get OCRDirectlyPrompt() {
    return `
# æ•°å­¦æ–‡æœ¬ OCR æç¤ºè¯

## æ ¸å¿ƒä»»åŠ¡
ä»å›¾ç‰‡ä¸­æå–æ–‡æœ¬ï¼Œä¼˜å…ˆä½¿ç”¨ Unicode å­—ç¬¦è¾“å‡ºï¼Œå¹¶æä¾›ä¸“ä¸šçš„ä¸­æ–‡æ•°å­¦ç¿»è¯‘ã€‚

**å…³é”®è¦æ±‚**ï¼š
- å·²æ˜¯ä¸­æ–‡çš„å†…å®¹ä¿æŒåŸæ ·ï¼Œä¸ç¿»è¯‘
- ç¦æ­¢ä½¿ç”¨ LaTeX åŒ…è£¹ç¬¦å·ï¼ˆ$...$ï¼‰ï¼Œä¼˜å…ˆ Unicode
- æ— éœ€æ·»åŠ  "æˆ‘çœ‹åˆ°..." ç­‰æè¿°æ€§å‰ç¼€

## è¾“å‡ºæ ¼å¼è¦æ±‚

**é‡è¦**ï¼šç›´æ¥è¾“å‡ºå†…å®¹ï¼Œä¸è¦æ·»åŠ ä»»ä½•æ ¼å¼æ ‡è®°æˆ–å‰ç¼€ï¼

### æƒ…å†µ 1ï¼šè‹±æ–‡/å…¶ä»–è¯­è¨€å†…å®¹
è¾“å‡ºæ ¼å¼ï¼š"<ä¸­æ–‡ç¿»è¯‘>: <åŸæ–‡ Unicode å½¢å¼>"

**æ­£ç¡®ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šLet f be a continuous function on [a,b]
- âœ… è¾“å‡ºï¼šè®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°: Let f be a continuous function on [a,b]

**é”™è¯¯ç¤ºä¾‹**ï¼ˆç¦æ­¢ï¼‰ï¼š
- âŒ [ä¸­æ–‡ä¸“ä¸šç¿»è¯‘]: è®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°: Let f be a continuous function on [a,b]
- âŒ ç¿»è¯‘ï¼šè®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°
- âŒ ä¸­æ–‡ç¿»è¯‘: è®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°

### æƒ…å†µ 2ï¼šå·²æ˜¯ä¸­æ–‡å†…å®¹
è¾“å‡ºæ ¼å¼ï¼š"<åŸæ–‡>"ï¼ˆä¿æŒåŸæ ·ï¼‰

**æ­£ç¡®ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šè®¾ f æ˜¯è¿ç»­å‡½æ•°
- âœ… è¾“å‡ºï¼šè®¾ f æ˜¯è¿ç»­å‡½æ•°

**é”™è¯¯ç¤ºä¾‹**ï¼ˆç¦æ­¢ï¼‰ï¼š
- âŒ [åŸæ–‡]: è®¾ f æ˜¯è¿ç»­å‡½æ•°
- âŒ ä¸­æ–‡: è®¾ f æ˜¯è¿ç»­å‡½æ•°

## å¤„ç†è§„åˆ™

### 1. ç©ºæ ¼å¤„ç†

${this.OCRSpaceHandlingRules}

### 2. ç¿»è¯‘è§„åˆ™

**æ ¸å¿ƒåŸåˆ™**ï¼š
- âœ… ä½¿ç”¨æ ‡å‡†æ•°å­¦æ•™ææœ¯è¯­ï¼ˆå¦‚é«˜ç­‰æ•™è‚²å‡ºç‰ˆç¤¾æ•°å­¦è¯æ±‡ï¼‰
- âœ… å…¬å¼ä¿æŒåŸæ ·ï¼Œä»…ç¿»è¯‘æè¿°æ€§æ–‡å­—
- âœ… æ ¹æ®æ•°å­¦åˆ†æ”¯ï¼ˆåˆ†æ/ä»£æ•°/å‡ ä½•ç­‰ï¼‰é€‰æ‹©æ°å½“æœ¯è¯­
- âŒ å»æ‰æ•°å­¦é™ˆè¿°çš„ç¼–å·æ ‡è®°ï¼ˆå®Œå…¨åˆ é™¤ï¼Œä¸ä¿ç•™ï¼‰
- âŒ å»æ‰æœ«å°¾æ ‡ç‚¹

**å®šç†åç§°æ ¼å¼**ï¼ˆç”¨åˆ†å·åˆ†éš”ä¸­æ–‡ã€è‹±æ–‡ï¼‰ï¼š
    ç¤ºä¾‹ï¼šå¦‚æœâ€¦â€¦, åˆ™èŒƒæ•°ä¸€è‡´æœ‰ç•Œ; ä¸€è‡´æœ‰ç•ŒåŸç†; uniformly bounded principle

${this.OCRNameHandlingRules}

${this.OCRTerminologyMapping}

### 3. æ ‡è®°ç§»é™¤è§„åˆ™ âš ï¸

**æ ¸å¿ƒåŸåˆ™**ï¼šå®Œå…¨åˆ é™¤æ•°å­¦é™ˆè¿°çš„ç¼–å·æ ‡è®°ï¼Œè¿™äº›æ ‡è®°å¯¹å†…å®¹ç†è§£æ²¡æœ‰å¸®åŠ©ã€‚

**éœ€è¦ç§»é™¤çš„æ ‡è®°ç±»å‹**ï¼š

#### å®šç†ç±»æ ‡è®°
- âŒ å®šç† 2.24ã€Theorem 1.1ã€å®šç† 1
- âŒ å¼•ç† 3.5ã€Lemma 2.3ã€å¼•ç† 2
- âŒ æ¨è®º 1.12ã€Corollary 4.2ã€æ¨è®º 3
- âŒ å‘½é¢˜ 5.7ã€Proposition 6.1ã€å‘½é¢˜ 4

#### ä¾‹é¢˜ç±»æ ‡è®°
- âŒ ä¾‹å­ 2ã€Example 3.4ã€ä¾‹ 1
- âŒ åä¾‹ 1.3ã€Counterexample 2
- âŒ æ³¨é‡Š 4ã€Remark 2.1ã€æ³¨ 3

#### ç»ƒä¹ ç±»æ ‡è®°
- âŒ ç»ƒä¹  1.2ã€Exercise 3.5ã€ä¹ é¢˜ 4
- âŒ é—®é¢˜ 2.3ã€Problem 5.1ã€é¢˜ 6

**æ­£ç¡®å¤„ç†ç¤ºä¾‹**ï¼š

**ç¤ºä¾‹ 1ï¼šå®šç†ç¼–å·**
- è¾“å…¥å›¾ç‰‡ï¼šTheorem 2.24 (Cauchy Criterion): A sequence converges if...
- âŒ é”™è¯¯ï¼šå®šç† 2.24 (Cauchy å‡†åˆ™): åºåˆ—æ”¶æ•›å½“ä¸”ä»…å½“...
- âœ… æ­£ç¡®ï¼šåºåˆ—æ”¶æ•›å½“ä¸”ä»…å½“...; Cauchy å‡†åˆ™; Cauchy Criterion

**ç¤ºä¾‹ 2ï¼šæ¨è®ºç¼–å·**
- è¾“å…¥å›¾ç‰‡ï¼šæ¨è®º 1.12: è‹¥ f è¿ç»­ï¼Œåˆ™...
- âŒ é”™è¯¯ï¼šæ¨è®º 1.12: è‹¥ f è¿ç»­ï¼Œåˆ™...
- âœ… æ­£ç¡®ï¼šè‹¥ f è¿ç»­ï¼Œåˆ™...: If f is continuous, then...

**ç¤ºä¾‹ 3ï¼šç»ƒä¹ ç¼–å·**
- è¾“å…¥å›¾ç‰‡ï¼šExercise 1.2: Prove that...
- âŒ é”™è¯¯ï¼šç»ƒä¹  1.2: è¯æ˜...
- âœ… æ­£ç¡®ï¼šè¯æ˜...: Prove that...

**ç¤ºä¾‹ 4ï¼šä¾‹å­ç¼–å·**
- è¾“å…¥å›¾ç‰‡ï¼šä¾‹å­ 3: è®¾ f(x) = xÂ²
- âŒ é”™è¯¯ï¼šä¾‹å­ 3: è®¾ f(x) = xÂ²
- âœ… æ­£ç¡®ï¼šè®¾ f(x) = xÂ²: Let f(x) = xÂ²

**âš ï¸ ç‰¹åˆ«æ³¨æ„**ï¼š
- ç¼–å·åŒ…æ‹¬å•ä¸ªæ•°å­—ï¼ˆå¦‚ "å®šç† 1"ï¼‰å’Œå¸¦å°æ•°ç‚¹çš„æ•°å­—ï¼ˆå¦‚ "å®šç† 2.24"ï¼‰
- éœ€è¦ç§»é™¤æ ‡è®°è¯ + ç¼–å·ï¼Œä½†ä¿ç•™æ‹¬å·ä¸­çš„å®šç†åç§°ï¼ˆå¦‚ "Cauchy å‡†åˆ™"ï¼‰
- æ ‡è®°å¯èƒ½åœ¨å¼€å¤´æˆ–å†…å®¹å‰ï¼Œéƒ½è¦è¯†åˆ«å¹¶ç§»é™¤

${this.OCRCorrectionRules}

${this.OCRNumberingRules}

## æœ€ç»ˆæ£€æŸ¥æ¸…å•
1. æ‰€æœ‰ä¸‹æ ‡ã€ä¸Šæ ‡æ˜¯å¦ä½¿ç”¨äº†æ­£ç¡®çš„ Unicode å­—ç¬¦
2. æ•°å­¦ç¬¦å·æ˜¯å¦å‡†ç¡®ï¼ˆç‰¹åˆ«æ³¨æ„ä¹˜å·ã€å±äºç¬¦å·ç­‰ï¼‰
3. å¸Œè…Šå­—æ¯æ˜¯å¦æ­£ç¡®è¯†åˆ«
4. æ•°å­—å’Œå­—æ¯æ˜¯å¦æ··æ·†ï¼ˆ0/O, 1/l/I ç­‰ï¼‰
5. ç©ºæ ¼æ˜¯å¦ç¬¦åˆæ•°å­¦æ’ç‰ˆè§„èŒƒ
`
  }


  static OCRToMarkdownPrompt = `
# æ•°å­¦æ–‡æœ¬ OCR - Markdown LaTeX æ ¼å¼

## æ ¸å¿ƒä»»åŠ¡
ä»å›¾ç‰‡ä¸­æå–æ•°å­¦å†…å®¹ï¼Œå¹¶ä»¥ Markdown + LaTeX æ ¼å¼è¾“å‡ºï¼Œé€‚ç”¨äºæ•°å­¦ç¬”è®°å’Œæ–‡æ¡£ã€‚

**å…³é”®è¦æ±‚**ï¼š
- æ‰€æœ‰æ•°å­¦å…¬å¼ä½¿ç”¨ LaTeX è¯­æ³•ï¼Œå¹¶ç”¨ $ æˆ– $$ åŒ…è£¹
- è¡Œå†…å…¬å¼ä½¿ç”¨ $...$
- ç‹¬ç«‹å…¬å¼ä½¿ç”¨ $$...$$ï¼ˆå•ç‹¬æˆè¡Œï¼‰
- æ–‡æœ¬éƒ¨åˆ†ä¿æŒä¸­æ–‡æˆ–åŸæ–‡
- æ— éœ€æ·»åŠ  "æˆ‘çœ‹åˆ°..." ç­‰æè¿°æ€§å‰ç¼€

## è¾“å‡ºæ ¼å¼

### æ ¼å¼ 1ï¼šçº¯å…¬å¼
å¯¹äºçº¯æ•°å­¦å…¬å¼çš„å›¾ç‰‡ï¼Œç›´æ¥è¾“å‡º LaTeXï¼š
$$å…¬å¼å†…å®¹$$

**ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šf(x) = xÂ²+2x+1
- è¾“å‡ºï¼š$f(x) = x^2+2x+1$

### æ ¼å¼ 2ï¼šæ··åˆå†…å®¹
å¯¹äºåŒ…å«æ–‡å­—æè¿°çš„å†…å®¹ï¼Œæ··åˆä½¿ç”¨æ–‡æœ¬å’Œå…¬å¼ï¼š

**ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šè®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°
- è¾“å‡ºï¼šè®¾ $f$ æ˜¯ $[a,b]$ ä¸Šçš„è¿ç»­å‡½æ•°

- è¾“å…¥ï¼šThe function f: Râ†’R is continuous
- è¾“å‡ºï¼šå‡½æ•° $f: \\mathbb{R} \\to \\mathbb{R}$ æ˜¯è¿ç»­çš„

## LaTeX è¯­æ³•è§„åˆ™

### 1. åŸºæœ¬ç¬¦å·
- ä¸Šæ ‡ï¼šx^2, x^{n+1}
- ä¸‹æ ‡ï¼šx_1, x_{i,j}
- åˆ†æ•°ï¼š\\frac{a}{b}
- æ ¹å¼ï¼š\\sqrt{2}, \\sqrt[3]{8}
- å¸Œè…Šå­—æ¯ï¼š\\alpha, \\beta, \\gamma, \\delta, \\epsilon, \\theta, \\lambda, \\pi, \\sigma

### 2. è¿ç®—ç¬¦
- \\pm (Â±), \\times (Ã—), \\div (Ã·), \\cdot (Â·)
- \\leq (â‰¤), \\geq (â‰¥), \\neq (â‰ ), \\approx (â‰ˆ)
- \\in (âˆˆ), \\notin (âˆ‰), \\subset (âŠ‚), \\subseteq (âŠ†)
- \\cup (âˆª), \\cap (âˆ©), \\emptyset (âˆ…)

### 3. å¾®ç§¯åˆ†
- æé™ï¼š\\lim_{x \\to a}, \\lim_{n \\to \\infty}
- æ±‚å’Œï¼š\\sum_{i=1}^{n}, \\sum_{k=0}^{\\infty}
- ç§¯åˆ†ï¼š\\int_{a}^{b}, \\iint, \\iiint, \\oint
- åå¯¼ï¼š\\frac{\\partial f}{\\partial x}, \\nabla
- å¯¼æ•°ï¼šf'(x), f''(x), \\dot{x}, \\ddot{x}

### 4. æ‹¬å·
- å°æ‹¬å·ï¼š(x), è‡ªåŠ¨è°ƒæ•´ï¼š\\left( ... \\right)
- ä¸­æ‹¬å·ï¼š[a,b], è‡ªåŠ¨è°ƒæ•´ï¼š\\left[ ... \\right]
- å¤§æ‹¬å·ï¼š\\{ ... \\}, è‡ªåŠ¨è°ƒæ•´ï¼š\\left\\{ ... \\right\\}
- èŒƒæ•°ï¼š\\| x \\|, ç»å¯¹å€¼ï¼š\\| a \\|

### 5. å¸¸ç”¨æ•°å­¦é›†åˆ
- è‡ªç„¶æ•°ï¼š\\mathbb{N}
- æ•´æ•°ï¼š\\mathbb{Z}
- æœ‰ç†æ•°ï¼š\\mathbb{Q}
- å®æ•°ï¼š\\mathbb{R}
- å¤æ•°ï¼š\\mathbb{C}

### 6. å‡½æ•°å’Œæ˜ å°„
- æ˜ å°„ï¼šf: A \\to B
- å¤åˆï¼šf \\circ g
- åå‡½æ•°ï¼šf^{-1}

### 7. é€»è¾‘ç¬¦å·
- ä»»æ„ï¼š\\forall
- å­˜åœ¨ï¼š\\exists
- è•´å«ï¼š\\Rightarrow, \\Leftarrow, \\Leftrightarrow
- éï¼š\\neg
- ä¸”ï¼š\\wedge (âˆ§)
- æˆ–ï¼š\\vee (âˆ¨)

## ç©ºæ ¼å¤„ç†è§„åˆ™

**è§„åˆ™ Aï¼šLaTeX å†…ä¸éœ€è¦æ‰‹åŠ¨ç©ºæ ¼**
LaTeX ä¼šè‡ªåŠ¨å¤„ç†å…¬å¼å†…çš„é—´è·ï¼š
- âœ… $f(x)=x^2+2x+1$ï¼ˆæ— ç©ºæ ¼ï¼‰
- âŒ $f(x) = x^2 + 2x + 1$ï¼ˆä¸å¿…è¦çš„ç©ºæ ¼ï¼‰

**è§„åˆ™ Bï¼šæ–‡æœ¬éƒ¨åˆ†ä¿ç•™å¿…è¦ç©ºæ ¼**
- âœ… è®¾ $f$ æ˜¯è¿ç»­å‡½æ•°ï¼ˆä¸­æ–‡è¯é—´æœ‰ç©ºæ ¼ï¼‰
- âœ… Let $f$ be continuousï¼ˆè‹±æ–‡å•è¯é—´æœ‰ç©ºæ ¼ï¼‰

## ç¿»è¯‘è§„åˆ™
- å·²æ˜¯ä¸­æ–‡çš„ä¿æŒåŸæ ·
- è‹±æ–‡æ•°å­¦æœ¯è¯­ç¿»è¯‘ä¸ºæ ‡å‡†ä¸­æ–‡ï¼ˆå‚è€ƒé«˜æ•™å‡ºç‰ˆç¤¾æ•°å­¦è¯å…¸ï¼‰
- å…¬å¼ç¬¦å·ä¿æŒåŸæ ·ï¼Œä»…ç¿»è¯‘æè¿°æ€§æ–‡å­—
- å»æ‰æ•°å­¦é™ˆè¿°çš„ç¼–å·æ ‡è®°ï¼ˆå®Œå…¨åˆ é™¤ï¼Œä¸ä¿ç•™ï¼‰
- å»æ‰æœ«å°¾æ ‡ç‚¹

${this.OCRNameHandlingRules}

**æ ‡è®°ç§»é™¤ç¤ºä¾‹**ï¼š
- Theorem 1.1 (Strong Law): If ... â†’ å¼ºå¤§æ•°å®šå¾‹ï¼šè‹¥ ...ï¼ˆç§»é™¤ "Theorem 1.1"ï¼‰
- Example 2.3: Let f be ... â†’ è®¾ $f$ ä¸º ...ï¼ˆç§»é™¤ "Example 2.3"ï¼‰
- æ¨è®º 1.12: è‹¥ f è¿ç»­ â†’ è‹¥ $f$ è¿ç»­ï¼ˆç§»é™¤ "æ¨è®º 1.12"ï¼‰
- ç»ƒä¹  1.2: è¯æ˜... â†’ è¯æ˜...ï¼ˆç§»é™¤ "ç»ƒä¹  1.2"ï¼‰

${this.OCRNumberingRules}
`

  static OCRExtractConceptPrompt = `
# æ•°å­¦æ¦‚å¿µ/å®šç†æå–

## æ ¸å¿ƒä»»åŠ¡
ä»å›¾ç‰‡ä¸­çš„æ•°å­¦å®šä¹‰æˆ–å®šç†ä¸­**ä»…æå–è¢«å®šä¹‰çš„æ–°æ¦‚å¿µåç§°**ï¼Œä¸æå–å‰ç½®æ¡ä»¶ä¸­çš„å·²çŸ¥æ¦‚å¿µã€‚

**å…³é”®è¦æ±‚**ï¼š
- è¯†åˆ«å®šä¹‰ã€å®šç†ã€å‘½é¢˜ç­‰æ•°å­¦é™ˆè¿°
- **åªæå–å®šä¹‰æ ‡å¿—è¯ï¼ˆç§°ã€å«åšã€å®šä¹‰ä¸ºç­‰ï¼‰ä¹‹åçš„æ¦‚å¿µ**
- å¿½ç•¥å‰ç½®æ¡ä»¶ï¼ˆè®¾ã€å‡è®¾ã€è‹¥ã€ç»™å®šç­‰ï¼‰ä¸­çš„æ¦‚å¿µ
- è¾“å‡ºæ ¼å¼ï¼šä¸­æ–‡1; è‹±æ–‡1; ä¸­æ–‡2; è‹±æ–‡2; ...
- æ— éœ€æ·»åŠ  "æˆ‘çœ‹åˆ°..." ç­‰æè¿°æ€§å‰ç¼€

## âš ï¸ é‡è¦åŸåˆ™ï¼šåŒºåˆ†è¢«å®šä¹‰æ¦‚å¿µä¸å‰ç½®æ¦‚å¿µ

### å…³é”®æ ‡å¿—è¯å®šä½æ³•
**ç¬¬ä¸€æ­¥ï¼šæ‰¾åˆ°å®šä¹‰æ ‡å¿—è¯**
- âœ… å®šä¹‰æ ‡å¿—è¯ï¼š**ç§°**ã€**å«åš**ã€**å®šä¹‰ä¸º**ã€**è®°ä½œ**
  - **ç‰¹æ®Šè¯´æ˜**ï¼š"**æ˜¯**"ã€"**ä¸º**" ä»…åœ¨ç‰¹å®šç»“æ„ä¸­ä½œä¸ºå®šä¹‰æ ‡å¿—è¯ï¼š
    - âœ… "åˆ™ç§°...æ˜¯..."ã€"å«åš...æ˜¯..."ã€"å®šä¹‰...ä¸º..." â†’ æå–
    - âŒ "è®¾ X æ˜¯åº¦é‡ç©ºé—´"ã€"f ä¸ºæ˜ å°„"ï¼ˆå‰ç½®æ¡ä»¶ä¸­çš„ç³»è¯ï¼‰ â†’ ä¸æå–
- âŒ å‰ç½®æ ‡å¿—è¯ï¼š**è®¾**ã€**å‡è®¾**ã€**è‹¥**ã€**ç»™å®š**ã€**ä»¤**ã€**å·²çŸ¥**

**ç¬¬äºŒæ­¥ï¼šåªæå–æ ‡å¿—è¯ä¹‹åçš„å†…å®¹**
- å®šä¹‰æ ‡å¿—è¯**ä¹‹å‰**çš„æ¦‚å¿µ â†’ âŒ ä¸æå–ï¼ˆè¿™äº›æ˜¯å‰ç½®/èƒŒæ™¯æ¦‚å¿µï¼‰
- å®šä¹‰æ ‡å¿—è¯**ä¹‹å**çš„æ¦‚å¿µ â†’ âœ… æå–ï¼ˆè¿™æ‰æ˜¯è¢«å®šä¹‰çš„æ–°æ¦‚å¿µï¼‰

**âš ï¸ ç‰¹åˆ«æ³¨æ„ï¼š"è‹¥...åˆ™ç§°..."å¥å¼**
- åœ¨ **"è‹¥...åˆ™ç§°..."** ç»“æ„ä¸­ï¼Œæ•´ä¸ª"è‹¥...åˆ™"æ˜¯ä¸€ä¸ªæ¡ä»¶å®šä¹‰å¥å¼
- **"è‹¥"åˆ°"åˆ™"ä¹‹é—´**çš„æ‰€æœ‰å†…å®¹éƒ½æ˜¯å‰ç½®æ¡ä»¶ â†’ âŒ ä¸æå–
- **"åˆ™ç§°/åˆ™å«åš/åˆ™æ˜¯"ä¹‹å**çš„å†…å®¹æ‰æ˜¯è¢«å®šä¹‰æ¦‚å¿µ â†’ âœ… æå–
- ç¤ºä¾‹ï¼š"è‹¥ [æ¡ä»¶], åˆ™ç§° [æ¦‚å¿µ]" â†’ åªæå– [æ¦‚å¿µ]

**ç¬¬ä¸‰æ­¥ï¼šç†è§£å¥å­ç»“æ„ï¼ŒåŒºåˆ†æ¡ä»¶å’Œç»“è®º**
- âœ… ç†è§£å¥å­çš„é€»è¾‘ç»“æ„ï¼šå‰ç½®èƒŒæ™¯ â†’ æ¡ä»¶ â†’ å®šä¹‰
- âŒ ä¸è¦ç®€å•åœ°æå–æ‰€æœ‰å‡ºç°çš„æ•°å­¦æœ¯è¯­
- âœ… åªæå–"ç»“è®ºéƒ¨åˆ†"ï¼ˆå®šä¹‰æ ‡å¿—è¯ä¹‹åï¼‰çš„æ¦‚å¿µ
- âŒ å¿½ç•¥"å‰ç½®éƒ¨åˆ†"å’Œ"æ¡ä»¶éƒ¨åˆ†"çš„æ‰€æœ‰æ¦‚å¿µ

### æ­£åå¯¹æ¯”ç¤ºä¾‹

**ç¤ºä¾‹ 1ï¼šä¸€è‡´è¿ç»­ï¼ˆç”¨æˆ·å®é™…æ¡ˆä¾‹ï¼‰**
è¾“å…¥ï¼šå®šä¹‰ è®¾ X å’Œ Y æ˜¯åº¦é‡ç©ºé—´, f æ˜¯ X åˆ° Y ä¸­çš„æ˜ å°„, å¦‚æœå¯¹äºä»»ä¸€æ­£æ•° Îµ, å­˜åœ¨æ­£æ•° Î´, å½“ d(x,x') < Î´ æ—¶, æœ‰ d(f(x),f(x')) < Îµ, å°±ç§° f åœ¨ X ä¸Šæ˜¯ä¸€è‡´è¿ç»­çš„.

åˆ†æï¼š
- "è®¾ X å’Œ Y æ˜¯åº¦é‡ç©ºé—´" â†’ âŒ å‰ç½®æ¡ä»¶ï¼ˆ"è®¾"å…³é”®è¯ï¼‰
- "f æ˜¯ X åˆ° Y ä¸­çš„æ˜ å°„" â†’ âŒ å‰ç½®æ¡ä»¶
- "å°±ç§° f åœ¨ X ä¸Šæ˜¯ä¸€è‡´è¿ç»­çš„" â†’ âœ… å®šä¹‰æ ‡å¿—è¯"ç§°"ä¹‹åçš„å†…å®¹

âœ… æ­£ç¡®è¾“å‡ºï¼šä¸€è‡´è¿ç»­; uniformly continuous
âŒ é”™è¯¯è¾“å‡ºï¼šåº¦é‡ç©ºé—´; metric space; æ˜ å°„; mapping; ä¸€è‡´è¿ç»­; uniformly continuous

**ç¤ºä¾‹ 2ï¼šCauchy åˆ—**
è¾“å…¥ï¼šè®¾ X æ˜¯åº¦é‡ç©ºé—´, æˆ‘ä»¬ç§° X ä¸­çš„æ•°åˆ— {xâ‚™} æ˜¯ Cauchy åˆ—, å¦‚æœå¯¹äºä»»æ„ Îµ>0...

åˆ†æï¼š
- "è®¾ X æ˜¯åº¦é‡ç©ºé—´" â†’ âŒ å‰ç½®æ¡ä»¶ï¼ˆ"è®¾"å…³é”®è¯ï¼‰
- "æˆ‘ä»¬ç§° X ä¸­çš„æ•°åˆ— {xâ‚™} æ˜¯ Cauchy åˆ—" â†’ âœ… å®šä¹‰æ ‡å¿—è¯"ç§°"ä¹‹å

âœ… æ­£ç¡®è¾“å‡ºï¼šCauchy åˆ—; Cauchy sequence
âŒ é”™è¯¯è¾“å‡ºï¼šåº¦é‡ç©ºé—´; metric space; Cauchy åˆ—; Cauchy sequence

**ç¤ºä¾‹ 3ï¼šç´§ç®—å­**

è¾“å…¥ï¼šå‡è®¾ X å’Œ Y æ˜¯ Banach ç©ºé—´, è‹¥ç®—å­ T: Xâ†’Y å°†æœ‰ç•Œé›†æ˜ ä¸ºç›¸å¯¹ç´§é›†, åˆ™ç§° T ä¸ºç´§ç®—å­.

åˆ†æï¼š
- "å‡è®¾ X å’Œ Y æ˜¯ Banach ç©ºé—´" â†’ âŒ å‰ç½®æ¡ä»¶ï¼ˆ"å‡è®¾"å…³é”®è¯ï¼‰
- "åˆ™ç§° T ä¸ºç´§ç®—å­" â†’ âœ… å®šä¹‰æ ‡å¿—è¯"ç§°"ä¹‹å

âœ… æ­£ç¡®è¾“å‡ºï¼šç´§ç®—å­; compact operator
âŒ é”™è¯¯è¾“å‡ºï¼šBanach ç©ºé—´; Banach space; ç´§ç®—å­; compact operator

**ç¤ºä¾‹ 4ï¼šåŒåˆ†å¸ƒï¼ˆç”¨æˆ·å®é™…æ¡ˆä¾‹ - "è‹¥...åˆ™ç§°..."å¥å¼ï¼‰**

è¾“å…¥ï¼šè®¾ (Î¾â‚,â‹¯,Î¾â‚™), (Î·â‚,â‹¯,Î·â‚™) æ˜¯æ¦‚ç‡ç©ºé—´ (Î©,ğ’œ,â„™) ä¸Šçš„ä¸¤ä¸ªéšæœºå‘é‡, è‹¥å®ƒä»¬å…·æœ‰ç›¸åŒçš„åˆ†å¸ƒå‡½æ•°, åˆ™ç§°å®ƒä»¬æ˜¯åŒåˆ†å¸ƒçš„.

åˆ†æï¼š
- "è®¾ (Î¾â‚,â‹¯,Î¾â‚™), (Î·â‚,â‹¯,Î·â‚™) æ˜¯æ¦‚ç‡ç©ºé—´ä¸Šçš„ä¸¤ä¸ªéšæœºå‘é‡" â†’ âŒ å‰ç½®æ¡ä»¶ï¼ˆ"è®¾"å…³é”®è¯ï¼‰
- "è‹¥å®ƒä»¬å…·æœ‰ç›¸åŒçš„åˆ†å¸ƒå‡½æ•°" â†’ âŒ å‰ç½®æ¡ä»¶ï¼ˆ"è‹¥...åˆ™"ç»“æ„çš„æ¡ä»¶éƒ¨åˆ†ï¼‰
- "åˆ™ç§°å®ƒä»¬æ˜¯åŒåˆ†å¸ƒçš„" â†’ âœ… å®šä¹‰æ ‡å¿—è¯"åˆ™ç§°"ä¹‹åçš„å†…å®¹

âœ… æ­£ç¡®è¾“å‡ºï¼šåŒåˆ†å¸ƒ; identically distributed
âŒ é”™è¯¯è¾“å‡ºï¼šæ¦‚ç‡ç©ºé—´; probability space; éšæœºå‘é‡; random vector; åˆ†å¸ƒå‡½æ•°; distribution function; åŒåˆ†å¸ƒ; identically distributed

**âš ï¸ å…³é”®ç‚¹**ï¼šåœ¨"è‹¥...åˆ™ç§°..."å¥å¼ä¸­ï¼Œ"è‹¥"åˆ°"åˆ™"ä¹‹é—´çš„**æ‰€æœ‰å†…å®¹**ï¼ˆåŒ…æ‹¬"æ¦‚ç‡ç©ºé—´"ã€"éšæœºå‘é‡"ã€"åˆ†å¸ƒå‡½æ•°"ï¼‰éƒ½æ˜¯å‰ç½®æ¡ä»¶ï¼Œå¿…é¡»å…¨éƒ¨å¿½ç•¥ï¼

**ç¤ºä¾‹ 5ï¼šåµŒå¥—å®šä¹‰ï¼ˆä¸€å¥è¯å®šä¹‰å¤šä¸ªæ¦‚å¿µï¼‰**

è¾“å…¥ï¼šç§°ç®—å­ T ä¸ºçº¿æ€§ç®—å­æˆ–çº¿æ€§æ˜ å°„ï¼Œå¦‚æœå¯¹ä»»æ„ Î±, Î² âˆˆ â„‚ å’Œ x, y âˆˆ Xï¼Œæœ‰ T(Î±x+Î²y) = Î±Tx + Î²Ty.

åˆ†æï¼š
- "ç§°ç®—å­ T ä¸ºçº¿æ€§ç®—å­æˆ–çº¿æ€§æ˜ å°„" â†’ âœ… å®šä¹‰æ ‡å¿—è¯"ç§°...ä¸º"ä¹‹åï¼ŒåŒ…å«ä¸¤ä¸ªç­‰ä»·åç§°
- æå–æ‰€æœ‰ç­‰ä»·åç§°

âœ… æ­£ç¡®è¾“å‡ºï¼šçº¿æ€§ç®—å­; linear operator; çº¿æ€§æ˜ å°„; linear mapping
âŒ é”™è¯¯è¾“å‡ºï¼šçº¿æ€§ç®—å­; linear operatorï¼ˆé—æ¼äº†åˆ«åï¼‰

**ç¤ºä¾‹ 6ï¼šè¯æ˜è¿‡ç¨‹ï¼ˆæ— è¢«å®šä¹‰æ¦‚å¿µï¼‰**

è¾“å…¥ï¼šè¯æ˜ï¼šç”± f çš„è¿ç»­æ€§ï¼Œå¯¹äº Îµ>0ï¼Œå­˜åœ¨ Î´>0 ä½¿å¾—å½“ |x-xâ‚€|<Î´ æ—¶ï¼Œ|f(x)-f(xâ‚€)|<Îµ. å› æ­¤ç»“è®ºæˆç«‹.

åˆ†æï¼š
- è¿™æ˜¯è¯æ˜è¿‡ç¨‹ï¼Œæ²¡æœ‰å®šä¹‰æ ‡å¿—è¯
- åªæ˜¯åœ¨ä½¿ç”¨å·²çŸ¥æ¦‚å¿µï¼ˆè¿ç»­æ€§ï¼‰è¿›è¡Œæ¨ç†

âœ… æ­£ç¡®è¾“å‡ºï¼šæ— 
âŒ é”™è¯¯è¾“å‡ºï¼šè¿ç»­æ€§; continuityï¼ˆè¿™ä¸æ˜¯è¢«å®šä¹‰çš„æ¦‚å¿µï¼‰

## è¾“å‡ºæ ¼å¼

æ ‡å‡†æ ¼å¼ï¼ˆåˆ†å·åˆ†éš”ï¼Œä¸­è‹±æ–‡äº¤æ›¿ï¼‰ï¼š
æ¦‚å¿µä¸­æ–‡å; æ¦‚å¿µè‹±æ–‡å; åˆ«åä¸­æ–‡; åˆ«åè‹±æ–‡; ...

**å•ä¸ªæ¦‚å¿µç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šæˆ‘ä»¬ç§°å‡½æ•° f æ˜¯è¿ç»­çš„ï¼Œå¦‚æœ...
- è¾“å‡ºï¼šè¿ç»­å‡½æ•°; continuous function

**å¤šä¸ªæ¦‚å¿µç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šç§°ç®—å­ T ä¸ºçº¿æ€§ç®—å­æˆ–çº¿æ€§æ˜ å°„ï¼Œå¦‚æœ...
- è¾“å‡ºï¼šçº¿æ€§ç®—å­; linear operator; çº¿æ€§æ˜ å°„; linear mapping

## è¯†åˆ«æ¨¡å¼

### æ¨¡å¼ 1ï¼šå®šä¹‰å¥å¼ï¼ˆé‡ç‚¹å…³æ³¨æ ‡å¿—è¯ï¼‰
**æ ¸å¿ƒç­–ç•¥**ï¼šå®šä½å®šä¹‰æ ‡å¿—è¯ï¼Œåªæå–å…¶åå†…å®¹

å¸¸è§çš„å®šä¹‰å¥å¼æ¨¡æ¿ï¼š
- "æˆ‘ä»¬**ç§°** [æ¦‚å¿µ] ä¸º [åç§°], å¦‚æœ..." â†’ æå– [åç§°]
- "**å®šä¹‰** [åç§°] ä¸ºæ»¡è¶³...çš„ [æ¦‚å¿µ]" â†’ æå– [åç§°]
- "å°±**ç§°** [æ¦‚å¿µ] **æ˜¯** [åç§°]" â†’ æå– [åç§°]
- "[æ¦‚å¿µ] **å«åš** [åç§°]" â†’ æå– [åç§°]

**âš ï¸ æ¡ä»¶å®šä¹‰å¥å¼ï¼ˆé‡ç‚¹ï¼‰**ï¼š
- **"è‹¥ [æ¡ä»¶], åˆ™ç§° [æ¦‚å¿µ] ä¸º [åç§°]"** â†’ åªæå– [åç§°]
  - "è‹¥"åˆ°"åˆ™"ä¹‹é—´çš„å…¨éƒ¨å†…å®¹éƒ½æ˜¯å‰ç½®æ¡ä»¶ï¼Œå¿…é¡»å¿½ç•¥
  - åªæœ‰"åˆ™ç§°/åˆ™å«åš/åˆ™æ˜¯"ä¹‹åçš„å†…å®¹æ‰æå–
- **"è®¾ [å‰ç½®], è‹¥ [æ¡ä»¶], åˆ™ç§° [åç§°]"** â†’ åªæå– [åç§°]
  - "è®¾"ä¹‹åå’Œ"è‹¥"åˆ°"åˆ™"ä¹‹é—´çš„æ‰€æœ‰æ¦‚å¿µéƒ½æ˜¯èƒŒæ™¯/æ¡ä»¶ï¼Œä¸æå–

**ç¤ºä¾‹**ï¼š
- "æˆ‘ä»¬ç§°å®æ•°åˆ— {xâ‚™} æ˜¯ Cauchy åˆ—, å¦‚æœ..." â†’ Cauchy åˆ—; Cauchy sequence
- "è‹¥å‡½æ•° f åœ¨ç‚¹ a çš„æŸé‚»åŸŸå†…å¯å¾®, åˆ™ç§° f åœ¨ a å¤„å¯å¾®" â†’ å¯å¾®å‡½æ•°; differentiable function
- "è®¾ X æ˜¯åº¦é‡ç©ºé—´, è‹¥æ˜ å°„ f æ»¡è¶³..., åˆ™ç§° f æ˜¯ä¸€è‡´è¿ç»­çš„" â†’ ä¸€è‡´è¿ç»­; uniformly continuous

### æ¨¡å¼ 2ï¼šå®šç†/å‘½é¢˜å¥å¼
å®šç†é€šå¸¸æœ‰ä¸“æœ‰åç§°ï¼š
- "[å®šç†åç§°]: è‹¥ [æ¡ä»¶], åˆ™ [ç»“è®º]"
- "å®šç† ([å®šç†å]): ..."
- "[ç»“è®º], è¿™å°±æ˜¯ [å®šç†å]"

**ç¤ºä¾‹**ï¼š
- "å¼ºå¤§æ•°å®šå¾‹: è‹¥éšæœºå˜é‡åºåˆ—..." â†’ å¼ºå¤§æ•°å®šå¾‹; strong law of large numbers
- "ä¸€è‡´æœ‰ç•ŒåŸç†: è‹¥ç®—å­æ—..." â†’ ä¸€è‡´æœ‰ç•ŒåŸç†; uniform boundedness principle
- "é—­å›¾åƒå®šç† (Closed Graph Theorem): ..." â†’ é—­å›¾åƒå®šç†; closed graph theorem

### æ¨¡å¼ 3ï¼šç­‰ä»·å®šä¹‰
å¤šä¸ªç­‰ä»·åç§°ï¼š
- "[åç§°1] æˆ–ç§° [åç§°2], æ˜¯æŒ‡..."
- "[åç§°1] (ä¹Ÿå« [åç§°2]), å®šä¹‰ä¸º..."

**ç¤ºä¾‹**ï¼š
- "Borel é›†æˆ–ç§° Borel å¯æµ‹é›†, æ˜¯æŒ‡..." â†’ Borel é›†; Borel set; Borel å¯æµ‹é›†; Borel measurable set

## æå–è§„åˆ™

### 1. æ¦‚å¿µè¯†åˆ«
- âœ… æå–è¢«å®šä¹‰çš„æ ¸å¿ƒæ•°å­¦æ¦‚å¿µï¼ˆå‡½æ•°ã€ç©ºé—´ã€ç®—å­ã€å®šç†ç­‰ï¼‰
- âœ… åŒ…å«æ‰€æœ‰ç­‰ä»·åç§°å’Œåˆ«å
- âŒ ä¸æå–ä¾‹å­ç¼–å·ï¼ˆå¦‚ "ä¾‹ 2.1"ï¼‰
- âŒ ä¸æå–ç« èŠ‚æ ‡å·ï¼ˆå¦‚ "å®šç† 3.5"ï¼‰

### 2. ä¸­è‹±æ–‡é…å¯¹
- ä¼˜å…ˆä½¿ç”¨å›¾ç‰‡ä¸­å·²æœ‰çš„ç¿»è¯‘
- è‹¥ä»…æœ‰ä¸­æ–‡ï¼Œè¡¥å……æ ‡å‡†è‹±æ–‡æœ¯è¯­
- è‹¥ä»…æœ‰è‹±æ–‡ï¼Œè¡¥å……æ ‡å‡†ä¸­æ–‡ç¿»è¯‘
- ä½¿ç”¨æ ‡å‡†æ•°å­¦è¯å…¸æœ¯è¯­ï¼ˆé«˜æ•™å‡ºç‰ˆç¤¾ï¼‰

### 3. å¤šæ¦‚å¿µå¤„ç†
- æŒ‰ç…§é‡è¦æ€§æ’åºï¼ˆæ ¸å¿ƒæ¦‚å¿µåœ¨å‰ï¼‰
- åŒä¸€æ¦‚å¿µçš„ä¸åŒåç§°æ”¾åœ¨ä¸€èµ·
- ä½¿ç”¨åˆ†å·åˆ†éš”ä¸åŒåç§°

**ç¤ºä¾‹**ï¼š
- "è¿ç»­å‡½æ•°; continuous function; è¿ç»­æ˜ å°„; continuous map"
- "Hilbert ç©ºé—´; Hilbert space; å®Œå¤‡å†…ç§¯ç©ºé—´; complete inner product space"

## å¸¸ç”¨æ•°å­¦æœ¯è¯­å¯¹ç…§

### åŸºæœ¬æ¦‚å¿µ
- å‡½æ•° function | æ˜ å°„ mapping | ç®—å­ operator
- é›†åˆ set | ç©ºé—´ space | åŸŸ field
- åºåˆ— sequence | çº§æ•° series | æé™ limit

### æ€§è´¨
- è¿ç»­ continuous | å¯å¾® differentiable | å¯ç§¯ integrable
- æ”¶æ•› convergent | æœ‰ç•Œ bounded | ç´§ compact
- çº¿æ€§ linear | å•è°ƒ monotone | å‡¸ convex

### ç†è®º
- å®šç† theorem | å¼•ç† lemma | æ¨è®º corollary
- å‘½é¢˜ proposition | åŸç† principle | æ³•åˆ™ law

## æ³¨æ„äº‹é¡¹
1. ä»…è¾“å‡ºæ¦‚å¿µåç§°ï¼Œä¸è¾“å‡ºå®šä¹‰å†…å®¹
2. æ ‡ç‚¹ç¬¦å·å¤„ç†ï¼š
   - æ¦‚å¿µåç§°**ä¹‹é—´**ç”¨åˆ†å·åˆ†éš”
   - æ¦‚å¿µåç§°**å†…éƒ¨**çš„ç©ºæ ¼ã€è¿å­—ç¬¦ä¿ç•™ï¼ˆå¦‚"Cauchy åˆ—"ã€"ä¸€è‡´è¿ç»­"ï¼‰
   - å»æ‰æ¦‚å¿µåç§°**å‰å**çš„æ ‡ç‚¹ç¬¦å·ï¼ˆå¦‚å¥å·ã€é€—å·ï¼‰
3. ä¸­æ–‡å’Œè‹±æ–‡åç§°å¿…é¡»ä¸€ä¸€å¯¹åº”
4. è‹¥æœ‰å¤šä¸ªç­‰ä»·åç§°ï¼Œå…¨éƒ¨åˆ—å‡º
5. ä¿æŒæœ¯è¯­çš„æ ‡å‡†æ€§å’Œä¸“ä¸šæ€§
6. **ç‰¹æ®Šæƒ…å†µ**ï¼šè‹¥å›¾ç‰‡ä¸­æ²¡æœ‰å®šä¹‰/å®šç†ï¼Œåªæ˜¯è¯æ˜è¿‡ç¨‹ã€ä¾‹å­æˆ–å…¶ä»–å†…å®¹ï¼Œè¾“å‡º"æ— "

${this.OCRNumberingRules}
`

  static get OCRDirectlyNoTransPrompt() {
    return `
# æ•°å­¦æ–‡æœ¬ OCR æç¤ºè¯ï¼ˆå®Œæ•´ç¿»è¯‘ç‰ˆæœ¬ï¼‰

## âš ï¸ é‡è¦è¯´æ˜ï¼šæœ¬æç¤ºè¯çš„ä»»åŠ¡èŒƒå›´

**æœ¬æç¤ºè¯çš„ä»»åŠ¡**ï¼šå®Œæ•´ç¿»è¯‘ OCR å›¾ç‰‡ä¸­çš„æ‰€æœ‰æ–‡æœ¬å†…å®¹
- âœ… ç¿»è¯‘æ‰€æœ‰æ–‡æœ¬ï¼ˆåŒ…æ‹¬å‰ç½®æ¡ä»¶ã€å®šä¹‰ã€å®šç†ã€è¯æ˜ç­‰ï¼‰
- âœ… ä¿ç•™å®Œæ•´çš„å¥å­ç»“æ„å’Œé€»è¾‘å…³ç³»
- âœ… è¾“å‡ºå®Œæ•´çš„å®šä¹‰å¥ï¼ˆåŒ…æ‹¬"è®¾...""è‹¥..."ç­‰å‰ç½®éƒ¨åˆ†ï¼‰


## æ ¸å¿ƒä»»åŠ¡
ä»å›¾ç‰‡ä¸­æå–æ–‡æœ¬ï¼Œä¼˜å…ˆä½¿ç”¨ Unicode å­—ç¬¦è¾“å‡ºï¼Œå®Œæ•´ç¿»è¯‘ä¸ºä¸­æ–‡ã€‚

**å…³é”®è¦æ±‚**ï¼š
- å·²æ˜¯ä¸­æ–‡çš„å†…å®¹ä¿æŒåŸæ ·
- è‹±æ–‡/å…¶ä»–è¯­è¨€å†…å®¹ç¿»è¯‘æˆä¸­æ–‡
- **ä¿ç•™å®Œæ•´å¥å­**ï¼ˆåŒ…æ‹¬å‰ç½®æ¡ä»¶"è®¾"ã€"å‡è®¾"ã€"è‹¥"ç­‰ï¼‰
- ç¦æ­¢ä½¿ç”¨ LaTeX åŒ…è£¹ç¬¦å·ï¼ˆ$...$ï¼‰ï¼Œä¼˜å…ˆ Unicode
- æ— éœ€æ·»åŠ  "æˆ‘çœ‹åˆ°..." ç­‰æè¿°æ€§å‰ç¼€

## è¾“å‡ºæ ¼å¼è¦æ±‚

**é‡è¦**ï¼šç›´æ¥è¾“å‡ºå®Œæ•´çš„ä¸­æ–‡å†…å®¹ï¼Œä¸è¦æ·»åŠ ä»»ä½•æ ¼å¼æ ‡è®°æˆ–å‰ç¼€ï¼ä¹Ÿä¸éœ€è¦é¦–å°¾çš„æ ‡ç‚¹ç¬¦å·ï¼

### ç»Ÿä¸€è¾“å‡ºæ ¼å¼
è¾“å‡ºæ ¼å¼ï¼š<ä¸­æ–‡å†…å®¹>

**æ­£ç¡®ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šLet f be a continuous function on [a,b]
- âœ… è¾“å‡ºï¼šè®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°

- è¾“å…¥ï¼šè®¾ f æ˜¯è¿ç»­å‡½æ•°
- âœ… è¾“å‡ºï¼šè®¾ f æ˜¯è¿ç»­å‡½æ•°

**é”™è¯¯ç¤ºä¾‹**ï¼ˆç¦æ­¢ï¼‰ï¼š
- âŒ ä¸­æ–‡ç¿»è¯‘: è®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°
- âŒ [ä¸­æ–‡]: è®¾ f æ˜¯è¿ç»­å‡½æ•°
- âŒ ç¿»è¯‘ç»“æœ: è®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°
- âŒ å†…å®¹: è®¾ f æ˜¯è¿ç»­å‡½æ•°


## å¤„ç†è§„åˆ™

### 1. ç©ºæ ¼å¤„ç†

${this.OCRSpaceHandlingRules}

### 2. ç¿»è¯‘è§„åˆ™

**æ ¸å¿ƒåŸåˆ™**ï¼š
- âœ… ä½¿ç”¨æ ‡å‡†æ•°å­¦æ•™ææœ¯è¯­ï¼ˆå¦‚é«˜ç­‰æ•™è‚²å‡ºç‰ˆç¤¾æ•°å­¦è¯æ±‡ï¼‰
- âœ… å…¬å¼ä¿æŒåŸæ ·ï¼Œä»…ç¿»è¯‘æè¿°æ€§æ–‡å­—
- âœ… æ ¹æ®æ•°å­¦åˆ†æ”¯ï¼ˆåˆ†æ/ä»£æ•°/å‡ ä½•ç­‰ï¼‰é€‰æ‹©æ°å½“æœ¯è¯­
- âŒ å»æ‰æ•°å­¦é™ˆè¿°çš„ç¼–å·æ ‡è®°ï¼ˆå®Œå…¨åˆ é™¤ï¼Œä¸ä¿ç•™ï¼‰
- âŒ å»æ‰æœ«å°¾æ ‡ç‚¹

${this.OCRNameHandlingRules}

${this.OCRTerminologyMapping}

${this.OCRCorrectionRules}

${this.OCRNumberingRules}

## æœ€ç»ˆæ£€æŸ¥æ¸…å•
1. æ‰€æœ‰ä¸‹æ ‡ã€ä¸Šæ ‡æ˜¯å¦ä½¿ç”¨äº†æ­£ç¡®çš„ Unicode å­—ç¬¦
2. æ•°å­¦ç¬¦å·æ˜¯å¦å‡†ç¡®ï¼ˆç‰¹åˆ«æ³¨æ„ä¹˜å·ã€å±äºç¬¦å·ç­‰ï¼‰
3. å¸Œè…Šå­—æ¯æ˜¯å¦æ­£ç¡®è¯†åˆ«
4. æ•°å­—å’Œå­—æ¯æ˜¯å¦æ··æ·†ï¼ˆ0/O, 1/l/I ç­‰ï¼‰
5. ç©ºæ ¼æ˜¯å¦ç¬¦åˆæ•°å­¦æ’ç‰ˆè§„èŒƒ
`
  }

  static OCRToMarkdownNoTransPrompt = `
# æ•°å­¦æ–‡æœ¬ OCR - Markdown LaTeX æ ¼å¼ï¼ˆä»…ä¸­æ–‡ç‰ˆæœ¬ï¼‰

## æ ¸å¿ƒä»»åŠ¡
ä»å›¾ç‰‡ä¸­æå–æ•°å­¦å†…å®¹ï¼Œå¹¶ä»¥ Markdown + LaTeX æ ¼å¼è¾“å‡ºï¼Œæ‰€æœ‰æ–‡æœ¬ç¿»è¯‘ä¸ºä¸­æ–‡ã€‚

**å…³é”®è¦æ±‚**ï¼š
- æ‰€æœ‰æ•°å­¦å…¬å¼ä½¿ç”¨ LaTeX è¯­æ³•ï¼Œå¹¶ç”¨ $ æˆ– $$ åŒ…è£¹
- è¡Œå†…å…¬å¼ä½¿ç”¨ $...$
- ç‹¬ç«‹å…¬å¼ä½¿ç”¨ $$...$$ï¼ˆå•ç‹¬æˆè¡Œï¼‰
- æ‰€æœ‰æ–‡æœ¬ç¿»è¯‘ä¸ºä¸­æ–‡ï¼ˆè‹±æ–‡æœ¯è¯­ç¿»è¯‘æˆæ ‡å‡†ä¸­æ–‡ï¼‰
- å·²æ˜¯ä¸­æ–‡çš„ä¿æŒåŸæ ·
- æ— éœ€æ·»åŠ  "æˆ‘çœ‹åˆ°..." ç­‰æè¿°æ€§å‰ç¼€

## è¾“å‡ºæ ¼å¼è¦æ±‚

**é‡è¦**ï¼šç›´æ¥è¾“å‡º Markdown å†…å®¹ï¼Œä¸è¦æ·»åŠ ä»»ä½•æ ¼å¼æ ‡è®°ã€ä»£ç å—åŒ…è£¹æˆ–å‰ç¼€ï¼

**æ­£ç¡®ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šf(x) = xÂ²+2x+1
- âœ… è¾“å‡ºï¼š$f(x) = x^2+2x+1$

- è¾“å…¥ï¼šLet f be a continuous function on [a,b]
- âœ… è¾“å‡ºï¼šè®¾ $f$ æ˜¯ $[a,b]$ ä¸Šçš„è¿ç»­å‡½æ•°

- è¾“å…¥ï¼šè®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°
- âœ… è¾“å‡ºï¼šè®¾ $f$ æ˜¯ $[a,b]$ ä¸Šçš„è¿ç»­å‡½æ•°

**é”™è¯¯ç¤ºä¾‹**ï¼ˆç¦æ­¢ï¼‰ï¼š
- âŒ \`\`\`markdown
      $f(x) = x^2+2x+1$
      \`\`\`
- âŒ è¾“å‡º: $f(x) = x^2+2x+1$
- âŒ ç»“æœ: è®¾ $f$ æ˜¯ $[a,b]$ ä¸Šçš„è¿ç»­å‡½æ•°
- âŒ Markdown æ ¼å¼: ...

## è¾“å‡ºæ ¼å¼è¯¦è§£

### æ ¼å¼ 1ï¼šçº¯å…¬å¼
å¯¹äºçº¯æ•°å­¦å…¬å¼çš„å›¾ç‰‡ï¼Œç›´æ¥è¾“å‡º LaTeXï¼š
$$å…¬å¼å†…å®¹$$

**ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šf(x) = xÂ²+2x+1
- âœ… è¾“å‡ºï¼š$f(x) = x^2+2x+1$

### æ ¼å¼ 2ï¼šæ··åˆå†…å®¹
å¯¹äºåŒ…å«æ–‡å­—æè¿°çš„å†…å®¹ï¼Œæ··åˆä½¿ç”¨æ–‡æœ¬å’Œå…¬å¼ï¼š

**ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šè®¾ f æ˜¯ [a,b] ä¸Šçš„è¿ç»­å‡½æ•°
- âœ… è¾“å‡ºï¼šè®¾ $f$ æ˜¯ $[a,b]$ ä¸Šçš„è¿ç»­å‡½æ•°

- è¾“å…¥ï¼šThe function f: Râ†’R is continuous
- âœ… è¾“å‡ºï¼šå‡½æ•° $f: \\mathbb{R} \\to \\mathbb{R}$ æ˜¯è¿ç»­çš„

## LaTeX è¯­æ³•è§„åˆ™

### 1. åŸºæœ¬ç¬¦å·
- ä¸Šæ ‡ï¼šx^2, x^{n+1}
- ä¸‹æ ‡ï¼šx_1, x_{i,j}
- åˆ†æ•°ï¼š\\frac{a}{b}
- æ ¹å¼ï¼š\\sqrt{2}, \\sqrt[3]{8}
- å¸Œè…Šå­—æ¯ï¼š\\alpha, \\beta, \\gamma, \\delta, \\epsilon, \\theta, \\lambda, \\pi, \\sigma

### 2. è¿ç®—ç¬¦
- \\pm (Â±), \\times (Ã—), \\div (Ã·), \\cdot (Â·)
- \\leq (â‰¤), \\geq (â‰¥), \\neq (â‰ ), \\approx (â‰ˆ)
- \\in (âˆˆ), \\notin (âˆ‰), \\subset (âŠ‚), \\subseteq (âŠ†)
- \\cup (âˆª), \\cap (âˆ©), \\emptyset (âˆ…)

### 3. å¾®ç§¯åˆ†
- æé™ï¼š\\lim_{x \\to a}, \\lim_{n \\to \\infty}
- æ±‚å’Œï¼š\\sum_{i=1}^{n}, \\sum_{k=0}^{\\infty}
- ç§¯åˆ†ï¼š\\int_{a}^{b}, \\iint, \\iiint, \\oint
- åå¯¼ï¼š\\frac{\\partial f}{\\partial x}, \\nabla
- å¯¼æ•°ï¼šf'(x), f''(x), \\dot{x}, \\ddot{x}

### 4. æ‹¬å·
- å°æ‹¬å·ï¼š(x), è‡ªåŠ¨è°ƒæ•´ï¼š\\left( ... \\right)
- ä¸­æ‹¬å·ï¼š[a,b], è‡ªåŠ¨è°ƒæ•´ï¼š\\left[ ... \\right]
- å¤§æ‹¬å·ï¼š\\{ ... \\}, è‡ªåŠ¨è°ƒæ•´ï¼š\\left\\{ ... \\right\\}
- èŒƒæ•°ï¼š\\| x \\|, ç»å¯¹å€¼ï¼š\\| a \\|

### 5. å¸¸ç”¨æ•°å­¦é›†åˆ
- è‡ªç„¶æ•°ï¼š\\mathbb{N}
- æ•´æ•°ï¼š\\mathbb{Z}
- æœ‰ç†æ•°ï¼š\\mathbb{Q}
- å®æ•°ï¼š\\mathbb{R}
- å¤æ•°ï¼š\\mathbb{C}

### 6. å‡½æ•°å’Œæ˜ å°„
- æ˜ å°„ï¼šf: A \\to B
- å¤åˆï¼šf \\circ g
- åå‡½æ•°ï¼šf^{-1}

### 7. é€»è¾‘ç¬¦å·
- ä»»æ„ï¼š\\forall
- å­˜åœ¨ï¼š\\exists
- è•´å«ï¼š\\Rightarrow, \\Leftarrow, \\Leftrightarrow
- éï¼š\\neg
- ä¸”ï¼š\\wedge (âˆ§)
- æˆ–ï¼š\\vee (âˆ¨)

## ç©ºæ ¼å¤„ç†è§„åˆ™

**è§„åˆ™ Aï¼šLaTeX å†…ä¸éœ€è¦æ‰‹åŠ¨ç©ºæ ¼**
LaTeX ä¼šè‡ªåŠ¨å¤„ç†å…¬å¼å†…çš„é—´è·ï¼š
- âœ… $f(x)=x^2+2x+1$ï¼ˆæ— ç©ºæ ¼ï¼‰
- âŒ $f(x) = x^2 + 2x + 1$ï¼ˆä¸å¿…è¦çš„ç©ºæ ¼ï¼‰

**è§„åˆ™ Bï¼šæ–‡æœ¬éƒ¨åˆ†ä¿ç•™å¿…è¦ç©ºæ ¼**
- âœ… è®¾ $f$ æ˜¯è¿ç»­å‡½æ•°ï¼ˆä¸­æ–‡è¯é—´æœ‰ç©ºæ ¼ï¼‰
- âœ… è®¾ $f$ ä¸ºè¿ç»­å‡½æ•°ï¼ˆä¸­æ–‡è¯é—´æœ‰ç©ºæ ¼ï¼‰

## ç¿»è¯‘è§„åˆ™
- å·²æ˜¯ä¸­æ–‡çš„ä¿æŒåŸæ ·
- è‹±æ–‡æ•°å­¦æœ¯è¯­ç¿»è¯‘ä¸ºæ ‡å‡†ä¸­æ–‡ï¼ˆå‚è€ƒé«˜æ•™å‡ºç‰ˆç¤¾æ•°å­¦è¯å…¸ï¼‰
- å…¬å¼ç¬¦å·ä¿æŒåŸæ ·ï¼Œä»…ç¿»è¯‘æè¿°æ€§æ–‡å­—
- å»æ‰æ•°å­¦é™ˆè¿°çš„ç¼–å·æ ‡è®°ï¼ˆå®Œå…¨åˆ é™¤ï¼Œä¸ä¿ç•™ï¼‰
- å»æ‰æœ«å°¾æ ‡ç‚¹

${this.OCRNameHandlingRules}

**æ ‡è®°ç§»é™¤ç¤ºä¾‹**ï¼š
- Theorem 1.1 (Strong Law): If ... â†’ å¼ºå¤§æ•°å®šå¾‹ï¼šè‹¥ ...ï¼ˆç§»é™¤ "Theorem 1.1"ï¼‰
- Example 2.3: Let f be ... â†’ è®¾ $f$ ä¸º ...ï¼ˆç§»é™¤ "Example 2.3"ï¼‰
- Definition 2.5: A function f is continuous if ... â†’ è‹¥ ..., åˆ™å‡½æ•° $f$ æ˜¯è¿ç»­çš„ï¼ˆç§»é™¤ "Definition 2.5"ï¼‰
- æ¨è®º 1.12: è‹¥ f è¿ç»­ â†’ è‹¥ $f$ è¿ç»­ï¼ˆç§»é™¤ "æ¨è®º 1.12"ï¼‰
- ç»ƒä¹  1.2: è¯æ˜... â†’ è¯æ˜...ï¼ˆç§»é™¤ "ç»ƒä¹  1.2"ï¼‰

${this.OCRNumberingRules}
`

  static OCRExtractConceptNoTransPrompt = `
# æ•°å­¦æ¦‚å¿µ/å®šç†æå–ï¼ˆä»…ä¸­æ–‡ç‰ˆæœ¬ï¼‰

## æ ¸å¿ƒä»»åŠ¡
ä»å›¾ç‰‡ä¸­çš„æ•°å­¦å®šä¹‰æˆ–å®šç†ä¸­æå–å…³é”®æ¦‚å¿µåç§°ï¼Œä»…è¾“å‡ºä¸­æ–‡åç§°ã€‚

**å…³é”®è¦æ±‚**ï¼š
- è¯†åˆ«å®šä¹‰ã€å®šç†ã€å‘½é¢˜ç­‰æ•°å­¦é™ˆè¿°
- æå–æ ¸å¿ƒæ¦‚å¿µçš„ä¸­æ–‡åç§°
- è¾“å‡ºæ ¼å¼ï¼šæ¦‚å¿µ1; æ¦‚å¿µ2; æ¦‚å¿µ3; ...
- æ— éœ€æ·»åŠ  "æˆ‘çœ‹åˆ°..." ç­‰æè¿°æ€§å‰ç¼€

## è¾“å‡ºæ ¼å¼è¦æ±‚

**é‡è¦**ï¼šç›´æ¥è¾“å‡ºæ¦‚å¿µåç§°åˆ—è¡¨ï¼Œä¸è¦æ·»åŠ ä»»ä½•æ ¼å¼æ ‡è®°æˆ–å‰ç¼€ï¼

æ ‡å‡†æ ¼å¼ï¼ˆåˆ†å·åˆ†éš”ï¼Œä»…ä¸­æ–‡ï¼‰ï¼š
æ¦‚å¿µä¸­æ–‡å1; æ¦‚å¿µä¸­æ–‡å2; ...

**æ­£ç¡®ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šæˆ‘ä»¬ç§°å‡½æ•° f æ˜¯è¿ç»­çš„ï¼Œå¦‚æœ...
- âœ… è¾“å‡ºï¼šè¿ç»­å‡½æ•°

- è¾“å…¥ï¼šç§°ç®—å­ T ä¸ºçº¿æ€§ç®—å­æˆ–çº¿æ€§æ˜ å°„ï¼Œå¦‚æœ...
- âœ… è¾“å‡ºï¼šçº¿æ€§ç®—å­; çº¿æ€§æ˜ å°„

- è¾“å…¥ï¼šStrong Law of Large Numbers: If ...
- âœ… è¾“å‡ºï¼šå¼ºå¤§æ•°å®šå¾‹

**é”™è¯¯ç¤ºä¾‹**ï¼ˆç¦æ­¢ï¼‰ï¼š
- âŒ æ¦‚å¿µåç§°: è¿ç»­å‡½æ•°
- âŒ æå–ç»“æœ: çº¿æ€§ç®—å­; çº¿æ€§æ˜ å°„
- âŒ [ä¸­æ–‡æ¦‚å¿µ]: å¼ºå¤§æ•°å®šå¾‹
- âŒ è¯†åˆ«å‡ºçš„æ¦‚å¿µ: è¿ç»­å‡½æ•°

## è¯†åˆ«æ¨¡å¼

### æ¨¡å¼ 1ï¼šå®šä¹‰å¥å¼
å¸¸è§çš„å®šä¹‰å¥å¼æ¨¡æ¿ï¼š
- "æˆ‘ä»¬ç§° [æ¦‚å¿µ] ä¸º [åç§°], å¦‚æœ..."
- "å®šä¹‰ [åç§°] ä¸ºæ»¡è¶³...çš„ [æ¦‚å¿µ]"
- "è‹¥ [æ¡ä»¶], åˆ™ç§° [æ¦‚å¿µ] ä¸º [åç§°]"
- "[æ¦‚å¿µ] æ˜¯æ»¡è¶³...çš„ [å¯¹è±¡], è®°ä¸º [ç¬¦å·]"

**ç¤ºä¾‹**ï¼š
- "æˆ‘ä»¬ç§°å®æ•°åˆ— {xâ‚™} æ˜¯ Cauchy åˆ—, å¦‚æœ..." â†’ Cauchy åˆ—
- "è‹¥å‡½æ•° f åœ¨ç‚¹ a çš„æŸé‚»åŸŸå†…å¯å¾®, åˆ™ç§° f åœ¨ a å¤„å¯å¾®" â†’ å¯å¾®å‡½æ•°

### æ¨¡å¼ 2ï¼šå®šç†/å‘½é¢˜å¥å¼
å®šç†é€šå¸¸æœ‰ä¸“æœ‰åç§°ï¼š
- "[å®šç†åç§°]: è‹¥ [æ¡ä»¶], åˆ™ [ç»“è®º]"
- "å®šç† ([å®šç†å]): ..."
- "[ç»“è®º], è¿™å°±æ˜¯ [å®šç†å]"

**ç¤ºä¾‹**ï¼š
- "å¼ºå¤§æ•°å®šå¾‹: è‹¥éšæœºå˜é‡åºåˆ—..." â†’ å¼ºå¤§æ•°å®šå¾‹
- "ä¸€è‡´æœ‰ç•ŒåŸç†: è‹¥ç®—å­æ—..." â†’ ä¸€è‡´æœ‰ç•ŒåŸç†
- "é—­å›¾åƒå®šç† (Closed Graph Theorem): ..." â†’ é—­å›¾åƒå®šç†

### æ¨¡å¼ 3ï¼šç­‰ä»·å®šä¹‰
å¤šä¸ªç­‰ä»·åç§°ï¼š
- "[åç§°1] æˆ–ç§° [åç§°2], æ˜¯æŒ‡..."
- "[åç§°1] (ä¹Ÿå« [åç§°2]), å®šä¹‰ä¸º..."

**ç¤ºä¾‹**ï¼š
- "Borel é›†æˆ–ç§° Borel å¯æµ‹é›†, æ˜¯æŒ‡..." â†’ Borel é›†; Borel å¯æµ‹é›†
- "çº¿æ€§ç®—å­ (ä¹Ÿå«çº¿æ€§æ˜ å°„), å®šä¹‰ä¸º..." â†’ çº¿æ€§ç®—å­; çº¿æ€§æ˜ å°„

## æå–è§„åˆ™

### 1. æ¦‚å¿µè¯†åˆ«
- âœ… æå–æ ¸å¿ƒæ•°å­¦æ¦‚å¿µï¼ˆå‡½æ•°ã€ç©ºé—´ã€ç®—å­ã€å®šç†ç­‰ï¼‰
- âœ… åŒ…å«æ‰€æœ‰ç­‰ä»·çš„ä¸­æ–‡åç§°
- âœ… è‹±æ–‡æœ¯è¯­ç¿»è¯‘æˆæ ‡å‡†ä¸­æ–‡
- âŒ ä¸æå–ä¾‹å­ç¼–å·ï¼ˆå¦‚ "ä¾‹ 2.1"ï¼‰
- âŒ ä¸æå–ç« èŠ‚æ ‡å·ï¼ˆå¦‚ "å®šç† 3.5"ï¼‰

### 2. ç¿»è¯‘è§„åˆ™
- è‹¥å›¾ç‰‡å·²æœ‰ä¸­æ–‡ï¼Œä¼˜å…ˆä½¿ç”¨åŸæ–‡ä¸­çš„ä¸­æ–‡
- è‹¥ä»…æœ‰è‹±æ–‡ï¼Œç¿»è¯‘æˆæ ‡å‡†ä¸­æ–‡æœ¯è¯­
- ä½¿ç”¨æ ‡å‡†æ•°å­¦è¯å…¸æœ¯è¯­ï¼ˆé«˜æ•™å‡ºç‰ˆç¤¾ï¼‰

### 3. å¤šæ¦‚å¿µå¤„ç†
- æŒ‰ç…§é‡è¦æ€§æ’åºï¼ˆæ ¸å¿ƒæ¦‚å¿µåœ¨å‰ï¼‰
- åŒä¸€æ¦‚å¿µçš„ä¸åŒä¸­æ–‡åç§°æ”¾åœ¨ä¸€èµ·
- ä½¿ç”¨åˆ†å·åˆ†éš”ä¸åŒåç§°

**ç¤ºä¾‹**ï¼š
- "è¿ç»­å‡½æ•°; è¿ç»­æ˜ å°„"
- "Hilbert ç©ºé—´; å®Œå¤‡å†…ç§¯ç©ºé—´"

## å¸¸ç”¨æ•°å­¦æœ¯è¯­ç¿»è¯‘

### åŸºæœ¬æ¦‚å¿µ
- function â†’ å‡½æ•° | mapping â†’ æ˜ å°„ | operator â†’ ç®—å­
- set â†’ é›†åˆ | space â†’ ç©ºé—´ | field â†’ åŸŸ
- sequence â†’ åºåˆ— | series â†’ çº§æ•° | limit â†’ æé™

### æ€§è´¨
- continuous â†’ è¿ç»­ | differentiable â†’ å¯å¾® | integrable â†’ å¯ç§¯
- convergent â†’ æ”¶æ•› | bounded â†’ æœ‰ç•Œ | compact â†’ ç´§
- linear â†’ çº¿æ€§ | monotone â†’ å•è°ƒ | convex â†’ å‡¸

### ç†è®º
- theorem â†’ å®šç† | lemma â†’ å¼•ç† | corollary â†’ æ¨è®º
- proposition â†’ å‘½é¢˜ | principle â†’ åŸç† | law â†’ æ³•åˆ™

## æ³¨æ„äº‹é¡¹
1. ä»…è¾“å‡ºä¸­æ–‡æ¦‚å¿µåç§°ï¼Œä¸è¾“å‡ºå®šä¹‰å†…å®¹
2. å»æ‰æ‰€æœ‰æ ‡ç‚¹ç¬¦å·ï¼ˆé™¤åˆ†å·å¤–ï¼‰
3. è‹¥æœ‰å¤šä¸ªç­‰ä»·ä¸­æ–‡åç§°ï¼Œå…¨éƒ¨åˆ—å‡º
4. ä¿æŒæœ¯è¯­çš„æ ‡å‡†æ€§å’Œä¸“ä¸šæ€§

${this.OCRNumberingRules}
`

  static OCRSummarizePrompt = `
# æ•°å­¦æ–‡æœ¬ OCR - ç¿»è¯‘å¹¶æ€»ç»“

## æ ¸å¿ƒä»»åŠ¡
ä»å›¾ç‰‡ä¸­æå–æ–‡æœ¬ï¼Œè¿›è¡Œä¸“ä¸šç¿»è¯‘å¹¶æ€»ç»“ç²¾ç‚¼ï¼Œé€‚ç”¨äºç ”ç©¶è¿›å±•ã€å­¦æœ¯è®ºè¿°ç­‰å†…å®¹ã€‚

**å…³é”®è¦æ±‚**ï¼š
- å·²æ˜¯ä¸­æ–‡çš„å†…å®¹ä¿æŒåŸæ ·å¹¶æ€»ç»“
- è‹±æ–‡å†…å®¹ç¿»è¯‘æˆä¸­æ–‡å¹¶æ€»ç»“
- ç–‘é—®å¥è½¬æ¢ä¸ºé™ˆè¿°å¥
- å»é™¤å†—ä½™è¯´æ˜å’Œè¡¥å……ä¿¡æ¯
- äººåä¿æŒåŸæ–‡ä¸ç¿»è¯‘
- ç¦æ­¢ä½¿ç”¨ LaTeX åŒ…è£¹ç¬¦å·ï¼ˆ$...$ï¼‰ï¼Œä¼˜å…ˆ Unicode
- æ— éœ€æ·»åŠ  "æˆ‘çœ‹åˆ°..." ç­‰æè¿°æ€§å‰ç¼€

## è¾“å‡ºæ ¼å¼è¦æ±‚

**é‡è¦**ï¼šç›´æ¥è¾“å‡ºå†…å®¹ï¼Œä¸è¦æ·»åŠ ä»»ä½•æ ¼å¼æ ‡è®°æˆ–å‰ç¼€ï¼

### æƒ…å†µ 1ï¼šè‹±æ–‡/å…¶ä»–è¯­è¨€å†…å®¹
è¾“å‡ºæ ¼å¼ï¼š<æ€»ç»“åçš„ä¸­æ–‡>: <åŸæ–‡ Unicode å½¢å¼>

**æ­£ç¡®ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šWhy two names? When Ï† is an inner function then this family of measures, along with an associated family of unitary operators (more about this later in the notes), was first studied by Clark. General self-maps Ï† were later studied by Aleksandrov.
- âœ… è¾“å‡ºï¼šæœ‰ä¸¤ä¸ªåç§°çš„åŸå› ï¼šå½“ Ï† æ˜¯å†…å‡½æ•°æ—¶ï¼Œè¿™ä¸ªæµ‹åº¦æ—ä»¥åŠç›¸å…³çš„é…‰ç®—å­æ—é¦–å…ˆç”± Clark ç ”ç©¶ï¼Œè€Œä¸€èˆ¬çš„è‡ªæ˜ å°„ Ï† åæ¥ç”± Aleksandrov ç ”ç©¶: Why two names? When Ï† is an inner function then this family of measures, along with an associated family of unitary operators, was first studied by Clark. General self-maps Ï† were later studied by Aleksandrov.

**é”™è¯¯ç¤ºä¾‹**ï¼ˆç¦æ­¢ï¼‰ï¼š
- âŒ [æ€»ç»“]: æœ‰ä¸¤ä¸ªåç§°çš„åŸå› ï¼š...
- âŒ æ€»ç»“ï¼šæœ‰ä¸¤ä¸ªåç§°çš„åŸå› ï¼š...

### æƒ…å†µ 2ï¼šå·²æ˜¯ä¸­æ–‡å†…å®¹
è¾“å‡ºæ ¼å¼ï¼š"<æ€»ç»“åçš„å†…å®¹>"ï¼ˆä¿æŒä¸­æ–‡ï¼‰

**æ­£ç¡®ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šä¸ºä»€ä¹ˆæœ‰ä¸¤ä¸ªåç§°ï¼Ÿå½“ Ï† æ˜¯å†…å‡½æ•°æ—¶ï¼Œè¿™ä¸ªæµ‹åº¦æ—ä»¥åŠç›¸å…³çš„é…‰ç®—å­æ—ï¼ˆæœ¬ç¬”è®°åé¢ä¼šè¯¦ç»†è®¨è®ºï¼‰é¦–å…ˆç”± Clark ç ”ç©¶ã€‚ä¸€èˆ¬çš„è‡ªæ˜ å°„ Ï† åæ¥ç”± Aleksandrov ç ”ç©¶ã€‚
- âœ… è¾“å‡ºï¼šæœ‰ä¸¤ä¸ªåç§°çš„åŸå› ï¼šå½“ Ï† æ˜¯å†…å‡½æ•°æ—¶ï¼Œè¿™ä¸ªæµ‹åº¦æ—ä»¥åŠç›¸å…³çš„é…‰ç®—å­æ—é¦–å…ˆç”± Clark ç ”ç©¶ï¼Œè€Œä¸€èˆ¬çš„è‡ªæ˜ å°„ Ï† åæ¥ç”± Aleksandrov ç ”ç©¶

## æ€»ç»“è§„åˆ™

### 1. ç–‘é—®å¥è½¬é™ˆè¿°å¥
å°†ç–‘é—®å¥å¼æ”¹å†™ä¸ºé™ˆè¿°å¥å¼ï¼Œä½¿è¡¨è¾¾æ›´ç®€æ´æµç•…ã€‚

**è½¬æ¢æ¨¡å¼**ï¼š
- "ä¸ºä»€ä¹ˆ...ï¼Ÿ" â†’ "...çš„åŸå› æ˜¯..."
- "ä»€ä¹ˆæ˜¯...ï¼Ÿ" â†’ "...æ˜¯æŒ‡..."
- "å¦‚ä½•...ï¼Ÿ" â†’ "...çš„æ–¹æ³•æ˜¯..."
- "æ˜¯å¦...ï¼Ÿ" â†’ åˆ¤æ–­åæ˜ç¡®é™ˆè¿°

**ç¤ºä¾‹**ï¼š
- âŒ ä¸ºä»€ä¹ˆ Clark measure æœ‰ä¸¤ä¸ªåç§°ï¼Ÿå› ä¸º...
- âœ… Clark measure æœ‰ä¸¤ä¸ªåç§°çš„åŸå› æ˜¯ï¼š...

- âŒ ä»€ä¹ˆæ˜¯ Aleksandrov measureï¼Ÿå®ƒæ˜¯...
- âœ… Aleksandrov measure æ˜¯æŒ‡...

### 2. å»é™¤å†—ä½™ä¿¡æ¯
åˆ é™¤è¡¥å……è¯´æ˜ã€æ³¨é‡Šã€å¼•ç”¨ç­‰éæ ¸å¿ƒä¿¡æ¯ã€‚

**éœ€è¦åˆ é™¤çš„å†…å®¹**ï¼š
- æ‹¬å·å†…çš„è¡¥å……è¯´æ˜ï¼šï¼ˆæœ¬ç¬”è®°åé¢ä¼šè¯¦ç»†è®¨è®ºï¼‰ã€ï¼ˆè§ç¬¬3ç« ï¼‰
- å¼•ç”¨æ ‡æ³¨ï¼š[1]ã€[Smith 2020]
- å†—ä½™ä¿®é¥°ï¼šæ˜¾ç„¶ã€å®¹æ˜“çœ‹å‡ºã€ä¼—æ‰€å‘¨çŸ¥
- è¿‡æ¸¡æ€§è¯è¯­ï¼šé¦–å…ˆã€ç„¶åã€æœ€åï¼ˆé™¤éå¯¹ç†è§£é€»è¾‘è‡³å…³é‡è¦ï¼‰

**ç¤ºä¾‹**ï¼š
- âŒ è¿™ä¸ªæµ‹åº¦æ—ï¼ˆæœ¬ç¬”è®°åé¢ä¼šè¯¦ç»†è®¨è®ºï¼‰é¦–å…ˆç”± Clark ç ”ç©¶
- âœ… è¿™ä¸ªæµ‹åº¦æ—é¦–å…ˆç”± Clark ç ”ç©¶

### 3. é€»è¾‘æ•´åˆ
ä½¿ç”¨è¿æ¥è¯æ•´åˆä¿¡æ¯ï¼Œä½¿è¡¨è¾¾æ›´è¿è´¯ã€‚

**å¸¸ç”¨è¿æ¥è¯**ï¼š
- å› æœå…³ç³»ï¼šç”±äºã€å› æ­¤ã€æ‰€ä»¥
- å¹¶åˆ—å…³ç³»ï¼šåŒæ—¶ã€è€Œã€å¹¶ä¸”
- è½¬æŠ˜å…³ç³»ï¼šä½†æ˜¯ã€ç„¶è€Œã€ä¸è¿‡
- é€’è¿›å…³ç³»ï¼šè¿›è€Œã€è¿›ä¸€æ­¥ã€ç”šè‡³

**ç¤ºä¾‹**ï¼š
- âŒ é¦–å…ˆç”± Clark ç ”ç©¶ã€‚åæ¥ç”± Aleksandrov ç ”ç©¶ã€‚
- âœ… é¦–å…ˆç”± Clark ç ”ç©¶ï¼Œè€Œåæ¥ç”± Aleksandrov ç ”ç©¶

- âŒ Ï† æ˜¯å†…å‡½æ•°ã€‚æµ‹åº¦æ—ç”± Clark ç ”ç©¶ã€‚
- âœ… å½“ Ï† æ˜¯å†…å‡½æ•°æ—¶ï¼Œæµ‹åº¦æ—ç”± Clark ç ”ç©¶

### 4. äººåå¤„ç†è§„åˆ™
**æ ¸å¿ƒåŸåˆ™**ï¼šäººåå§‹ç»ˆä¿æŒåŸæ–‡ï¼Œä¸ç¿»è¯‘

- âœ… äººåä¿æŒåŸæ–‡æ‹¼å†™ï¼šClark, Aleksandrov, Fourier, Cauchy
- âœ… ä¸“ä¸šæœ¯è¯­ä¸­çš„äººåä¿æŒåŸæ–‡ï¼šClark measure â†’ Clark æµ‹åº¦ï¼ˆä¸æ˜¯"å…‹æ‹‰å…‹æµ‹åº¦"ï¼‰
- âœ… å¥å­ä¸­çš„äººåä¿æŒåŸæ–‡ï¼šç”± Clark ç ”ç©¶ï¼ˆä¸æ˜¯"ç”±å…‹æ‹‰å…‹ç ”ç©¶"ï¼‰
- âœ… äººåæ‰€æœ‰æ ¼ä¿æŒåŸæ–‡ï¼šClark's theorem â†’ Clark å®šç†
- âœ… å¸¸è§æ•°å­¦å®¶äººåç¤ºä¾‹ï¼š
  - Fourier, Laplace, Cauchy, Riemann, Lebesgue
  - Banach, Hilbert, Sobolev, Schwartz, HÃ¶lder
  - Clark, Aleksandrov, Kolmogorov, Chebyshev

## Unicode ç¬¦å·ä½¿ç”¨

**ä¼˜å…ˆä½¿ç”¨ Unicode**ï¼š
- ä¸Šæ ‡ï¼šxÂ², xÂ³, xâ¿
- ä¸‹æ ‡ï¼šxâ‚, xâ‚‚, xâ‚™
- å¸Œè…Šå­—æ¯ï¼šÎ±, Î², Î³, Î´, Îµ, Ï†, Î¸, Î», Î¼, Ï€, Ïƒ, Ï‰
- è¿ç®—ç¬¦ï¼šÂ±, Ã—, Ã·, â‰ , â‰¤, â‰¥, â‰ˆ
- å¾®ç§¯åˆ†ï¼šâˆ«, âˆ‘, âˆ, âˆ‚, âˆ‡, âˆ, lim

${this.OCRCorrectionRules}

${this.OCRNumberingRules}

## æœ€ç»ˆæ£€æŸ¥æ¸…å•
1. ç–‘é—®å¥æ˜¯å¦å·²è½¬æ¢ä¸ºé™ˆè¿°å¥
2. å†—ä½™ä¿¡æ¯æ˜¯å¦å·²åˆ é™¤
3. äººåæ˜¯å¦ä¿æŒåŸæ–‡
4. é€»è¾‘è¿æ¥æ˜¯å¦æµç•…
5. Unicode ç¬¦å·æ˜¯å¦æ­£ç¡®ä½¿ç”¨
`

  static OCRSummarizeNoTransPrompt = `
# æ•°å­¦æ–‡æœ¬ OCR - æ€»ç»“ï¼ˆä»…ä¸­æ–‡ï¼‰

## æ ¸å¿ƒä»»åŠ¡
ä»å›¾ç‰‡ä¸­æå–æ–‡æœ¬å¹¶è¿›è¡Œæ€»ç»“ç²¾ç‚¼ï¼Œæ‰€æœ‰å†…å®¹è¾“å‡ºä¸ºä¸­æ–‡ã€‚

**å…³é”®è¦æ±‚**ï¼š
- æ‰€æœ‰å†…å®¹ç¿»è¯‘æˆä¸­æ–‡ï¼ˆå·²æ˜¯ä¸­æ–‡çš„ä¿æŒåŸæ ·ï¼‰
- ç–‘é—®å¥è½¬æ¢ä¸ºé™ˆè¿°å¥
- å»é™¤å†—ä½™è¯´æ˜å’Œè¡¥å……ä¿¡æ¯
- äººåä¿æŒåŸæ–‡ä¸ç¿»è¯‘
- ç¦æ­¢ä½¿ç”¨ LaTeX åŒ…è£¹ç¬¦å·ï¼ˆ$...$ï¼‰ï¼Œä¼˜å…ˆ Unicode
- æ— éœ€æ·»åŠ  "æˆ‘çœ‹åˆ°..." ç­‰æè¿°æ€§å‰ç¼€

## è¾“å‡ºæ ¼å¼è¦æ±‚

**é‡è¦**ï¼šç›´æ¥è¾“å‡ºæ€»ç»“åçš„ä¸­æ–‡å†…å®¹ï¼Œä¸è¦æ·»åŠ ä»»ä½•æ ¼å¼æ ‡è®°æˆ–å‰ç¼€ï¼

**ç»Ÿä¸€è¾“å‡ºæ ¼å¼**ï¼š"<æ€»ç»“åçš„ä¸­æ–‡å†…å®¹>"

**æ­£ç¡®ç¤ºä¾‹**ï¼š
- è¾“å…¥ï¼šWhy two names? When Ï† is an inner function...
- âœ… è¾“å‡ºï¼šæœ‰ä¸¤ä¸ªåç§°çš„åŸå› ï¼šå½“ Ï† æ˜¯å†…å‡½æ•°æ—¶ï¼Œè¿™ä¸ªæµ‹åº¦æ—é¦–å…ˆç”± Clark ç ”ç©¶ï¼Œè€Œä¸€èˆ¬è‡ªæ˜ å°„åæ¥ç”± Aleksandrov ç ”ç©¶

**é”™è¯¯ç¤ºä¾‹**ï¼ˆç¦æ­¢ï¼‰ï¼š
- âŒ [æ€»ç»“]: æœ‰ä¸¤ä¸ªåç§°çš„åŸå› ï¼š...
- âŒ ä¸­æ–‡: æœ‰ä¸¤ä¸ªåç§°çš„åŸå› ï¼š...

## æ€»ç»“è§„åˆ™

### 1. ç–‘é—®å¥è½¬é™ˆè¿°å¥
å°†ç–‘é—®å¥å¼æ”¹å†™ä¸ºé™ˆè¿°å¥å¼ï¼Œä½¿è¡¨è¾¾æ›´ç®€æ´æµç•…ã€‚

**è½¬æ¢æ¨¡å¼**ï¼š
- "ä¸ºä»€ä¹ˆ...ï¼Ÿ" â†’ "...çš„åŸå› æ˜¯..."
- "ä»€ä¹ˆæ˜¯...ï¼Ÿ" â†’ "...æ˜¯æŒ‡..."
- "å¦‚ä½•...ï¼Ÿ" â†’ "...çš„æ–¹æ³•æ˜¯..."
- "æ˜¯å¦...ï¼Ÿ" â†’ åˆ¤æ–­åæ˜ç¡®é™ˆè¿°

### 2. å»é™¤å†—ä½™ä¿¡æ¯
åˆ é™¤è¡¥å……è¯´æ˜ã€æ³¨é‡Šã€å¼•ç”¨ç­‰éæ ¸å¿ƒä¿¡æ¯ã€‚

**éœ€è¦åˆ é™¤çš„å†…å®¹**ï¼š
- æ‹¬å·å†…çš„è¡¥å……è¯´æ˜ï¼šï¼ˆæœ¬ç¬”è®°åé¢ä¼šè¯¦ç»†è®¨è®ºï¼‰ã€ï¼ˆè§ç¬¬3ç« ï¼‰
- å¼•ç”¨æ ‡æ³¨ï¼š[1]ã€[Smith 2020]
- å†—ä½™ä¿®é¥°ï¼šæ˜¾ç„¶ã€å®¹æ˜“çœ‹å‡ºã€ä¼—æ‰€å‘¨çŸ¥
- è¿‡æ¸¡æ€§è¯è¯­ï¼šé¦–å…ˆã€ç„¶åã€æœ€åï¼ˆé™¤éå¯¹ç†è§£é€»è¾‘è‡³å…³é‡è¦ï¼‰

### 3. é€»è¾‘æ•´åˆ
ä½¿ç”¨è¿æ¥è¯æ•´åˆä¿¡æ¯ï¼Œä½¿è¡¨è¾¾æ›´è¿è´¯ã€‚

**å¸¸ç”¨è¿æ¥è¯**ï¼š
- å› æœå…³ç³»ï¼šç”±äºã€å› æ­¤ã€æ‰€ä»¥
- å¹¶åˆ—å…³ç³»ï¼šåŒæ—¶ã€è€Œã€å¹¶ä¸”
- è½¬æŠ˜å…³ç³»ï¼šä½†æ˜¯ã€ç„¶è€Œã€ä¸è¿‡
- é€’è¿›å…³ç³»ï¼šè¿›è€Œã€è¿›ä¸€æ­¥ã€ç”šè‡³

### 4. äººåå¤„ç†è§„åˆ™
**æ ¸å¿ƒåŸåˆ™**ï¼šäººåå§‹ç»ˆä¿æŒåŸæ–‡ï¼Œä¸ç¿»è¯‘

- âœ… äººåä¿æŒåŸæ–‡æ‹¼å†™ï¼šClark, Aleksandrov, Fourier, Cauchy
- âœ… ä¸“ä¸šæœ¯è¯­ä¸­çš„äººåä¿æŒåŸæ–‡ï¼šClark measure â†’ Clark æµ‹åº¦ï¼ˆä¸æ˜¯"å…‹æ‹‰å…‹æµ‹åº¦"ï¼‰
- âœ… å¥å­ä¸­çš„äººåä¿æŒåŸæ–‡ï¼šç”± Clark ç ”ç©¶ï¼ˆä¸æ˜¯"ç”±å…‹æ‹‰å…‹ç ”ç©¶"ï¼‰
- âœ… äººåæ‰€æœ‰æ ¼ä¿æŒåŸæ–‡ï¼šClark's theorem â†’ Clark å®šç†
- âœ… å¸¸è§æ•°å­¦å®¶äººåç¤ºä¾‹ï¼š
  - Fourier, Laplace, Cauchy, Riemann, Lebesgue
  - Banach, Hilbert, Sobolev, Schwartz, HÃ¶lder
  - Clark, Aleksandrov, Kolmogorov, Chebyshev

## Unicode ç¬¦å·ä½¿ç”¨

**ä¼˜å…ˆä½¿ç”¨ Unicode**ï¼š
- ä¸Šæ ‡ï¼šxÂ², xÂ³, xâ¿
- ä¸‹æ ‡ï¼šxâ‚, xâ‚‚, xâ‚™
- å¸Œè…Šå­—æ¯ï¼šÎ±, Î², Î³, Î´, Îµ, Ï†, Î¸, Î», Î¼, Ï€, Ïƒ, Ï‰
- è¿ç®—ç¬¦ï¼šÂ±, Ã—, Ã·, â‰ , â‰¤, â‰¥, â‰ˆ
- å¾®ç§¯åˆ†ï¼šâˆ«, âˆ‘, âˆ, âˆ‚, âˆ‡, âˆ, lim

${this.OCRCorrectionRules}

${this.OCRNumberingRules}

## æœ€ç»ˆæ£€æŸ¥æ¸…å•
1. ç–‘é—®å¥æ˜¯å¦å·²è½¬æ¢ä¸ºé™ˆè¿°å¥
2. å†—ä½™ä¿¡æ¯æ˜¯å¦å·²åˆ é™¤
3. äººåæ˜¯å¦ä¿æŒåŸæ–‡
4. é€»è¾‘è¿æ¥æ˜¯å¦æµç•…
5. Unicode ç¬¦å·æ˜¯å¦æ­£ç¡®ä½¿ç”¨
`

  static async OCRToTitle(note, mode = 1, needTranslation = undefined, place = "all") {
    let imageData = ocrUtils.getImageFromNote(note)
    if (!imageData) {
      // MNUtil.showHUD("No image found")
      return
    }
    let compressedImageData = UIImage.imageWithData(imageData).jpegData(0.1)

    // ç¡®å®šæ˜¯å¦éœ€è¦ç¿»è¯‘
    // 1. å¦‚æœ needTranslation å‚æ•°å·²æŒ‡å®šï¼Œä½¿ç”¨è¯¥å€¼
    // 2. é»˜è®¤ä¸º falseï¼ˆä¸ç¿»è¯‘ï¼‰
    // æ³¨æ„ï¼šneedTranslation åº”ç”±è°ƒç”¨æ–¹ï¼ˆå¦‚ main.jsï¼‰æ ¹æ® self.preExcerptMode ä¼ å…¥
    let shouldTranslate = needTranslation !== undefined
      ? needTranslation
      : false;

    // æ ¹æ®æ¨¡å¼å’Œæ˜¯å¦ç¿»è¯‘é€‰æ‹©å¯¹åº”çš„ prompt
    let prompt
    switch (mode) {
      case 1:
        prompt = shouldTranslate ? this.OCRDirectlyPrompt : this.OCRDirectlyNoTransPrompt
        break
      case 2:
        prompt = shouldTranslate ? this.OCRToMarkdownPrompt : this.OCRToMarkdownNoTransPrompt
        break
      case 3:
        // æ£€æŸ¥æ˜¯å¦æ˜¯å®šä¹‰ç±»å¡ç‰‡ï¼ˆé€šè¿‡ colorIndex åˆ¤æ–­ï¼‰
        if (note.colorIndex === KnowledgeBaseTemplate.types["å®šä¹‰"].colorIndex) {
          // å®šä¹‰ç±»å¡ç‰‡ä½¿ç”¨æ¦‚å¿µæå–æç¤ºè¯
          prompt = shouldTranslate ? this.OCRExtractConceptPrompt : this.OCRExtractConceptNoTransPrompt
        } else if (note.colorIndex === KnowledgeBaseTemplate.types["ç ”ç©¶è¿›å±•"].colorIndex) {
          // ç ”ç©¶è¿›å±•ç±»å¡ç‰‡ä½¿ç”¨æ€»ç»“æç¤ºè¯
          prompt = shouldTranslate ? this.OCRSummarizePrompt : this.OCRSummarizeNoTransPrompt
        } else {
          // éå®šä¹‰ç±»å¡ç‰‡ä½¿ç”¨ç›´å‡ºæç¤ºè¯
          prompt = shouldTranslate ? this.OCRDirectlyPrompt : this.OCRDirectlyNoTransPrompt
        }
        break
      default:
        prompt = shouldTranslate ? this.OCRDirectlyPrompt : this.OCRDirectlyNoTransPrompt
    }

    // æ ¹æ®æ¨¡å¼é€‰æ‹©å¯¹åº”çš„ OCR æ¨¡å‹
    let ocrModel;
    switch (mode) {
      case 1:
        // æ¨¡å¼1ï¼šç›´æ¥OCR - ä½¿ç”¨ä¸“ç”¨æ¨¡å‹ï¼Œæœªè®¾ç½®æ—¶å›é€€åˆ°é€šç”¨æ¨¡å‹
        if (note.colorIndex === KnowledgeBaseTemplate.types["å®šä¹‰"].colorIndex) {
          return false  // å®šä¹‰å¡ç‰‡ä¸è¿›è¡Œ OCR
        }
        ocrModel = KnowledgeBaseConfig.config.excerptOCRModelForMode1 || KnowledgeBaseConfig.config.excerptOCRModel;
        break;
      case 2:
        // æ¨¡å¼2ï¼šMarkdownæ ¼å¼ - ä½¿ç”¨ä¸“ç”¨æ¨¡å‹ï¼ˆé»˜è®¤ Doc2Xï¼‰ï¼Œæœªè®¾ç½®æ—¶å›é€€åˆ°é€šç”¨æ¨¡å‹
        ocrModel = KnowledgeBaseConfig.config.excerptOCRModelForMode2 || KnowledgeBaseConfig.config.excerptOCRModel;
        break;
      case 3:
        // æ¨¡å¼3ï¼šæ¦‚å¿µæå–/æ€»ç»“ - ä½¿ç”¨ä¸“ç”¨æ¨¡å‹ï¼Œæœªè®¾ç½®æ—¶å›é€€åˆ°é€šç”¨æ¨¡å‹
        // æ£€æŸ¥æ˜¯å¦æ˜¯å®šä¹‰ç±»å¡ç‰‡æˆ–ç ”ç©¶è¿›å±•ç±»å¡ç‰‡ï¼ˆé€šè¿‡ colorIndex åˆ¤æ–­ï¼‰
        if (note.colorIndex === KnowledgeBaseTemplate.types["å®šä¹‰"].colorIndex) {
          // å®šä¹‰ç±»å¡ç‰‡
          ocrModel = KnowledgeBaseConfig.config.excerptOCRModelForMode3 || KnowledgeBaseConfig.config.excerptOCRModel;
        } else if (note.colorIndex === KnowledgeBaseTemplate.types["ç ”ç©¶è¿›å±•"].colorIndex) {
          // ç ”ç©¶è¿›å±•ç±»å¡ç‰‡ä½¿ç”¨æ¨¡å¼3çš„æ¨¡å‹ï¼ˆæˆ–å¯ä»¥å•ç‹¬é…ç½®ï¼‰
          ocrModel = KnowledgeBaseConfig.config.excerptOCRModelForMode3 || KnowledgeBaseConfig.config.excerptOCRModel;
        } else {
          ocrModel = KnowledgeBaseConfig.config.excerptOCRModelForMode1 || KnowledgeBaseConfig.config.excerptOCRModel;
        }
        break;
      default:
        // é»˜è®¤ä½¿ç”¨é€šç”¨æ¨¡å‹
        ocrModel = KnowledgeBaseConfig.config.excerptOCRModel;
    }

    let result = await this.OCR(compressedImageData, ocrModel, prompt)
    // åº”ç”¨ OCR åå¤„ç†è§„åˆ™
    result = this.postProcessOCRResult(result)
    if (result) {
      MNUtil.undoGrouping(()=>{
        let titleParts = KnowledgeBaseTemplate.parseNoteTitle(note)
        switch (place) {
          case "all":
            note.title = result.trim()
            break;
          case "firstTitleLinkWord":
            note.title = titleParts.type?'ã€' + titleParts.type + ' >> ' + titleParts.prefixContent + 'ã€‘' + result.trim() + "; " +  titleParts.content : result.trim() + "; " +  titleParts.content
            break;
          case "lastTitleLinkWord":
            note.title = note.title + "; " +  result.trim()
            break;
        }
        KnowledgeBaseUtils.log("Set note title via OCR: "+result, "OCRToTitle")
        return true
      })
    } else {
      return false
    }
  }
  static async OCR(imageData, source = "doubao-seed-1-6-nothinking", prompt){
    try {
      let ocrSource = source
      let config = JSON.parse(JSON.stringify(ocrConfig.config))
      config.source = ocrSource
      MNUtil.log(typeof imageData)
      MNUtil.log("is imagedata: "+(imageData instanceof NSData))
      let imageBase64 = (typeof imageData === "string") ? imageData : imageData.base64Encoding()
      let strForMD5 = JSON.stringify(config)+imageBase64
      let MD5 = MNUtil.MD5(strForMD5)
      MNUtil.log("MD5: "+MD5)
      let res = undefined;
      switch (ocrSource) {
        case "Doc2X":
        case "doc2x":
          res = await ocrNetwork.doc2xImgOCR(imageData)
          if (res) {
            ocrNetwork.OCRBuffer[MD5] = res
            MNUtil.log({
              source:"MN OCR",
              message:"âœ… OCR By Doc2X",
              detail:res
            })
          }
          break;
        case "SimpleTex":
        case "simpleTex":
          res = await ocrNetwork.simpleTexOCR(imageData)
          if (res) {
            ocrNetwork.OCRBuffer[MD5] = res
            MNUtil.log({
              source:"MN OCR",
              message:"âœ… OCR By SimpleTex",
              detail:res
            })
          }
          break;
        case "glm-4v-plus":
        case "glm-4v-flash":
        case "glm-4.1v-thinking-flashx":
        case "glm-4.1v-thinking-flash":
        case "glm-4.5v":
        case "glm-4.5v-nothinking":
        case "abab6.5s-chat":
        case "claude-3-5-sonnet-20241022":
        case "claude-3-5-haiku-20241022":
        case "claude-3-7-sonnet":
        case "claude-opus-4":
        case "claude-sonnet-4":
        case "claude-3-5-haiku":
        case "gemini-2.0-flash-exp":
        case "gemini-2.0-flash-lite":
        case "gemini-2.5-flash-lite":
        case "gemini-2.0-flash":
        case "gemini-2.5-flash":
        case "gemini-2.5-pro":
        case "gemini-2.0-pro":
        case "GPT-4o":
        case "GPT-4o-mini":
        case "GPT-4.1":
        case "GPT-4.1-mini":
        case "GPT-4.1-nano":
        case "GPT-5":
        case "GPT-5-mini":
        case "GPT-5-nano":
        case "doubao-seed-1-6":
        case "doubao-seed-1-6-nothinking":
        case "doubao-seed-1.6-flash":
        case "doubao-seed-1.6-flash-nothinking":
        case "Moonshot-v1":
        case "MiniMax-Text-01":
          let beginTime = Date.now()
          res = await this.ChatGPTVision(imageBase64, ocrSource, prompt)
          let endTime = Date.now()
          let costTime = (endTime-beginTime)/1000
          if (res) {
            ocrNetwork.OCRBuffer[MD5] = res
            MNUtil.log({
              source:"MN OCR",
              message:"âœ… OCR By "+ocrSource+" ("+costTime.toFixed(2)+"s)",
              detail:res
            })
          }
          break;
        default:
          MNUtil.showHUD("Unsupported source: "+ocrSource)
          return undefined
      }
      MNUtil.stopHUD()
      res = ocrUtils.action(source, res)
      return res
    } catch (error) {
      KnowledgeBaseUtils.addErrorLog(error, "KnowledgeBaseNetwork.OCR")
      return undefined
    }
  }

  /**
   * å…è®¸ç›´æ¥ä¼ å…¥base64å›¾ç‰‡,å‡å°‘è½¬æ¢è€—æ—¶
   * @param {string|NSData} imageData
   * @returns {Promise<Object>}
   */
  static async ChatGPTVision(imageData, source="GPT-4o",prompt = ocrConfig.getConfig("userPrompt")) {
    try {
      let key = subscriptionConfig.config.apikey
      if (ocrConfig.modelSource(source).isFree) {
        key = 'sk-S2rXjj2qB98OiweU46F3BcF2D36e4e5eBfB2C9C269627e44'
      }
      if (!key) {
        MNUtil.showHUD("No ChatGPT API key")
        return
      }
      MNUtil.waitHUD("OCR By "+source)
      let url = subscriptionConfig.config.url + "/v1/chat/completions"
      let imageUrl = "data:image/jpeg;base64,"
      if (typeof imageData === "string") {
        imageUrl = imageUrl+imageData
      } else {
        imageUrl = imageUrl+imageData.base64Encoding()
      }
      ocrNetwork.history = [
        {
          role:"system",
          content:prompt
        },
        {
          role: "user", 
          content: [
            {
              "type": "image_url",
              "image_url": {
                "url" : imageUrl
              }
            }
          ]
        }
      ]

      let modelName = ocrConfig.modelSource(source).model
      let request = ocrNetwork.initRequestForChatGPT(key, url, modelName, 0.1)
      let res = await ocrNetwork.sendRequest(request,"ChatGPTVision",false)
      let ocrResult
      if (res.choices && res.choices.length) {
        ocrResult = res.choices[0].message.content
      } else {
        return undefined
      }

      let convertedText = ocrResult
        .replace(/\$\$\n?/g, '$$$\n')
        .replace(/(\\\[\s*\n?)|(\s*\\\]\n?)/g, '$$$\n')
        .replace(/(\\\(\s*)|(\s*\\\))/g, '$')
        .replace(/```/g,'')
        .replace(/<\|begin_of_box\|>/g,'')
        .replace(/<\|end_of_box\|>/g,'')
      return convertedText
    } catch (error) {
      KnowledgeBaseUtils.addErrorLog(error, "ChatGPTVision")
      return undefined
    }
  }

  /**
   * é€šè¿‡äº‹ä»¶é€šçŸ¥è°ƒç”¨ MNAIï¼ˆæ›´é«˜çº§ï¼‰
   * @param {string} text - è¦å¤„ç†çš„æ–‡æœ¬
   * @returns {Promise<string|null>} AI ç”Ÿæˆçš„ç»“æœæ–‡æœ¬ï¼Œå¤±è´¥è¿”å› null
   *
   * @description
   * ä½¿ç”¨ NSNotificationCenter å¹¿æ’­æœºåˆ¶è°ƒç”¨ MNAI æ’ä»¶ã€‚
   * å‘é€è¯·æ±‚åä¼šè½®è¯¢ç­‰å¾… AI ç”Ÿæˆå®Œæˆï¼Œæœ€å¤šç­‰å¾… 30 ç§’ã€‚
   *
   * MNAI æ’ä»¶ä¼šç›‘å¬ "customChat" äº‹ä»¶ï¼Œé€šè¿‡ customAsk æ–¹æ³•å¤„ç†è¯·æ±‚ã€‚
   * ç”Ÿæˆçš„å†…å®¹æœ€ç»ˆå­˜å‚¨åœ¨ chatAIUtils.notifyController.lastResponse ä¸­ã€‚
   *
   * @example
   * const result = await KnowledgeBaseNetwork.callMNAIWithNotification("è¯·å¸®æˆ‘ç¿»è¯‘è¿™æ®µæ–‡å­—");
   * if (result) {
   *   console.log("AI ç»“æœï¼š", result);
   * }
   */
  static async callMNAIWithNotification(text) {
    try {
      // æ£€æŸ¥ MNAI æ˜¯å¦å·²åŠ è½½
      if (typeof chatAIUtils === "undefined") {
        MNUtil.showHUD("âŒ è¯·å…ˆå®‰è£…å¹¶æ‰“å¼€ MNAI æ’ä»¶");
        return null;
      }

      MNUtil.showHUD("æ­£åœ¨å‘é€åˆ° AI å¤„ç†...");

      // å‘é€è¯·æ±‚åˆ° MNAI
      MNUtil.postNotification("customChat", {
        user: text
      });

      // ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®© MNAI å¼€å§‹å¤„ç†
      await MNUtil.delay(0.5);

      // è½®è¯¢ç­‰å¾…ç»“æœ
      const maxAttempts = 60;  // æœ€å¤šç­‰å¾… 30 ç§’ï¼ˆ60 * 0.5ï¼‰
      const pollInterval = 0.5; // æ¯ 0.5 ç§’æ£€æŸ¥ä¸€æ¬¡
      let AIResult = null;

      for (let i = 0; i < maxAttempts; i++) {
        // æ£€æŸ¥ notifyController æ˜¯å¦å­˜åœ¨
        if (chatAIUtils && chatAIUtils.notifyController) {
          const controller = chatAIUtils.notifyController;

          // ä¼˜å…ˆæ£€æŸ¥ lastResponseï¼ˆç”Ÿæˆå®Œæˆåçš„æœ€ç»ˆç»“æœï¼‰
          // MNAI åœ¨ finish() ä¸­ä¼šå°† response ä¿å­˜åˆ° lastResponse ç„¶åæ¸…ç©º response
          if (controller.lastResponse && controller.lastResponse.trim()) {
            MNUtil.showHUD("âœ… è·å–åˆ° AI ç»“æœ");
            KnowledgeBaseUtils.log("è·å–åˆ° lastResponse: " + controller.lastResponse.substring(0, 50) + "...", "callMNAIWithNotification");

            // å»¶è¿Ÿ 0.5 ç§’åè‡ªåŠ¨å…³é—­é€šçŸ¥çª—å£
            // è®©ç”¨æˆ·æœ‰æ—¶é—´çœ‹åˆ°æˆåŠŸæç¤º
            if (controller.checkAutoClose) {
              controller.checkAutoClose(true, 0.5);
            } else if (controller.hide) {
              // å¤‡ç”¨ï¼šå¦‚æœ checkAutoClose ä¸å¯ç”¨ï¼Œç›´æ¥è°ƒç”¨ hide
              setTimeout(() => {
                controller.hide();
              }, 500);
            }
            AIResult = controller.lastResponse;
            controller.lastResponse = "";
            return AIResult;
          }

          // å¤‡ç”¨æ£€æŸ¥ï¼šåœ¨æŸäº›æƒ…å†µä¸‹ response å¯èƒ½è¿˜æœªè¢«æ¸…ç©º
          // è¿™ç§æƒ…å†µè¾ƒå°‘è§ï¼Œä½†ä¿ç•™ä»¥é˜²ä¸‡ä¸€
          if (!controller.connection && controller.response && controller.response.trim()) {
            MNUtil.showHUD("âœ… è·å–åˆ° AI ç»“æœï¼ˆå¤‡ç”¨ï¼‰");
            KnowledgeBaseUtils.log("è·å–åˆ° response: " + controller.response.substring(0, 50) + "...", "callMNAIWithNotification");

            // åŒæ ·å…³é—­çª—å£
            if (controller.checkAutoClose) {
              controller.checkAutoClose(true, 0.5);
            } else if (controller.hide) {
              setTimeout(() => {
                controller.hide();
              }, 500);
            }

            AIResult = controller.lastResponse;
            controller.lastResponse = "";
            return AIResult;
          }
        }
        // ç»§ç»­ç­‰å¾…
        await MNUtil.delay(pollInterval);
      }

      // è¶…æ—¶
      MNUtil.showHUD("âŒ è·å– AI ç»“æœè¶…æ—¶ï¼ˆ30ç§’ï¼‰");
      return null;

    } catch (error) {
      MNUtil.showHUD("âŒ è°ƒç”¨ MNAI å¤±è´¥: " + error.message);
      KnowledgeBaseUtils.addErrorLog(error, "callMNAIWithNotification");
      return null;
    }
  }
}

class KnowledgeBaseConfig {
  static excerptOCRSources = [
    "doubao-seed-1-6",
    "doubao-seed-1-6-nothinking",
    "doubao-seed-1.6-flash",
    "doubao-seed-1.6-flash-nothinking",
    "Doc2X",
    "Doc2XPDF",
    "SimpleTex",
    "abab6.5s-chat",
    "MiniMax-Text-01",
    "Moonshot-v1",
    "claude-3-5-sonnet-20241022",
    "claude-opus-4",
    "claude-sonnet-4",
    "claude-3-7-sonnet",
    "claude-3-5-haiku-20241022",
    "claude-3-5-haiku",
    "gemini-2.0-flash",
    "gemini-2.5-flash",
    "gemini-2.0-flash-lite",
    "gemini-2.5-flash-lite",
    "gemini-2.0-flash-exp",
    "gemini-2.0-pro",
    "gemini-2.5-pro",
    "glm-4v-plus",
    "glm-4v-flash",
    "glm-4.1v-thinking-flashx",
    "glm-4.1v-thinking-flash",
    "glm-4.5v",
    "glm-4.5v-nothinking",
    "GPT-4o",
    "GPT-4o-mini",
    "GPT-4.1",
    "GPT-4.1-mini",
    "GPT-4.1-nano",
    "GPT-5",
    "GPT-5-mini",
    "GPT-5-nano",
    // ğŸ†• æ–°å¢ Qwen è§†è§‰ç³»åˆ—
    "qwen3-vl-plus",
    "qwen3-omni-flash",
    "qwen/qwen3-vl-235b-a22b-instruct",
    "qwen/qwen3-vl-235b-a22b-thinking",
    // ğŸ†• æ–°å¢ Moonshot å®Œæ•´ç³»åˆ—
    "kimi-latest",
    "moonshot-v1-8k",
    "moonshot-v1-32k",
    "moonshot-v1-128k",
    "moonshot-v1-8k-vision-preview",
    "moonshot-v1-32k-vision-preview",
    "moonshot-v1-128k-vision-preview",
    "moonshot-v1-auto",
    // ğŸ†• æ–°å¢ Doubao è¯¦ç»†ç‰ˆæœ¬
    "doubao-seed-1-6-thinking-250715",
    "doubao-seed-1-6-thinking-250615",
    "doubao-seed-1-6-250615",
    "doubao-seed-1-6-flash-250715",
    "doubao-seed-1-6-flash-250615",
    "doubao-seed-1-6-vision-250815",
    // ğŸ†• æ–°å¢ GLM é«˜çº§ç‰ˆæœ¬
    "pro/thudm/glm-4.1v-9b-thinking",
  ];
  // é»˜è®¤æ‘˜å½• OCR æ¨¡å‹å¸¸é‡ï¼Œé¿å…åœ¨å¤šä¸ªä½ç½®é‡å¤å­—é¢é‡
  static DEFAULT_EXCERPT_OCR_MODEL = "doubao-seed-1-6";
  static get defaultConfig() {
    return {
      excerptOCRModel: this.DEFAULT_EXCERPT_OCR_MODEL, // æ‘˜å½• OCR æ¨¡å‹ï¼ˆé€šç”¨é»˜è®¤ï¼‰
      // è®¡ç®—é»˜è®¤æ¨¡å‹çš„ç´¢å¼•ï¼Œä½¿ç”¨å¸¸é‡è€Œä¸æ˜¯å†æ¬¡è®¿é—® getter
      excerptOCRModelIndex: this.excerptOCRSources.indexOf(this.DEFAULT_EXCERPT_OCR_MODEL),
      excerptOCRMode: 0, // æ‘˜å½• OCR æ¨¡å¼ï¼š0=å…³é—­, 1=ç›´æ¥OCR, 2=Markdownæ ¼å¼, 3=æ¦‚å¿µæå–

      // æ¯ä¸ªæ¨¡å¼çš„ä¸“ç”¨æ¨¡å‹ï¼ˆå‘åå…¼å®¹ï¼Œæœªè®¾ç½®æ—¶å›é€€åˆ° excerptOCRModelï¼‰
      excerptOCRModelForMode1: "doubao-seed-1-6",        // æ¨¡å¼1ï¼šç›´æ¥OCR
      excerptOCRModelForMode2: "Doc2X",                  // æ¨¡å¼2ï¼šMarkdownæ ¼å¼ï¼ˆDoc2Xä¸“ä¸ºæ•°å­¦å…¬å¼ä¼˜åŒ–ï¼‰
      excerptOCRModelForMode3: "doubao-seed-1-6",        // æ¨¡å¼3ï¼šæ¦‚å¿µæå–

      // å¡ç‰‡é¢„å¤„ç†æ¨¡å¼
      preProcessMode: false,  // æ˜¯å¦å¯ç”¨é¢„å¤„ç†æ¨¡å¼ï¼ˆé»˜è®¤å…³é—­ï¼‰
      classificationMode: false,  // å½’ç±»æ¨¡å¼
      classAutoPinMode: false,

      // ğŸ†• æœç´¢ç´¢å¼•æ¨¡å¼é…ç½®
      searchIndexMode: "light",  // ç´¢å¼•æ¨¡å¼: "light" (è½»é‡ï¼Œé»˜è®¤) æˆ– "full" (å…¨é‡ï¼Œå«åŒä¹‰è¯æ‰©å±•)
      lastIndexMode: "light",    // è®°å½•ä¸Šæ¬¡æ„å»ºçš„ç´¢å¼•æ¨¡å¼
      autoRebuildOnConfigChange: false,  // é…ç½®å˜æ›´æ—¶æ˜¯å¦è‡ªåŠ¨æç¤ºé‡å»ºç´¢å¼•

      // ğŸ†• è‡ªåŠ¨å…³é—­æ¨¡å¼
      autoCloseMode: true  // é»˜è®¤å¯ç”¨è‡ªåŠ¨å…³é—­ï¼ˆæœç´¢ç•Œé¢ï¼‰
    }
  }
  
  static getConfig(key){
    if (!this.config) {
      return false
    }
    if (this.config[key] !== undefined) {
      return this.config[key]
    }else{
      return this.defaultConfig[key]
    }
  }

  static init(mainPath) {
    if (mainPath) {
      this.mainPath = mainPath
    }

    this.config = this.getByDefault('MNKnowledgeBase_config', this.defaultConfig)
  }

  static getByDefault(key, defaultValue, backUpFile) { //è®°å¾—åœ¨removeä¸­å¢åŠ å¤‡ä»½æ–‡ä»¶çš„åˆ é™¤
    let value = NSUserDefaults.standardUserDefaults().objectForKey(key)
    if (value === undefined) {
      if (backUpFile && MNUtil.isfileExists(backUpFile)) { //éœ€è¦æ£€æŸ¥å¤‡ä»½æ–‡ä»¶
        let backupConfig = MNUtil.readJSON(backUpFile)
        if (backupConfig && Object.keys(backupConfig).length > 0) {
          MNUtil.log("backupConfig.readFromBackupFile")
          return backupConfig
        }
      }
      NSUserDefaults.standardUserDefaults().setObjectForKey(defaultValue, key)
      return defaultValue
    }
    return value
  }
  static get(key) {
    return NSUserDefaults.standardUserDefaults().objectForKey(key)
  }
  static save() {
    NSUserDefaults.standardUserDefaults().setObjectForKey(this.config, "MNKnowledgeBase_config")
  }

  /**
   * è·å–å½“å‰æœç´¢ç´¢å¼•æ¨¡å¼
   * @returns {string} "light" æˆ– "full"
   */
  static getSearchIndexMode() {
    return this.getConfig("searchIndexMode") || "light";
  }

  /**
   * è®¾ç½®æœç´¢ç´¢å¼•æ¨¡å¼
   * @param {string} mode - "light" æˆ– "full"
   */
  static setSearchIndexMode(mode) {
    if (mode !== "light" && mode !== "full") {
      MNUtil.showHUD("âŒ æ— æ•ˆçš„ç´¢å¼•æ¨¡å¼ï¼Œåªèƒ½æ˜¯ light æˆ– full");
      return;
    }
    this.config.searchIndexMode = mode;
    this.save();
  }

  /**
   * è®°å½•ä¸Šæ¬¡æ„å»ºçš„ç´¢å¼•æ¨¡å¼
   * @param {string} mode - "light" æˆ– "full"
   */
  static recordLastIndexMode(mode) {
    this.config.lastIndexMode = mode;
    this.save();
  }

  /**
   * è·å–è‡ªåŠ¨å…³é—­æ¨¡å¼
   * @returns {boolean}
   */
  static getAutoCloseMode() {
    return this.getConfig("autoCloseMode");
  }

  /**
   * è®¾ç½®è‡ªåŠ¨å…³é—­æ¨¡å¼
   * @param {boolean} enabled
   */
  static setAutoCloseMode(enabled) {
    this.config.autoCloseMode = enabled;
    this.save();
    MNUtil.log(`ã€KnowledgeBaseConfigã€‘autoCloseMode å·²ä¿å­˜: ${enabled}`);
  }

  /**
   * æ£€æŸ¥ç´¢å¼•æ¨¡å¼æ˜¯å¦æ”¹å˜
   * @returns {boolean} å¦‚æœå½“å‰é…ç½®çš„æ¨¡å¼ä¸ä¸Šæ¬¡æ„å»ºçš„ä¸åŒï¼Œè¿”å› true
   */
  static hasIndexModeChanged() {
    const currentMode = this.getSearchIndexMode();
    const lastMode = this.getConfig("lastIndexMode") || "light";
    return currentMode !== lastMode;
  }

  static remove(key) {
    NSUserDefaults.standardUserDefaults().removeObjectForKey(key)
  }
}

class HtmlMarkdownUtils {
  static icons = {
    // step: 'ğŸš©',
    // point: 'â–¸',
    // subpoint: 'â–ª',
    // subsubpoint: 'â€¢',
    level1: 'ğŸš©',
    level2: 'â–¸',
    level3: 'â–ª',
    level4: 'â€¢',
    level5: 'Â·',
    key: 'ğŸ”‘',
    alert: 'âš ï¸',
    danger: 'â—â—â—',
    remark: 'ğŸ“',
    goal: 'ğŸ¯',
    question: 'â“',
    idea: 'ğŸ’¡',
    method: 'âœ¨',
    check: 'ğŸ”',
    sketch: 'âœï¸',
    case: 'ğŸ“‹',
    step: 'ğŸ‘£',
  };
  static prefix = {
    danger: '',
    alert: '',
    key: '',
    // step: '',
    // point: '',
    // subpoint: '',
    // subsubpoint: '',
    level1: '',
    level2: '',
    level3: '',
    level4: '',
    level5: '',
    remark: '',
    goal: '',
    question: '',
    idea: 'æ€è·¯ï¼š',
    method: 'æ–¹æ³•ï¼š',
    check: 'CHECK',
    sketch: 'SKETCH',
    case: '',  // åºå·å°†åŠ¨æ€ç”Ÿæˆ
    step: '',  // åºå·å°†åŠ¨æ€ç”Ÿæˆ
  };
  static styles = {
    // æ ¼å¤–æ³¨æ„
    danger: 'font-weight:700;color:#6A0C0C;background:#FFC9C9;border-left:6px solid #A93226;font-size:1em;padding:8px 15px;display:inline-block;transform:skew(-3deg);box-shadow:2px 2px 5px rgba(0,0,0,0.1);',
    // æ³¨æ„
    alert: 'background:#FFF;color:#FF8C5A;border:2px solid currentColor;border-radius:3px;padding:6px 12px;font-weight:600;box-shadow:0 1px 3px rgba(255,140,90,0.2);display:inline-block;',
    // å…³é”®
    key: 'color: #B33F00;background: #FFF1E6;border-left: 6px solid #FF6B35;padding:16px 12px 1px;line-height:2;position:relative;top:6px;display:inline-block;font-family:monospace;margin-top:-2px;',
    level1: "font-weight:600;color:#1E40AF;background:linear-gradient(15deg,#EFF6FF 30%,#DBEAFE);border:2px solid #3B82F6;border-radius:12px;padding:10px 18px;display:inline-block;box-shadow:2px 2px 0px #BFDBFE,4px 4px 8px rgba(59,130,246,0.12);position:relative;margin:4px 8px;",
    level2: "font-weight:600;color:#4F79A3; background:linear-gradient(90deg,#F3E5F5 50%,#ede0f7);font-size:1.1em;padding:6px 12px;border-left:4px solid #7A9DB7;transform:skew(-1.5deg);box-shadow:1px 1px 3px rgba(0,0,0,0.05);margin-left:40px;position:relative;",
    level3: "font-weight:500;color:#7A9DB7;background:#E8F0FE;padding:4px 10px;border-radius:12px;border:1px solid #B3D4FF;font-size:0.95em;margin-left:80px;position:relative;",
    level4: "font-weight:400;color:#9DB7CA;background:#F8FBFF;padding:3px 8px;border-left:2px dashed #B3D4FF;font-size:0.9em;margin-left:120px;position:relative;",
    level5: "font-weight:300;color:#B3D4FF;background:#FFFFFF;padding:2px 6px;border-radius:8px;border:1px dashed #B3D4FF;font-size:0.85em;margin-left:160px;position:relative;",
    remark: 'background:#F5E6C9;color:#6d4c41;display:inline-block;border-left:5px solid #D4AF37;padding:2px 8px 3px 12px;border-radius:0 4px 4px 0;box-shadow:1px 1px 3px rgba(0,0,0,0.08);margin:0 2px;line-height:1.3;vertical-align:baseline;position:relative;',
    // ç›®æ ‡
    goal: 'font-weight:900;font-size:0.7em;color:#8B2635;background:linear-gradient(135deg,#F87171 0%,#FCA5A5 25%,#FECACA 60%,#FEF2F2 100%);padding:12px 24px;border-radius:50px;display:inline-block;position:relative;box-shadow:0 4px 8px rgba(248,113,113,0.25),inset 0 1px 0 rgba(255,255,255,0.5);text-shadow:0 1px 1px rgba(255,255,255,0.4);border:2px solid rgba(248,113,113,0.4);',
    // é—®é¢˜
    question: 'font-weight:700;color:#3D1A67;background:linear-gradient(15deg,#F8F4FF 30%,#F1E8FF);border:3px double #8B5CF6;border-radius:16px 4px 16px 4px;padding:14px 22px;display:inline-block;box-shadow:4px 4px 0px #DDD6FE,8px 8px 12px rgba(99,102,241,0.12);position:relative;margin:4px 8px;',
    // æ€è·¯
    idea: 'font-weight:600;color:#4A4EB2;background:linear-gradient(15deg,#F0F4FF 30%,#E6EDFF);border:2px dashed #7B7FD1;border-radius:12px;padding:10px 18px;display:inline-block;box-shadow:0 0 0 2px rgba(123,127,209,0.2),inset 0 0 10px rgba(123,127,209,0.1);position:relative;margin:4px 8px;',
    // æ–¹æ³•
    method: 'display:block;font-weight:700;color:#1B4332;background:linear-gradient(135deg,#74C69D 0%,#95D5B2 25%,#C7F0DB 60%,#E8F5E8 100%);font-size:1.3em;padding:12px 20px 12px 24px;border-left:10px solid #2D6A4F;margin:0 0 12px 0;border-radius:0 6px 6px 0;box-shadow:0 4px 12px rgba(116,198,157,0.2),inset 0 1px 0 rgba(255,255,255,0.5);text-shadow:0 1px 1px rgba(255,255,255,0.4);position:relative;',
    // æ£€æŸ¥
    check: 'font-weight:600;color:#34A853;background:#E6F7EE;border:2px solid #34A853;border-radius:4px;padding:4px 8px;display:inline-block;box-shadow:0 1px 2px rgba(52,168,83,0.2);margin:0 2px;line-height:1.3;vertical-align:baseline;position:relative;',
    // è‰ç¨¿/æ‰‹ç»˜
    sketch: 'background:transparent;color:#5D4037;display:inline-block;border-bottom:2px dotted #FF9800;padding:0 4px 2px;margin:0 2px;line-height:1.2;vertical-align:baseline;position:relative;font-size:0.9em;font-style:italic;',
    // æ¡ˆä¾‹
    case: 'font-weight:600;color:#2563EB;background:linear-gradient(135deg,#EFF6FF,#DBEAFE);border:2px solid #3B82F6;border-radius:8px;padding:8px 16px;display:inline-block;box-shadow:0 2px 4px rgba(37,99,235,0.2);margin:4px 0;',
    // æ­¥éª¤
    step: 'font-weight:500;color:#059669;background:#ECFDF5;border-left:4px solid #10B981;padding:6px 12px;display:inline-block;border-radius:0 4px 4px 0;margin:4px 0;',
  };
  // å®šä¹‰å³ä½¿å†…å®¹ä¸ºç©ºä¹Ÿè¦è¾“å‡ºçš„ç±»å‹ç™½åå•
  static emptyContentWhitelist = ['check', 'sketch'];
  
  static createHtmlMarkdownText(text, type = 'none') {
    // å¯¹äºç™½åå•ä¸­çš„ç±»å‹ï¼Œç‰¹æ®Šå¤„ç†
    if (this.emptyContentWhitelist.includes(type) && (!text || (typeof text === 'string' && text.trim() === ''))) {
      // å¯¹äºç™½åå•ç±»å‹ï¼Œå³ä½¿å†…å®¹ä¸ºç©ºä¹Ÿè¿”å›å®Œæ•´çš„ HTML
      return `<span id="${type}" style="${this.styles[type]} ">${this.icons[type]} ${this.prefix[type]}</span>`;
    }
    
    // å¤„ç† undefined æˆ– null çš„æƒ…å†µ
    if (!text) {
      if (type === 'none') {
        return '';
      } else {
        return '';
      }
    }
    
    let handledText = Pangu.spacing(text)
    if (type === 'none') {
      return text.trim();
    } else {
      // å¦‚æœå†…å®¹ä¸ºç©ºä¸”ç±»å‹ä¸åœ¨ç™½åå•ä¸­ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
      if (!handledText) {
        handledText = ' ';
        // switch (type) {
        //   case "sketch":
        //     handledText = ":"
        //     break;
        // }
      } else {
        switch (type) {
          case "sketch":
            handledText = ": " + handledText
            break;
        }
      }
      // é˜²å¾¡æ€§ç¼–ç¨‹ï¼šç¡®ä¿ icons å’Œ prefix ä¸ä¼šè¿”å› undefined
      const icon = this.icons[type] || '';
      const prefix = this.prefix[type] || '';
      const style = this.styles[type] || '';
      return `<span id="${type}" style="${style} ">${icon} ${prefix}${handledText}</span>`;
    }
  }

  /**
   * æ­£åˆ™åŒ¹é…è·å– span æ ‡ç­¾çš„å†…å®¹
   */
  static getSpanContent(comment) {
    let text
    switch (MNUtil.typeOf(comment)) {
      case "string":
        text = comment
        break;
      case "MNComment":
        text = comment.text?comment.text:""
        break;
    }
    const regex = /<span[^>]*>(.*?)<\/span>/;
    const match = text.match(regex);
    if (match && match[1]) {
      return match[1].trim();
    } else {
      return text;
    }
  }

  /**
   * æ­£åˆ™åŒ¹é…è·å– span æ ‡ç­¾çš„æ–‡æœ¬å†…å®¹ï¼ˆä¸å« emoji å’Œå‰ç¼€ï¼‰
   */
  static getSpanTextContent(comment) {
    let text
    switch (MNUtil.typeOf(comment)) {
      case "string":
        text = comment
        break;
      case "MNComment":
        text = comment.text?comment.text:""
        break;
    }
    const regex = /<span[^>]*>(.*?)<\/span>/;
    const match = text.match(regex);
    if (match && match[1]) {
      text = match[1].trim();
      // å»æ‰å›¾æ ‡
      Object.values(this.icons).forEach(icon => {
        text = text.replace(icon, '').trim();
      });
      // å»æ‰å‰ç¼€æ–‡æœ¬
      Object.values(this.prefix).forEach(prefix => {
        if (prefix && text.startsWith(prefix)) {
          text = text.substring(prefix.length).trim();
        }
      });
      return text
    } else {
      return text;
    }
  }

  /**
   * æ­£åˆ™åŒ¹é…è·å– span çš„ idï¼ˆç±»å‹ï¼‰
   */
  static getSpanType(comment) {
    let span
    switch (MNUtil.typeOf(comment)) {
      case "string":
        span = comment
        break;
      case "MNComment":
        span = comment.text?comment.text:""
        break;
    }
    const regex = /<span\s*id="([^"]*)"/;  // \s* å…è®¸0ä¸ªæˆ–å¤šä¸ªç©ºæ ¼ï¼Œä¿®å¤æ— æ³•åŒ¹é…è‡ªèº«ç”ŸæˆHTMLçš„Bug
    const match = span.match(regex);
    if (match && match[1]) {
      return match[1].trim();
    } else {
      return span;
    }
  }

  /**
   * è·å– idï¼ˆç±»å‹ï¼‰ å¾€ä¸‹ä¸€çº§çš„ç±»å‹
   */
  static getSpanNextLevelType(type) {
    const levelMap = {
      goal: 'level1',
      // step: 'point',
      // point: 'subpoint',
      // subpoint: 'subsubpoint',
      // subsubpoint: 'subsubpoint'
      level1: 'level2',
      level2: 'level3',
      level3: 'level4',
      level4: 'level5',
      level5: 'level5',
    };
    return levelMap[type] || undefined;
  }

  /**
   * è·å– idï¼ˆç±»å‹ï¼‰ å¾€ä¸Šä¸€çº§çš„ç±»å‹
   */
  static getSpanLastLevelType(type) {
    const levelMap = {
      // point: 'step',
      // subpoint: 'point',
      // subsubpoint: 'subpoint',
      // step: 'goal',
      goal: 'goal',
      level1: 'goal',
      level2: 'level1',
      level3: 'level2',
      level4: 'level3',
      level5: 'level4',
    };
    return levelMap[type] || undefined;
  }

  /**
   * æ˜¯å¦å±äºå¯å‡é™çº§ç±»å‹
   * 
   * é˜²æ­¢å¯¹ remark ç­‰ç±»å‹è¿›è¡Œå¤„ç†
   */
  static isLevelType(type) {
    // const levelTypes = ['goal', 'step', 'point', 'subpoint', 'subsubpoint'];
    const levelTypes = ['goal', 'level1', 'level2', 'level3', 'level4', 'level5',];
    return levelTypes.includes(type);
  }

  /**
   * è·å– note çš„ HtmlMD è¯„è®ºçš„ index å’Œç±»å‹
   */
  static getHtmlMDCommentIndexAndTypeObjArr(note) {
    let comments = note.MNComments
    let htmlMDCommentsObjArr = []
    comments.forEach(
      (comment, index) => {
        if (HtmlMarkdownUtils.isHtmlMDComment(comment)) {
          htmlMDCommentsObjArr.push(
            {
              index: index,
              type: this.getSpanType(comment.text)
            }
          )
        }
      }
    )
    return htmlMDCommentsObjArr
  }

  /**
   * åˆ¤å®šè¯„è®ºæ˜¯å¦æ˜¯ HtmlMD è¯„è®º
   */
  static isHtmlMDComment(comment) {
    let text
    switch (MNUtil.typeOf(comment)) {
      case "string":
        text = comment
        break;
      case "MNComment":
        text = comment.text?comment.text:""
        break;
    }
    if (text == undefined) {
      return false
    } else {
      return !!text.startsWith("<span")
    }
  }

  /**
   * å°† HtmlMD è¯„è®ºç±»å‹å˜æˆä¸‹ä¸€çº§
   */
  static changeHtmlMDCommentTypeToNextLevel(comment) {
    if (MNUtil.typeOf(comment) === "MNComment") {
      let content = this.getSpanTextContent(comment)
      let type = this.getSpanType(comment)
      if (HtmlMarkdownUtils.isHtmlMDComment(comment) && this.isLevelType(type)) {
        let nextLevelType = this.getSpanNextLevelType(type)
        comment.text = HtmlMarkdownUtils.createHtmlMarkdownText(content, nextLevelType)
      }
    }
  }

  /**
   * å°† HtmlMD è¯„è®ºç±»å‹å˜æˆä¸Šä¸€çº§
   */
  static changeHtmlMDCommentTypeToLastLevel(comment) {
    if (MNUtil.typeOf(comment) === "MNComment") {
      let content = this.getSpanTextContent(comment)
      let type = this.getSpanType(comment)
      if (HtmlMarkdownUtils.isHtmlMDComment(comment) && this.isLevelType(type)) {
        let lastLevelType = this.getSpanLastLevelType(type)
        comment.text = HtmlMarkdownUtils.createHtmlMarkdownText(content, lastLevelType)
      }
    }
  }


  /**
   * è·å–è¯„è®ºä¸­æœ€åä¸€ä¸ª HtmlMD è¯„è®º
   */
  static getLastHtmlMDComment(note) {
    let comments = note.MNComments
    let lastHtmlMDComment = undefined
    if (comments.length === 2 && comments[0] == undefined && comments[1] == undefined) {
      return false
    }
    comments.forEach(
      comment => {
        if (HtmlMarkdownUtils.isHtmlMDComment(comment)) {
          lastHtmlMDComment = comment
        }
      }
    )
    return lastHtmlMDComment
  }

  /**
   * åˆ¤æ–­æ˜¯å¦æœ‰ HtmlMD è¯„è®º
   */
  static hasHtmlMDComment(note) {
    return !!this.getLastHtmlMDComment(note)
  }

  /**
   * å¢åŠ åŒçº§è¯„è®º
   */
  static addSameLevelHtmlMDComment(note, text, type) {
    note.appendMarkdownComment(
      HtmlMarkdownUtils.createHtmlMarkdownText(text, type),
    )
  }

  /**
   * å¢åŠ ä¸‹ä¸€çº§è¯„è®º
   */
  static addNextLevelHtmlMDComment(note, text, type) {
    let nextLevelType = this.getSpanNextLevelType(type)
    if (nextLevelType) {
      note.appendMarkdownComment(
        HtmlMarkdownUtils.createHtmlMarkdownText(text, nextLevelType)
      )
    } else {
      note.appendMarkdownComment(
        HtmlMarkdownUtils.createHtmlMarkdownText(text, type)
      )
    }
  }

  /**
   * æ‰¹é‡è°ƒæ•´æ‰€æœ‰ HtmlMarkdown è¯„è®ºçš„å±‚çº§
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   * @param {string} direction - è°ƒæ•´æ–¹å‘ï¼š"up" è¡¨ç¤ºå±‚çº§ä¸Šç§»ï¼ˆlevel2->level1ï¼‰ï¼Œ"down" è¡¨ç¤ºå±‚çº§ä¸‹ç§»ï¼ˆlevel1->level2ï¼‰
   * @returns {number} è¿”å›è°ƒæ•´çš„è¯„è®ºæ•°é‡
   */
  static adjustAllHtmlMDLevels(note, direction = "up") {
    const comments = note.MNComments;
    let adjustedCount = 0;
    
    if (!comments || comments.length === 0) {
      MNUtil.showHUD("å½“å‰å¡ç‰‡æ²¡æœ‰è¯„è®º");
      return 0;
    }
    
    // éå†æ‰€æœ‰è¯„è®º
    comments.forEach((comment, index) => {
      if (!comment || !comment.text) return;
      
      // å¤„ç†å¯èƒ½çš„ "- " å‰ç¼€
      let hasLeadingDash = false;
      let cleanText = comment.text;
      if (cleanText.startsWith("- ")) {
        hasLeadingDash = true;
        cleanText = cleanText.substring(2);
      }
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯ HtmlMarkdown è¯„è®ºä¸”æ˜¯å±‚çº§ç±»å‹
      if (this.isHtmlMDComment(cleanText)) {
        const type = this.getSpanType(cleanText);
        const content = this.getSpanTextContent(cleanText);
        
        if (this.isLevelType(type)) {
          let newType;
          
          if (direction === "up") {
            // å±‚çº§ä¸Šç§»ï¼ˆæ•°å­—å˜å°ï¼‰
            newType = this.getSpanLastLevelType(type);
          } else if (direction === "down") {
            // å±‚çº§ä¸‹ç§»ï¼ˆæ•°å­—å˜å¤§ï¼‰
            newType = this.getSpanNextLevelType(type);
          } else {
            return;
          }
          
          // åªæœ‰å½“ç±»å‹çœŸçš„æ”¹å˜æ—¶æ‰æ›´æ–°
          if (newType && newType !== type) {
            const newHtmlText = this.createHtmlMarkdownText(content, newType);
            comment.text = hasLeadingDash ? "- " + newHtmlText : newHtmlText;
            adjustedCount++;
          }
        }
      }
    });
    
    if (adjustedCount > 0) {
      MNUtil.showHUD(`å·²è°ƒæ•´ ${adjustedCount} ä¸ªå±‚çº§è¯„è®º`);
    } else {
      MNUtil.showHUD("æ²¡æœ‰å¯è°ƒæ•´çš„å±‚çº§è¯„è®º");
    }
    
    return adjustedCount;
  }

  /**
   * æ ¹æ®æŒ‡å®šçš„æœ€é«˜çº§åˆ«è°ƒæ•´æ‰€æœ‰å±‚çº§
   * 
   * @param {MNNote} note - è¦å¤„ç†çš„å¡ç‰‡
   * @param {string} targetHighestLevel - ç›®æ ‡æœ€é«˜çº§åˆ«ï¼ˆå¦‚ "goal", "level1", "level2" ç­‰ï¼‰
   * @returns {number} è¿”å›è°ƒæ•´çš„è¯„è®ºæ•°é‡
   */
  static adjustHtmlMDLevelsByHighest(note, targetHighestLevel) {
    const comments = note.MNComments;
    if (!comments || comments.length === 0) {
      MNUtil.showHUD("å½“å‰å¡ç‰‡æ²¡æœ‰è¯„è®º");
      return 0;
    }
    
    // å®šä¹‰å±‚çº§é¡ºåºï¼ˆä»é«˜åˆ°ä½ï¼‰
    const levelOrder = ['goal', 'level1', 'level2', 'level3', 'level4', 'level5'];
    const targetIndex = levelOrder.indexOf(targetHighestLevel);
    
    if (targetIndex === -1) {
      MNUtil.showHUD("æ— æ•ˆçš„ç›®æ ‡å±‚çº§");
      return 0;
    }
    
    // ç¬¬ä¸€éæ‰«æï¼šæ‰¾å‡ºå½“å‰æœ€é«˜å±‚çº§
    let currentHighestLevel = null;
    let currentHighestIndex = levelOrder.length;
    
    // æ”¶é›†æ‰€æœ‰å±‚çº§ç±»å‹çš„è¯„è®ºä¿¡æ¯
    const levelComments = [];
    
    comments.forEach((comment, index) => {
      if (!comment || !comment.text) return;
      
      let cleanText = comment.text;
      let hasLeadingDash = false;
      
      if (cleanText.startsWith("- ")) {
        hasLeadingDash = true;
        cleanText = cleanText.substring(2);
      }
      
      if (this.isHtmlMDComment(cleanText)) {
        const type = this.getSpanType(cleanText);
        
        if (this.isLevelType(type)) {
          const levelIndex = levelOrder.indexOf(type);
          if (levelIndex !== -1) {
            levelComments.push({
              comment: comment,
              index: index,
              type: type,
              levelIndex: levelIndex,
              content: this.getSpanTextContent(cleanText),
              hasLeadingDash: hasLeadingDash
            });
            
            // æ›´æ–°å½“å‰æœ€é«˜å±‚çº§
            if (levelIndex < currentHighestIndex) {
              currentHighestIndex = levelIndex;
              currentHighestLevel = type;
            }
          }
        }
      }
    });
    
    if (levelComments.length === 0) {
      MNUtil.showHUD("æ²¡æœ‰æ‰¾åˆ°å±‚çº§ç±»å‹çš„è¯„è®º");
      return 0;
    }
    
    // è®¡ç®—åç§»é‡
    const offset = targetIndex - currentHighestIndex;
    
    if (offset === 0) {
      MNUtil.showHUD(`æœ€é«˜å±‚çº§å·²ç»æ˜¯ ${targetHighestLevel}`);
      return 0;
    }
    
    // ç¬¬äºŒéï¼šæ ¹æ®åç§»é‡è°ƒæ•´æ‰€æœ‰å±‚çº§
    let adjustedCount = 0;
    
    levelComments.forEach(item => {
      const newLevelIndex = Math.max(0, Math.min(levelOrder.length - 1, item.levelIndex + offset));
      const newType = levelOrder[newLevelIndex];
      
      if (newType !== item.type) {
        const newHtmlText = this.createHtmlMarkdownText(item.content, newType);
        item.comment.text = item.hasLeadingDash ? "- " + newHtmlText : newHtmlText;
        adjustedCount++;
      }
    });
    
    if (adjustedCount > 0) {
      const direction = offset > 0 ? "ä¸‹ç§»" : "ä¸Šç§»";
      MNUtil.showHUD(`å·²å°†æœ€é«˜å±‚çº§è°ƒæ•´ä¸º ${targetHighestLevel}ï¼Œå…±${direction} ${Math.abs(offset)} çº§ï¼Œè°ƒæ•´äº† ${adjustedCount} ä¸ªè¯„è®º`);
    }
    
    return adjustedCount;
  }

  /**
   * å¢åŠ ä¸Šä¸€çº§è¯„è®º
   */
  static addLastLevelHtmlMDComment(note, text, type) {
    let lastLevelType = this.getSpanLastLevelType(type)
    if (lastLevelType) {
      note.appendMarkdownComment(
        HtmlMarkdownUtils.createHtmlMarkdownText(text, lastLevelType)
      )
    } else {
      note.appendMarkdownComment(
        HtmlMarkdownUtils.createHtmlMarkdownText(text, type)
      )
    }
  }

  /**
   * è‡ªåŠ¨æ ¹æ®æœ€åä¸€ä¸ª HtmlMD è¯„è®ºçš„ç±»å‹å¢åŠ  Level ç±»å‹è¯„è®º
   */
  static autoAddLevelHtmlMDComment(note, text, goalLevel = "same") {
    let lastHtmlMDComment = this.getLastHtmlMDComment(note)
    if (lastHtmlMDComment) {
      let lastHtmlMDCommentType = this.getSpanType(lastHtmlMDComment.text)
      switch (goalLevel) {
        case "same":
          this.addSameLevelHtmlMDComment(note, text, lastHtmlMDCommentType)
          break;
        case "next":
          this.addNextLevelHtmlMDComment(note, text, lastHtmlMDCommentType)
          break;
        case "last":
          this.addLastLevelHtmlMDComment(note, text, lastHtmlMDCommentType)
          break
        default: 
          MNUtil.showHUD("No goalLevel: " + goalLevel)
          break;
      }
    } else {
      // å¦‚æœæ²¡æœ‰ HtmlMD è¯„è®ºï¼Œå°±æ·»åŠ ä¸€ä¸ªä¸€çº§
      note.appendMarkdownComment(
        HtmlMarkdownUtils.createHtmlMarkdownText(text, 'goal')
      )
    }
  }

  // è§£æå¼€å¤´çš„è¿å­—ç¬¦æ•°é‡
  static parseLeadingDashes(str) {
    let count = 0;
    let index = 0;
    const maxDashes = 5;
    
    while (count < maxDashes && index < str.trim().length) {
      if (str[index] === '-') {
        count++;
        index++;
        // è·³è¿‡åç»­ç©ºæ ¼
        while (index < str.length && (str[index] === ' ' || str[index] === '\t')) {
          index++;
        }
      } else {
        break;
      }
    }
    
    return {
      count: count > 0 ? Math.min(count, maxDashes) : 0,
      remaining: str.slice(index).trim()
    };
  }

  /**
   * æ£€æŸ¥ç¬”è®°çš„åä»£ä¸­æ˜¯å¦æœ‰ä»»ä½•å­å¡ç‰‡åŒ…å«æ ‡é¢˜
   * @param {MNNote} rootFocusNote è¦æ£€æŸ¥çš„æ ¹ç¬”è®°
   * @returns {boolean} å¦‚æœæœ‰ä»»ä½•åä»£åŒ…å«æ ‡é¢˜è¿”å› trueï¼Œå¦åˆ™è¿”å› false
   */
  static hasDescendantWithTitle(rootFocusNote) {
      try {
          const nodesData = rootFocusNote.descendantNodes;
          if (!nodesData || !nodesData.descendant) {
              return false;
          }
          
          const allDescendants = nodesData.descendant;
          const treeIndex = nodesData.treeIndex;
          
          // è¿‡æ»¤æ‰çŸ¥è¯†ç‚¹å¡ç‰‡å’Œå½’ç±»å¡ç‰‡çš„åˆ†æ”¯
          const excludedBranchRoots = new Set();
          
          if (rootFocusNote.childNotes && rootFocusNote.childNotes.length > 0) {
              rootFocusNote.childNotes.forEach(childNote => {
                  if (KnowledgeBaseTemplate.isClassificationNote(childNote) || KnowledgeBaseTemplate.isKnowledgeNote(childNote)) {
                      excludedBranchRoots.add(childNote.noteId);
                  }
              });
          }
          
          // æ£€æŸ¥æ¯ä¸ªåä»£èŠ‚ç‚¹
          for (let i = 0; i < allDescendants.length; i++) {
              const node = allDescendants[i];
              const nodeTreeIndex = treeIndex[i];
              
              // è·³è¿‡è¢«æ’é™¤çš„åˆ†æ”¯
              if (nodeTreeIndex.length > 0 && excludedBranchRoots.size > 0) {
                  const directChildIndex = nodeTreeIndex[0];
                  const directChild = rootFocusNote.childNotes[directChildIndex];
                  if (directChild && excludedBranchRoots.has(directChild.noteId)) {
                      continue;
                  }
              }
              
              // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦æœ‰æ ‡é¢˜
              let hasTitle = false;
              if (typeof node.title === 'string') {
                  let titleContent = "";
                  if (typeof node.title.toNoBracketPrefixContent === 'function') {
                      titleContent = node.title.toNoBracketPrefixContent();
                  } else if (HtmlMarkdownUtils.isHtmlMDComment(node.title)) {
                      titleContent = HtmlMarkdownUtils.getSpanTextContent(node.title);
                  } else {
                      titleContent = node.title;
                  }
                  
                  if (titleContent.trim()) {
                      hasTitle = true;
                  }
              }
              
              if (hasTitle) {
                  return true;
              }
          }
          
          return false;
      } catch (error) {
        MNLog.error(error, "æ£€æŸ¥åä»£æ ‡é¢˜æ—¶å‡ºé”™");
        return false;
      }
  }

  /**
   * æ‰§è¡Œå‘ä¸Šåˆå¹¶æ“ä½œï¼Œå°†è¢«èšç„¦ç¬”è®°çš„åä»£ç¬”è®°åˆå¹¶åˆ°å…¶è‡ªèº«ã€‚
   * å­ç¬”è®°çš„æ ‡é¢˜ä¼šä½œä¸ºå¸¦æ ·å¼çš„ã€ç‹¬ç«‹çš„è¯„è®ºæ·»åŠ åˆ°å®ƒä»¬å„è‡ªçš„ç›´æ¥çˆ¶ç¬”è®°ä¸­ï¼Œ
   * ç„¶åå­ç¬”è®°ï¼ˆæ¸…ç©ºæ ‡é¢˜åï¼‰çš„ç»“æ„å†…å®¹å†åˆå¹¶åˆ°çˆ¶ç¬”è®°ã€‚
   *
   * @param {MNNote} rootFocusNote è¦å¤„ç†çš„ä¸»ç¬”è®°ï¼Œå…¶åä»£ç¬”è®°å°†è¢«å‘ä¸Šåˆå¹¶åˆ°æ­¤ç¬”è®°ä¸­ã€‚
   * @param {string} [firstLevelType] rootFocusNote ç›´æ¥å­ç¬”è®°çš„ HtmlMarkdownUtils ç±»å‹ (ä¾‹å¦‚ï¼š'goal', 'level1')ã€‚å¦‚æœä¸æä¾›ï¼Œå°†è·³è¿‡æ ‡é¢˜æ ·å¼åŒ–æ­¥éª¤ã€‚
   */
  static upwardMergeWithStyledComments(rootFocusNote, firstLevelType) {
      // ç¡®ä¿ MNUtil å’Œ HtmlMarkdownUtils åœ¨å½“å‰ä½œç”¨åŸŸä¸­å¯ç”¨
      if (typeof MNUtil === 'undefined' || typeof HtmlMarkdownUtils === 'undefined') {
          MNUtil.error("MNUtil æˆ– HtmlMarkdownUtils æœªå®šä¹‰ã€‚");
          if (typeof MNUtil !== 'undefined' && typeof MNUtil.showHUD === 'function') {
              MNUtil.showHUD("é”™è¯¯ï¼šæ‰¾ä¸åˆ°å¿…è¦çš„å·¥å…·åº“ã€‚", 2);
          }
          return;
      }

      // 1. API åç§°æ›´æ­£ï¼šä½¿ç”¨å±æ€§è®¿é—® rootFocusNote.descendantNodes
      let allDescendants, treeIndex;
      try {
          // å‡è®¾ descendantNodes æ˜¯ä¸€ä¸ªç›´æ¥è¿”å›æ‰€éœ€å¯¹è±¡çš„å±æ€§
          const nodesData = rootFocusNote.descendantNodes;
          if (!nodesData || typeof nodesData.descendant === 'undefined' || typeof nodesData.treeIndex === 'undefined') {
              throw new Error("descendantNodes å±æ€§æœªè¿”å›é¢„æœŸçš„ {descendant, treeIndex} å¯¹è±¡ç»“æ„ã€‚");
          }
          allDescendants = nodesData.descendant;
          treeIndex = nodesData.treeIndex;
      } catch (e) {
          MNUtil.error("æ— æ³•è·å–åä»£ç¬”è®°ã€‚è¯·ç¡®ä¿ rootFocusNote.descendantNodes å±æ€§å­˜åœ¨ä¸”èƒ½æ­£ç¡®è¿”å›æ•°æ®ã€‚", e);
          MNUtil.showHUD("é”™è¯¯ï¼šæ— æ³•è·å–åä»£ç¬”è®°æ•°æ®ã€‚", 2);
          return;
      }

      if (!allDescendants || allDescendants.length === 0) {
          MNUtil.showHUD("æ²¡æœ‰å¯åˆå¹¶çš„åä»£ç¬”è®°ã€‚", 2);
          return;
      }

      // è¿‡æ»¤æ‰çŸ¥è¯†ç‚¹å¡ç‰‡å’Œå½’ç±»å¡ç‰‡çš„åˆ†æ”¯
      // é¦–å…ˆæ‰¾å‡ºæ‰€æœ‰éœ€è¦æ’é™¤çš„åˆ†æ”¯æ ¹èŠ‚ç‚¹ï¼ˆç›´æ¥å­èŠ‚ç‚¹ï¼‰
      const excludedBranchRoots = new Set();
      
      // æ£€æŸ¥ç›´æ¥å­èŠ‚ç‚¹
      if (rootFocusNote.childNotes && rootFocusNote.childNotes.length > 0) {
          rootFocusNote.childNotes.forEach(childNote => {
              // åˆ¤æ–­å­å¡ç‰‡æ˜¯å¦æ˜¯å½’ç±»å¡ç‰‡æˆ–çŸ¥è¯†ç‚¹å¡ç‰‡ï¼ˆä»…æ£€æŸ¥å¡ç‰‡è‡ªèº«ï¼Œä¸å‘ä¸ŠæŸ¥æ‰¾ï¼‰
              if (KnowledgeBaseTemplate.isClassificationNote(childNote) || KnowledgeBaseTemplate.isKnowledgeNote(childNote)) {
                  excludedBranchRoots.add(childNote.noteId);
              }
          });
      }
      
      // å¦‚æœæœ‰éœ€è¦æ’é™¤çš„åˆ†æ”¯ï¼Œè¿‡æ»¤æ‰è¿™äº›åˆ†æ”¯çš„æ‰€æœ‰èŠ‚ç‚¹
      if (excludedBranchRoots.size > 0) {
          const filteredDescendants = [];
          const filteredTreeIndex = [];
          
          for (let i = 0; i < allDescendants.length; i++) {
              const node = allDescendants[i];
              const nodeTreeIndex = treeIndex[i];
              
              // treeIndex[0] æ˜¯ç›´æ¥å­èŠ‚ç‚¹åœ¨ childNotes ä¸­çš„ç´¢å¼•
              if (nodeTreeIndex.length > 0) {
                  const directChildIndex = nodeTreeIndex[0];
                  const directChild = rootFocusNote.childNotes[directChildIndex];
                  
                  // å¦‚æœè¿™ä¸ªèŠ‚ç‚¹ä¸å±äºè¢«æ’é™¤çš„åˆ†æ”¯ï¼Œåˆ™ä¿ç•™
                  if (directChild && !excludedBranchRoots.has(directChild.noteId)) {
                      filteredDescendants.push(node);
                      filteredTreeIndex.push(nodeTreeIndex);
                  }
              }
          }
          
          // æ›´æ–°ä¸ºè¿‡æ»¤åçš„æ•°ç»„
          allDescendants = filteredDescendants;
          treeIndex = filteredTreeIndex;
          
          // å¦‚æœè¿‡æ»¤åæ²¡æœ‰èŠ‚ç‚¹äº†ï¼Œæç¤ºå¹¶è¿”å›
          if (allDescendants.length === 0) {
              MNUtil.showHUD("æ‰€æœ‰å­å¡ç‰‡éƒ½æ˜¯çŸ¥è¯†ç‚¹æˆ–å½’ç±»å¡ç‰‡ï¼Œæ— æ³•åˆå¹¶ã€‚", 2);
              return;
          }
      }

      const nodesWithInfo = allDescendants.map((node, i) => ({
          node: node,
          level: treeIndex[i].length // ç›¸å¯¹äº rootFocusNote å­ç¬”è®°çš„æ·±åº¦ (1 ä»£è¡¨ç›´æ¥å­ç¬”è®°)
      }));

      let maxLevel = 0;
      if (nodesWithInfo.length > 0) {
          maxLevel = Math.max(...nodesWithInfo.map(item => item.level));
      }

      // (ç§»é™¤ aggregatedRawTextFromChildren Mapï¼Œå› ä¸ºä¸å†éœ€è¦å‘ä¸Šèšåˆæ ‡é¢˜æ–‡æœ¬)

      /**
       * æ ¹æ®ç¬”è®°åœ¨ treeIndex ä¸­çš„å±‚çº§ï¼ˆç›¸å¯¹äº rootFocusNote å­ç¬”è®°çš„æ·±åº¦ï¼‰
       * å’Œç¬¬ä¸€å±‚å­ç¬”è®°çš„åˆå§‹ç±»å‹ï¼Œæ¥ç¡®å®šè¯¥ç¬”è®°çš„ HtmlMarkdownUtils ç±»å‹ã€‚
       * @param {number} level - ç¬”è®°çš„å±‚çº§ (1 ä»£è¡¨ rootFocusNote çš„ç›´æ¥å­ç¬”è®°)
       * @param {string} initialTypeForLevel1 - ç¬¬ä¸€å±‚å­ç¬”è®°çš„åˆå§‹ç±»å‹
       * @returns {string} - è®¡ç®—å¾—åˆ°çš„ HtmlMarkdownUtils ç±»å‹
       */
      function getNodeTypeForTreeIndexLevel(level, initialTypeForLevel1) {
          // ä»…åœ¨æä¾›äº† initialTypeForLevel1 æ—¶æ‰æ‰§è¡Œ
          if (!initialTypeForLevel1) {
              return null;
          }
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯å±‚çº§ç±»å‹ï¼ˆgoal, level1-5ï¼‰
          if (HtmlMarkdownUtils.isLevelType(initialTypeForLevel1)) {
              // åŸæœ‰é€»è¾‘ï¼šå±‚çº§ç±»å‹æŒ‰åŸè§„åˆ™é€’å‡
              let currentType = initialTypeForLevel1;
              if (level === 1) {
                  return currentType;
              }
              for (let i = 1; i < level; i++) {
                  const nextType = HtmlMarkdownUtils.getSpanNextLevelType(currentType);
                  if (!nextType || nextType === currentType) {
                      return currentType;
                  }
                  currentType = nextType;
              }
              return currentType;
          } else {
              // æ–°é€»è¾‘ï¼šéå±‚çº§ç±»å‹ï¼ˆå¦‚ method, idea, question ç­‰ï¼‰
              if (level === 1) {
                  // ç¬¬ä¸€å±‚ä½¿ç”¨æŒ‡å®šçš„éå±‚çº§ç±»å‹
                  return initialTypeForLevel1;
              } else {
                  // ä»ç¬¬äºŒå±‚å¼€å§‹ï¼Œä½¿ç”¨ level1 å¹¶æŒ‰å±‚çº§é€’å‡
                  let currentType = 'level1';
                  // æ³¨æ„ï¼šlevel æ˜¯ä» 1 å¼€å§‹çš„ï¼Œlevel=2 è¡¨ç¤ºç¬¬äºŒå±‚
                  for (let i = 2; i < level; i++) {
                      const nextType = HtmlMarkdownUtils.getSpanNextLevelType(currentType);
                      if (!nextType || nextType === currentType) {
                          return currentType;
                      }
                      currentType = nextType;
                  }
                  return currentType;
              }
          }
      }

      // ä»æœ€æ·±å±‚çº§å¼€å§‹ï¼Œé€å±‚å‘ä¸Šå¤„ç†
      for (let currentTreeIndexLevel = maxLevel; currentTreeIndexLevel >= 1; currentTreeIndexLevel--) {
          const nodesAtThisLevel = nodesWithInfo.filter(item => item.level === currentTreeIndexLevel);

          for (const item of nodesAtThisLevel) {
              const currentNode = item.node;
              const parentNode = currentNode.parentNote;

              if (!parentNode) {
                  MNUtil.error(`å±‚çº§ ${currentTreeIndexLevel} çš„ç¬”è®° ${currentNode.id || '(æ— ID)'} æ²¡æœ‰çˆ¶ç¬”è®°ã€‚å·²è·³è¿‡ã€‚`);
                  continue;
              }
              if (parentNode.id !== rootFocusNote.id && !allDescendants.some(d => d.id === parentNode.id)) {
                  MNUtil.warn(`ç¬”è®° ${currentNode.id} çš„çˆ¶ç¬”è®° ${parentNode.id} ä¸åœ¨ rootFocusNote åä»£ç¬”è®°çš„åˆå¹¶èŒƒå›´å†…ã€‚å·²è·³è¿‡æ­¤ç¬”è®°çš„åˆå¹¶ã€‚`);
                  continue;
              }

              // 1. ä»…åœ¨æä¾›äº† firstLevelType æ—¶ç¡®å®šç±»å‹
              let typeForCurrentNodeTitleInParentComment;
              if (firstLevelType) {
                  // ç¡®å®š currentNode çš„æ ‡é¢˜åœ¨æ·»åŠ åˆ° parentNode çš„è¯„è®ºä¸­æ—¶åº”é‡‡ç”¨çš„ 'type'ã€‚
                  // è¿™ä¸ª type æ˜¯åŸºäº currentNode ç›¸å¯¹äº rootFocusNote çš„æ·±åº¦æ¥å†³å®šçš„ã€‚
                  typeForCurrentNodeTitleInParentComment = getNodeTypeForTreeIndexLevel(currentTreeIndexLevel, firstLevelType);
              }

              // 2. å‡†å¤‡æ¥è‡ª currentNode æ ‡é¢˜çš„åŸå§‹æ–‡æœ¬å†…å®¹ã€‚
              let rawTextFromTitle;
              if (typeof currentNode.title === 'string') {
                  if (typeof currentNode.title.toNoBracketPrefixContent === 'function') { // æ‚¨æåˆ°çš„ç‰¹å®šæ–¹æ³•
                      rawTextFromTitle = currentNode.title.toNoBracketPrefixContent();
                  } else if (HtmlMarkdownUtils.isHtmlMDComment(currentNode.title)) {
                      rawTextFromTitle = HtmlMarkdownUtils.getSpanTextContent(currentNode.title);
                  } else {
                      rawTextFromTitle = currentNode.title;
                  }
              } else {
                  rawTextFromTitle = "";
              }
              rawTextFromTitle = rawTextFromTitle.trim();

              // 3. å¦‚æœæä¾›äº† firstLevelTypeï¼Œå°†æ ‡é¢˜è½¬æ¢ä¸ºå¸¦æ ·å¼çš„è¯„è®º
              if (firstLevelType) {
                  // å°† currentNode çš„ rawTextFromTitle (åŸå§‹æ ‡é¢˜æ–‡æœ¬) ä½œä¸ºä¸€ä¸ªæ–°çš„å¸¦æ ·å¼çš„è¯„è®ºæ·»åŠ åˆ° parentNodeã€‚
                  // è¯„è®ºçš„ç±»å‹ç”± currentNode è‡ªèº«çš„å±‚çº§å†³å®šã€‚
                  if (rawTextFromTitle) { // ä»…å½“æ ‡é¢˜æœ‰å†…å®¹æ—¶æ‰æ·»åŠ è¯„è®º
                      // HtmlMarkdownUtils.addSameLevelHtmlMDComment(parentNode, rawTextFromTitle, typeForCurrentNodeTitleInParentComment);
                      // æˆ–è€…ï¼Œå¦‚æœæ›´å€¾å‘äºç›´æ¥ä½¿ç”¨ appendMarkdownComment:
                      if (typeof parentNode.appendMarkdownComment === 'function') {
                          // æ£€æŸ¥æ˜¯å¦æ˜¯éœ€è¦åºå·çš„ç±»å‹ï¼ˆcase, stepï¼‰
                          const numberedTypes = ['case', 'step'];
                          let commentHtml;

                          if (numberedTypes.includes(typeForCurrentNodeTitleInParentComment)) {
                              // ä½¿ç”¨å¸¦åºå·çš„åˆ›å»ºæ–¹æ³•
                              commentHtml = HtmlMarkdownUtils.createNumberedHtmlText(
                                  rawTextFromTitle,
                                  typeForCurrentNodeTitleInParentComment,
                                  null,  // number å‚æ•°ä¸º nullï¼Œè‡ªåŠ¨è®¡ç®—
                                  parentNode  // ä¼ å…¥ parentNode ç”¨äºè‡ªåŠ¨è®¡ç®—åºå·
                              );
                          } else {
                              // ä½¿ç”¨æ™®é€šåˆ›å»ºæ–¹æ³•
                              commentHtml = HtmlMarkdownUtils.createHtmlMarkdownText(
                                  rawTextFromTitle,
                                  typeForCurrentNodeTitleInParentComment
                              );
                          }

                          parentNode.appendMarkdownComment(commentHtml);
                      } else {
                          MNUtil.warn(`parentNode ${parentNode.id} ä¸Šæœªæ‰¾åˆ° appendMarkdownComment æ–¹æ³•ã€‚`);
                      }
                  }

                  // 4. æ¸…ç©º currentNode çš„æ ‡é¢˜ã€‚
                  if (typeof currentNode.setTitle === 'function') {
                      currentNode.setTitle("");
                  } else {
                      currentNode.title = "";
                  }
              }

              // 5. æ‰§è¡Œ currentNodeï¼ˆç°åœ¨å·²æ— æ ‡é¢˜ï¼Œä½†åŒ…å«å…¶åŸæœ‰è¯„è®ºã€å­èŠ‚ç‚¹ç­‰ï¼‰åˆ° parentNode çš„ç»“æ„æ€§åˆå¹¶ã€‚
              if (typeof currentNode.mergeInto === 'function') {
                  currentNode.mergeInto(parentNode);
              } else {
                  MNUtil.warn(`ç¬”è®° ${currentNode.id || '(æ— ID)'} ä¸Šæœªæ‰¾åˆ° mergeInto æ–¹æ³•ã€‚ç»“æ„æ€§åˆå¹¶å·²è·³è¿‡ã€‚`);
              }
          }
      }
      
      rootFocusNote.focusInMindMap(0.5);
  }


  /**
   * é€šè¿‡å¼¹çª—é€‰æ‹©å­—æ®µå¹¶å°†å…¶å†…å®¹è½¬æ¢ä¸º HtmlMarkdown è¯„è®º
   * @param {MNNote} note - è¦æ“ä½œçš„ç¬”è®°
   */
  static convertFieldContentToHtmlMDByPopup(note) {
    let htmlCommentsTextArr = KnowledgeBaseTemplate.parseNoteComments(note).htmlCommentsTextArr;
    
    if (htmlCommentsTextArr.length === 0) {
      MNUtil.showHUD("å½“å‰ç¬”è®°æ²¡æœ‰å­—æ®µ");
      return;
    }

    // åœ¨å­—æ®µåˆ—è¡¨å‰æ·»åŠ ç‰¹æ®Šé€‰é¡¹
    htmlCommentsTextArr.unshift("ğŸ“‹ ä»æ‰€æœ‰è¯„è®ºä¸­é€‰æ‹©");

    // ç¬¬ä¸€ä¸ªå¼¹çª—ï¼šé€‰æ‹©å­—æ®µ
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©è¦è½¬æ¢å†…å®¹çš„å­—æ®µ",
      "è¯·é€‰æ‹©ä¸€ä¸ªå­—æ®µï¼Œå°†å…¶å†…å®¹è½¬æ¢ä¸º HtmlMarkdown æ ¼å¼",
      0,
      "å–æ¶ˆ",
      htmlCommentsTextArr,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
        
        if (buttonIndex === 1) {
          // ç”¨æˆ·é€‰æ‹©äº†"ä»æ‰€æœ‰è¯„è®ºä¸­é€‰æ‹©"
          let contents = this.getAllNonHtmlMDContents(note);
          
          if (contents.length === 0) {
            MNUtil.showHUD("æ²¡æœ‰å¯è½¬æ¢çš„å†…å®¹");
            return;
          }
          
          // ç›´æ¥æ˜¾ç¤ºå†…å®¹é€‰æ‹©å¼¹çª—
          this.showFieldContentSelectionPopup(note, contents, "æ‰€æœ‰è¯„è®º");
        } else {
          // åŸæœ‰é€»è¾‘ï¼šé€‰æ‹©äº†ç‰¹å®šå­—æ®µ
          let selectedField = htmlCommentsTextArr[buttonIndex - 2]; // å› ä¸ºæ·»åŠ äº†ä¸€ä¸ªé€‰é¡¹ï¼Œç´¢å¼•è¦å‡2
          let contents = this.getFieldNonHtmlMDContents(note, selectedField);
          
          if (contents.length === 0) {
            MNUtil.showHUD("è¯¥å­—æ®µä¸‹æ²¡æœ‰å¯è½¬æ¢çš„å†…å®¹");
            return;
          }
          
          // æ˜¾ç¤ºå†…å®¹é€‰æ‹©å¼¹çª—
          this.showFieldContentSelectionPopup(note, contents, selectedField);
        }
      }
    );
  }

  /**
   * è·å–æŒ‡å®šå­—æ®µä¸‹çš„é HtmlMarkdown å†…å®¹
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} fieldName - å­—æ®µåç§°
   * @returns {Array} åŒ…å«å†…å®¹ä¿¡æ¯çš„æ•°ç»„
   */
  static getFieldNonHtmlMDContents(note, fieldName) {
    let commentsObj = KnowledgeBaseTemplate.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    
    // æ‰¾åˆ°å¯¹åº”å­—æ®µ
    let fieldObj = htmlCommentsObjArr.find(obj => obj.text.includes(fieldName));
    if (!fieldObj) return [];
    
    let contents = [];
    let excludingIndices = fieldObj.excludingFieldBlockIndexArr;
    
    excludingIndices.forEach(index => {
      let comment = note.MNComments[index];
      
      // åªå¤„ç†æ–‡æœ¬è¯„è®ºå’Œ Markdown è¯„è®ºï¼ˆé HtmlMarkdownï¼‰
      if (comment.type === "textComment" || 
          (comment.type === "markdownComment" && !HtmlMarkdownUtils.isHtmlMDComment(comment.text))) {
        
        let text = comment.text || "";
        let displayText = text;
        let hasLeadingDash = false;
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ "- " å‰ç¼€
        if (text.startsWith("- ")) {
          hasLeadingDash = true;
          displayText = text; // æ˜¾ç¤ºæ—¶ä¿ç•™ "- "
        }
        
        contents.push({
          index: index,
          text: text,
          displayText: displayText,
          type: comment.type,
          hasLeadingDash: hasLeadingDash
        });
      }
    });
    
    return contents;
  }

  /**
   * è·å–æ‰€æœ‰è¯„è®ºä¸­çš„é HtmlMarkdown å†…å®¹
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @returns {Array} åŒ…å«æ‰€æœ‰å¯è½¬æ¢å†…å®¹çš„æ•°ç»„
   */
  static getAllNonHtmlMDContents(note) {
    let contents = [];
    let comments = note.MNComments;
    
    comments.forEach((comment, index) => {
      // åªå¤„ç†æ–‡æœ¬è¯„è®ºå’Œé HtmlMarkdown çš„ Markdown è¯„è®º
      if (comment.type === "textComment" || 
          (comment.type === "markdownComment" && !HtmlMarkdownUtils.isHtmlMDComment(comment.text))) {
        
        let text = comment.text || "";
        let displayText = text;
        let hasLeadingDash = false;
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ "- " å‰ç¼€
        if (text.startsWith("- ")) {
          hasLeadingDash = true;
          displayText = text; // æ˜¾ç¤ºæ—¶ä¿ç•™ "- "
        }
        
        // æ·»åŠ å­—æ®µä¿¡æ¯ä»¥ä¾¿ç”¨æˆ·è¯†åˆ«
        let fieldInfo = this.getCommentFieldInfo(note, index);
        if (fieldInfo) {
          displayText = `[${fieldInfo}] ${displayText}`;
        }
        
        contents.push({
          index: index,
          text: text,
          displayText: displayText,
          type: comment.type,
          hasLeadingDash: hasLeadingDash,
          fieldName: fieldInfo
        });
      }
    });
    
    return contents;
  }

  /**
   * è·å–è¯„è®ºæ‰€å±çš„å­—æ®µä¿¡æ¯
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {number} commentIndex - è¯„è®ºç´¢å¼•
   * @returns {string|null} å­—æ®µåç§°ï¼Œå¦‚æœä¸å±äºä»»ä½•å­—æ®µåˆ™è¿”å› null
   */
  static getCommentFieldInfo(note, commentIndex) {
    let commentsObj = KnowledgeBaseTemplate.parseNoteComments(note);
    let htmlCommentsObjArr = commentsObj.htmlCommentsObjArr;
    
    // éå†æ‰€æœ‰å­—æ®µï¼Œæ‰¾åˆ°åŒ…å«è¯¥è¯„è®ºçš„å­—æ®µ
    for (let fieldObj of htmlCommentsObjArr) {
      if (fieldObj.excludingFieldBlockIndexArr.includes(commentIndex)) {
        return fieldObj.text;
      }
    }
    
    return null; // ä¸å±äºä»»ä½•å­—æ®µ
  }

  /**
   * æ˜¾ç¤ºå†…å®¹é€‰æ‹©å¼¹çª—
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Array} contents - å¯è½¬æ¢çš„å†…å®¹æ•°ç»„
   * @param {string} fieldName - å­—æ®µåç§°
   */
  static showFieldContentSelectionPopup(note, contents, fieldName) {
    // å‡†å¤‡æ˜¾ç¤ºé€‰é¡¹
    let options = contents.map((content, idx) => {
      return `${idx + 1}. ${content.displayText.substring(0, 50)}${content.displayText.length > 50 ? '...' : ''}`;
    });
    
    // æ·»åŠ å¤šé€‰å’Œå…¨éƒ¨è½¬æ¢é€‰é¡¹
    options.unshift("âœ… å¤šé€‰å†…å®¹");
    options.unshift("è½¬æ¢å…¨éƒ¨å†…å®¹");
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©è¦è½¬æ¢çš„å†…å®¹",
      `å­—æ®µ"${fieldName}"ä¸‹å…±æœ‰ ${contents.length} æ¡å¯è½¬æ¢å†…å®¹`,
      0,
      "å–æ¶ˆ",
      options,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
        
        let selectedContents = [];
        
        if (buttonIndex === 1) {
          // é€‰æ‹©äº†"è½¬æ¢å…¨éƒ¨å†…å®¹"
          selectedContents = contents;
          // æ˜¾ç¤ºç±»å‹é€‰æ‹©å¼¹çª—
          this.showTypeSelectionPopup(note, selectedContents);
        } else if (buttonIndex === 2) {
          // é€‰æ‹©äº†"å¤šé€‰å†…å®¹"
          let selectedIndices = new Set();
          this.showFieldContentMultiSelectDialog(note, contents, fieldName, selectedIndices);
        } else {
          // é€‰æ‹©äº†å•ä¸ªå†…å®¹
          selectedContents = [contents[buttonIndex - 3]]; // å› ä¸ºå¢åŠ äº†ä¸¤ä¸ªé€‰é¡¹ï¼Œæ‰€ä»¥ç´¢å¼•è¦å‡3
          // æ˜¾ç¤ºç±»å‹é€‰æ‹©å¼¹çª—
          this.showTypeSelectionPopup(note, selectedContents);
        }
      }
    );
  }

  /**
   * æ˜¾ç¤ºå†…å®¹å¤šé€‰å¯¹è¯æ¡†
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Array} contents - æ‰€æœ‰å¯è½¬æ¢çš„å†…å®¹
   * @param {string} fieldName - å­—æ®µåç§°
   * @param {Set} selectedIndices - å·²é€‰ä¸­çš„ç´¢å¼•é›†åˆ
   */
  static showFieldContentMultiSelectDialog(note, contents, fieldName, selectedIndices) {
    // æ„å»ºæ˜¾ç¤ºé€‰é¡¹
    let displayOptions = contents.map((content, idx) => {
      let prefix = selectedIndices.has(content.index) ? "âœ… " : "";
      let displayText = content.displayText.substring(0, 50) + (content.displayText.length > 50 ? '...' : '');
      return prefix + `${idx + 1}. ${displayText}`;
    });
    
    // æ·»åŠ å…¨é€‰/å–æ¶ˆå…¨é€‰é€‰é¡¹
    let allSelected = selectedIndices.size === contents.length;
    let selectAllText = allSelected ? "â¬œ å–æ¶ˆå…¨é€‰" : "â˜‘ï¸ å…¨é€‰æ‰€æœ‰å†…å®¹";
    displayOptions.unshift(selectAllText);
    
    // æ·»åŠ åˆ†éš”çº¿å’Œæ“ä½œé€‰é¡¹
    displayOptions.push("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    displayOptions.push("â¡ï¸ è½¬æ¢é€‰ä¸­å†…å®¹");
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      `å¤šé€‰å†…å®¹ - ${fieldName}`,
      `å·²é€‰ä¸­ ${selectedIndices.size}/${contents.length} é¡¹`,
      0,
      "å–æ¶ˆ",
      displayOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
        
        if (buttonIndex === 1) {
          // ç”¨æˆ·é€‰æ‹©äº†å…¨é€‰/å–æ¶ˆå…¨é€‰
          if (allSelected) {
            // å–æ¶ˆå…¨é€‰
            selectedIndices.clear();
          } else {
            // å…¨é€‰
            contents.forEach((content) => {
              selectedIndices.add(content.index);
            });
          }
          
          // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
          this.showFieldContentMultiSelectDialog(note, contents, fieldName, selectedIndices);
          
        } else if (buttonIndex === displayOptions.length) {
          // ç”¨æˆ·é€‰æ‹©äº†"è½¬æ¢é€‰ä¸­å†…å®¹"
          if (selectedIndices.size === 0) {
            MNUtil.showHUD("æ²¡æœ‰é€‰ä¸­ä»»ä½•å†…å®¹");
            this.showFieldContentMultiSelectDialog(note, contents, fieldName, selectedIndices);
            return;
          }
          
          // è·å–é€‰ä¸­çš„å†…å®¹
          let selectedContents = [];
          contents.forEach(content => {
            if (selectedIndices.has(content.index)) {
              selectedContents.push(content);
            }
          });
          
          // æ˜¾ç¤ºç±»å‹é€‰æ‹©å¼¹çª—
          this.showTypeSelectionPopup(note, selectedContents);
          
        } else if (buttonIndex === displayOptions.length - 1) {
          // ç”¨æˆ·é€‰æ‹©äº†åˆ†éš”çº¿ï¼Œå¿½ç•¥å¹¶é‡æ–°æ˜¾ç¤º
          this.showFieldContentMultiSelectDialog(note, contents, fieldName, selectedIndices);
          
        } else {
          // ç”¨æˆ·é€‰æ‹©äº†æŸä¸ªå†…å®¹ï¼Œåˆ‡æ¢é€‰ä¸­çŠ¶æ€
          let selectedContent = contents[buttonIndex - 2]; // å› ä¸ºåŠ äº†å…¨é€‰é€‰é¡¹ï¼Œæ‰€ä»¥ç´¢å¼•è¦å‡2
          
          if (selectedIndices.has(selectedContent.index)) {
            selectedIndices.delete(selectedContent.index);
          } else {
            selectedIndices.add(selectedContent.index);
          }
          
          // é€’å½’æ˜¾ç¤ºæ›´æ–°åçš„å¯¹è¯æ¡†
          this.showFieldContentMultiSelectDialog(note, contents, fieldName, selectedIndices);
        }
      }
    );
  }

  /**
   * æ˜¾ç¤ºç±»å‹é€‰æ‹©å¼¹çª—
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Array} contents - è¦è½¬æ¢çš„å†…å®¹æ•°ç»„
   */
  static showTypeSelectionPopup(note, contents) {
    // å®šä¹‰å¯é€‰çš„ç±»å‹
    let typeOptions = [
      "goal - ğŸ¯ ç›®æ ‡",
      "level1 - ğŸš© ä¸€çº§",
      "level2 - â–¸ äºŒçº§",
      "level3 - â–ª ä¸‰çº§",
      "level4 - â€¢ å››çº§",
      "level5 - Â· äº”çº§",
      "key - ğŸ”‘ å…³é”®",
      "alert - âš ï¸ è­¦å‘Š",
      "danger - â—â—â— å±é™©",
      "remark - ğŸ“ å¤‡æ³¨",
      "question - â“ é—®é¢˜",
      "idea - ğŸ’¡ æƒ³æ³•",
      "method - âœ¨ æ–¹æ³•"
    ];
    
    UIAlertView.showWithTitleMessageStyleCancelButtonTitleOtherButtonTitlesTapBlock(
      "é€‰æ‹©è½¬æ¢ç±»å‹",
      "è¯·é€‰æ‹©è¦è½¬æ¢æˆçš„ HtmlMarkdown ç±»å‹",
      0,
      "å–æ¶ˆ",
      typeOptions,
      (alert, buttonIndex) => {
        if (buttonIndex === 0) return; // ç”¨æˆ·å–æ¶ˆ
        
        // æå–ç±»å‹å
        let selectedType = typeOptions[buttonIndex - 1].split(" - ")[0];
        
        // æ‰§è¡Œè½¬æ¢
        this.convertContentsToHtmlMD(note, contents, selectedType);
      }
    );
  }

  /**
   * æ‰§è¡Œå†…å®¹è½¬æ¢
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {Array} contents - è¦è½¬æ¢çš„å†…å®¹æ•°ç»„
   * @param {string} type - ç›®æ ‡ç±»å‹
   */
  static convertContentsToHtmlMD(note, contents, type) {
    MNUtil.undoGrouping(() => {
      // æŒ‰ç´¢å¼•ä»å¤§åˆ°å°æ’åºï¼Œé¿å…åˆ é™¤æ—¶ç´¢å¼•å˜åŒ–
      let sortedContents = contents.sort((a, b) => b.index - a.index);
      
      sortedContents.forEach(content => {
        let textToConvert = content.text;
        
        // å¦‚æœæœ‰ "- " å‰ç¼€ï¼Œå»æ‰å®ƒ
        if (content.hasLeadingDash) {
          textToConvert = textToConvert.substring(2).trim();
        }
        
        // åˆ›å»º HtmlMarkdown æ–‡æœ¬
        let htmlMdText = HtmlMarkdownUtils.createHtmlMarkdownText(textToConvert, type);
        
        // è·å–åŸè¯„è®º
        let comment = note.MNComments[content.index];
        
        // æ›¿æ¢åŸè¯„è®ºçš„æ–‡æœ¬
        if (comment) {
          comment.text = htmlMdText;
        }
      });
      
      // åˆ·æ–°ç¬”è®°æ˜¾ç¤º
      note.refresh();
    });
    
    MNUtil.showHUD(`æˆåŠŸè½¬æ¢ ${contents.length} æ¡å†…å®¹`);
  }

  /**
   * æ™ºèƒ½æ·»åŠ ç©ºæ ¼
   * åœ¨ä¸­æ–‡å’Œè‹±æ–‡/æ•°å­—ä¹‹é—´æ·»åŠ ç©ºæ ¼
   * @param {string} text - è¦å¤„ç†çš„æ–‡æœ¬
   * @returns {string} å¤„ç†åçš„æ–‡æœ¬
   */

  /**
   * åˆ›å»ºç­‰ä»·è¯æ˜æ–‡æœ¬
   * @param {string} propositionA - å‘½é¢˜ A
   * @param {string} propositionB - å‘½é¢˜ B
   * @returns {Object} åŒ…å«ä¸¤ä¸ªæ–¹å‘è¯æ˜çš„å¯¹è±¡
   */
  static createEquivalenceProof(propositionA, propositionB) {
    // å¤„ç†ç©ºæ ¼
    const spacedA = this.smartSpacing(propositionA);
    const spacedB = this.smartSpacing(propositionB);
    
    // ç”Ÿæˆä¸¤ä¸ªæ–¹å‘çš„è¯æ˜ï¼ˆçº¯æ–‡æœ¬æ ¼å¼ï¼‰
    const proofAtoB = `è‹¥ ${spacedA} æˆç«‹ï¼Œåˆ™ ${spacedB} æˆç«‹`;
    const proofBtoA = `è‹¥ ${spacedB} æˆç«‹ï¼Œåˆ™ ${spacedA} æˆç«‹`;
    const equivalence = `${spacedA} â‡” ${spacedB}`;
    
    return {
      proofAtoB,
      proofBtoA,
      equivalence,
      fullProof: [equivalence, proofAtoB, proofBtoA]
    };
  }

  /**
   * é€šè¿‡å¼¹çª—è¾“å…¥åˆ›å»ºç­‰ä»·è¯æ˜ï¼ˆä½¿ç”¨æ¨¡æ¿é€‰æ‹©ï¼‰
   * @param {MNNote} note - ç›®æ ‡ç¬”è®°
   */
  
  /**
   * é€šç”¨çš„è¯æ˜æ·»åŠ å…¥å£
   * @param {MNNote} note - ç›®æ ‡ç¬”è®°
   */

  // ==================== è¯æ˜æ¨¡æ¿ç®¡ç†ç³»ç»Ÿ ====================
  
  /**
   * åˆå§‹åŒ–è¯æ˜æ¨¡æ¿é…ç½®
   */

  /**
   * ä»å­˜å‚¨åŠ è½½è¯æ˜æ¨¡æ¿é…ç½®
   */

  /**
   * è·å–é»˜è®¤è¯æ˜æ¨¡æ¿é…ç½®
   */

  /**
   * ä¿å­˜è¯æ˜æ¨¡æ¿é…ç½®
   */

  /**
   * è·å–æ‰€æœ‰è¯æ˜æ¨¡æ¿
   */
  
  /**
   * è·å–æ‰€æœ‰å¯ç”¨çš„è¯æ˜æ¨¡æ¿
   */
  
  /**
   * æ”¶é›†è¯æ˜è¾“å…¥æ•°æ®
   * @param {Object} template - é€‰ä¸­çš„æ¨¡æ¿
   * @returns {Object|null} è¾“å…¥æ•°æ®å¯¹è±¡æˆ–nullï¼ˆå¦‚æœå–æ¶ˆï¼‰
   */
  
  /**
   * æ˜¾ç¤ºè¾“å…¥å¯¹è¯æ¡†
   * @param {string} title - å¯¹è¯æ¡†æ ‡é¢˜
   * @param {string} message - å¯¹è¯æ¡†æ¶ˆæ¯
   * @param {string} confirmText - ç¡®è®¤æŒ‰é’®æ–‡æœ¬
   * @returns {Promise<string|null>} è¾“å…¥æ–‡æœ¬æˆ–nullï¼ˆå¦‚æœå–æ¶ˆï¼‰
   */
  
  /**
   * ä½¿ç”¨æ¨¡æ¿ç”Ÿæˆè¯æ˜å†…å®¹
   * @param {Object} template - è¯æ˜æ¨¡æ¿
   * @param {Object} inputs - è¾“å…¥æ•°æ®
   * @returns {Object} ç”Ÿæˆçš„è¯æ˜å†…å®¹
   */
  static generateProofFromTemplate(template, inputs) {
    const result = {
      mainContent: null,
      forwardProof: null,
      reverseProof: null
    };
    
    // æ›¿æ¢å ä½ç¬¦
    const replacePlaceholders = (text) => {
      if (!text) return "";
      const valueA = inputs.A || "";
      const valueB = inputs.B || "";
      return text.replace(/\{A\}/g, this.smartSpacing(valueA))
                 .replace(/\{B\}/g, this.smartSpacing(valueB));
    };
    
    // ç”Ÿæˆä¸»è¦å†…å®¹ï¼ˆæ ¹æ®æ¨¡æ¿ç±»å‹ï¼‰- çº¯æ–‡æœ¬æ ¼å¼
    if (template.type === "equivalence") {
      const spacedA = this.smartSpacing(inputs.A || "");
      const spacedB = this.smartSpacing(inputs.B || "");
      if (spacedA && spacedB) {
        result.mainContent = `${spacedA} â‡” ${spacedB}`;
      }
    } else if (template.type === "implication") {
      const spacedA = this.smartSpacing(inputs.A || "");
      const spacedB = this.smartSpacing(inputs.B || "");
      if (spacedA && spacedB) {
        result.mainContent = `${spacedA} â‡’ ${spacedB}`;
      }
    }
    
    // ç”Ÿæˆæ­£å‘è¯æ˜ï¼ˆçº¯æ–‡æœ¬æ ¼å¼ï¼‰
    if (template.forwardTemplate) {
      const forwardText = replacePlaceholders(template.forwardTemplate);
      result.forwardProof = forwardText;
    }
    
    // ç”Ÿæˆåå‘è¯æ˜ï¼ˆçº¯æ–‡æœ¬æ ¼å¼ï¼‰
    if (template.reverseTemplate) {
      const reverseText = replacePlaceholders(template.reverseTemplate);
      result.reverseProof = reverseText;
    }
    
    return result;
  }
  
  /**
   * å°†è¯æ˜å†…å®¹æ·»åŠ åˆ°ç¬”è®°
   * @param {MNNote} note - ç›®æ ‡ç¬”è®°
   * @param {Object} template - ä½¿ç”¨çš„æ¨¡æ¿
   * @param {Object} proof - ç”Ÿæˆçš„è¯æ˜å†…å®¹
   */

  /**
   * æ·»åŠ è¯æ˜æ¨¡æ¿
   */

  /**
   * æ›´æ–°è¯æ˜æ¨¡æ¿
   */

  /**
   * åˆ é™¤è¯æ˜æ¨¡æ¿
   */

  /**
   * è¯æ˜æ¨¡æ¿ç®¡ç† - ä¸»ç•Œé¢
   */

  /**
   * ç¼–è¾‘è¯æ˜æ¨¡æ¿å¯¹è¯æ¡†
   */

  /**
   * æ·»åŠ è¯æ˜æ¨¡æ¿å¯¹è¯æ¡†
   */

  /**
   * æ˜¾ç¤ºæ–‡æœ¬è¾“å…¥å¯¹è¯æ¡†
   */

  /**
   * å¯¼å‡ºè¯æ˜æ¨¡æ¿é…ç½®
   */

  /**
   * å¯¼å…¥è¯æ˜æ¨¡æ¿é…ç½®
   */

  /**
   * ========== Case/Step å¸¦åºå·è¯„è®ºåŠŸèƒ½ ==========
   */

  /**
   * è·å–ç¬”è®°ä¸­æŸç±»å‹çš„ä¸‹ä¸€ä¸ªåºå·
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} typePrefix - ç±»å‹å‰ç¼€ï¼Œå¦‚ "Case", "Step" ç­‰
   * @returns {number} ä¸‹ä¸€ä¸ªå¯ç”¨çš„åºå·
   */
  static getNextNumberForType(note, typePrefix) {
    const pattern = new RegExp(`${typePrefix}\\s*(\\d+)`, 'gi');
    let maxNumber = 0;

    // éå†æ‰€æœ‰è¯„è®ºæŸ¥æ‰¾æœ€å¤§åºå·
    const comments = note.comments || note.MNComments || [];
    for (const comment of comments) {
      if (comment && comment.text) {
        const matches = [...comment.text.matchAll(pattern)];
        for (const match of matches) {
          const num = parseInt(match[1]);
          if (num > maxNumber) maxNumber = num;
        }
      }
    }

    return maxNumber + 1;
  }

  /**
   * åˆ›å»ºå¸¦åºå·çš„ HTML æ–‡æœ¬
   * @param {string} text - å†…å®¹æ–‡æœ¬
   * @param {string} type - ç±»å‹ï¼ˆå¦‚ 'case', 'step'ï¼‰
   * @param {number} number - åºå·ï¼ˆå¯é€‰ï¼Œä¸æä¾›åˆ™è‡ªåŠ¨è®¡ç®—ï¼‰
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡ï¼ˆç”¨äºè‡ªåŠ¨è®¡ç®—åºå·ï¼‰
   * @returns {string} æ ¼å¼åŒ–åçš„ HTML æ–‡æœ¬
   */
  static createNumberedHtmlText(text, type, number, note) {
    // æ”¯æŒçš„å¸¦åºå·ç±»å‹é…ç½®
    const numberedTypes = {
      'case': { prefix: 'Case', icon: 'ğŸ“‹' },
      'step': { prefix: 'Step', icon: 'ğŸ‘£' },
    };

    // å¦‚æœä¸æ˜¯å¸¦åºå·çš„ç±»å‹ï¼Œä½¿ç”¨åŸæœ‰æ–¹æ³•
    if (!numberedTypes[type]) {
      return this.createHtmlMarkdownText(text, type);
    }

    const config = numberedTypes[type];

    // å¦‚æœæ²¡æœ‰æä¾›åºå·ï¼Œè‡ªåŠ¨è®¡ç®—
    if (!number && note) {
      number = this.getNextNumberForType(note, config.prefix);
    }

    // å¦‚æœè¿˜æ˜¯æ²¡æœ‰åºå·ï¼Œé»˜è®¤ä¸º 1
    if (!number) {
      number = 1;
    }

    // æ„å»ºå¸¦åºå·çš„æ–‡æœ¬
    const formattedText = `${config.prefix} ${number}: ${typeof Pangu !== 'undefined' ? Pangu.spacing(text) : text}`;

    // ä½¿ç”¨å¯¹åº”çš„æ ·å¼
    const style = this.styles[type] || '';
    const icon = this.icons[type] || config.icon;

    return `<span id="${type}" style="${style}">${icon} ${formattedText}</span>`;
  }

  /**
   * æ·»åŠ å¸¦åºå·çš„ Case è¯„è®º
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} text - è¯„è®ºå†…å®¹
   * @param {number} customNumber - è‡ªå®šä¹‰åºå·ï¼ˆå¯é€‰ï¼‰
   * @returns {number} ä½¿ç”¨çš„åºå·
   */
  static addCaseComment(note, text, customNumber) {
    const number = customNumber || this.getNextNumberForType(note, 'Case');
    const htmlText = this.createNumberedHtmlText(text, 'case', number, note);
    note.appendMarkdownComment(htmlText);
    return number;
  }

  /**
   * æ·»åŠ å¸¦åºå·çš„ Step è¯„è®º
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} text - è¯„è®ºå†…å®¹
   * @param {number} customNumber - è‡ªå®šä¹‰åºå·ï¼ˆå¯é€‰ï¼‰
   * @returns {number} ä½¿ç”¨çš„åºå·
   */
  static addStepComment(note, text, customNumber) {
    const number = customNumber || this.getNextNumberForType(note, 'Step');
    const htmlText = this.createNumberedHtmlText(text, 'step', number, note);
    note.appendMarkdownComment(htmlText);
    return number;
  }

  /**
   * é€šç”¨çš„æ·»åŠ å¸¦åºå·è¯„è®ºæ–¹æ³•
   * @param {MNNote} note - ç¬”è®°å¯¹è±¡
   * @param {string} text - è¯„è®ºå†…å®¹
   * @param {string} type - ç±»å‹ï¼ˆ'case', 'step' ç­‰ï¼‰
   * @param {number} customNumber - è‡ªå®šä¹‰åºå·ï¼ˆå¯é€‰ï¼‰
   * @returns {number} ä½¿ç”¨çš„åºå·
   */
  static addNumberedComment(note, text, type, customNumber) {
    // è·å–ç±»å‹å¯¹åº”çš„å‰ç¼€
    const numberedTypes = {
      'case': 'Case',
      'step': 'Step'
    };

    const prefix = numberedTypes[type];
    if (!prefix) {
      // å¦‚æœä¸æ˜¯å¸¦åºå·çš„ç±»å‹ï¼Œä½¿ç”¨æ™®é€šæ–¹æ³•
      note.appendMarkdownComment(this.createHtmlMarkdownText(text, type));
      return null;
    }

    const number = customNumber || this.getNextNumberForType(note, prefix);
    const htmlText = this.createNumberedHtmlText(text, type, number, note);
    note.appendMarkdownComment(htmlText);
    return number;
  }
}



// https://github.com/vinta/pangu.js
// CJK is short for Chinese, Japanese, and Korean.
//
// CJK includes following Unicode blocks:
// \u2e80-\u2eff CJK Radicals Supplement
// \u2f00-\u2fdf Kangxi Radicals
// \u3040-\u309f Hiragana
// \u30a0-\u30ff Katakana
// \u3100-\u312f Bopomofo
// \u3200-\u32ff Enclosed CJK Letters and Months
// \u3400-\u4dbf CJK Unified Ideographs Extension A
// \u4e00-\u9fff CJK Unified Ideographs
// \uf900-\ufaff CJK Compatibility Ideographs
//
// For more information about Unicode blocks, see
// http://unicode-table.com/en/
// https://github.com/vinta/pangu
//
// all J below does not include \u30fb
const CJK =
  "\u2e80-\u2eff\u2f00-\u2fdf\u3040-\u309f\u30a0-\u30fa\u30fc-\u30ff\u3100-\u312f\u3200-\u32ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff"
// ANS is short for Alphabets, Numbers, and Symbols.
//
// A includes A-Za-z\u0370-\u03ff
// N includes 0-9
// S includes `~!@#$%^&*()-_=+[]{}\|;:'",<.>/?
//
// some S below does not include all symbols
// the symbol part only includes ~ ! ; : , . ? but . only matches one character
const CONVERT_TO_FULLWIDTH_CJK_SYMBOLS_CJK = new RegExp(
  `([${CJK}])[ ]*([\\:]+|\\.)[ ]*([${CJK}])`,
  "g"
)
const CONVERT_TO_FULLWIDTH_CJK_SYMBOLS = new RegExp(
  `([${CJK}])[ ]*([~\\!;,\\?]+)[ ]*`,
  "g"
)
const DOTS_CJK = new RegExp(`([\\.]{2,}|\u2026)([${CJK}])`, "g")
const FIX_CJK_COLON_ANS = new RegExp(`([${CJK}])\\:([A-Z0-9\\(\\)])`, "g")
// the symbol part does not include '
const CJK_QUOTE = new RegExp(`([${CJK}])([\`"\u05f4])`, "g")
const QUOTE_CJK = new RegExp(`([\`"\u05f4])([${CJK}])`, "g")
const FIX_QUOTE_ANY_QUOTE = /([`"\u05f4]+)[ ]*(.+?)[ ]*([`"\u05f4]+)/g
const CJK_SINGLE_QUOTE_BUT_POSSESSIVE = new RegExp(`([${CJK}])('[^s])`, "g")
const SINGLE_QUOTE_CJK = new RegExp(`(')([${CJK}])`, "g")
const FIX_POSSESSIVE_SINGLE_QUOTE = new RegExp(
  `([A-Za-z0-9${CJK}])( )('s)`,
  "g"
)
const HASH_ANS_CJK_HASH = new RegExp(
  `([${CJK}])(#)([${CJK}]+)(#)([${CJK}])`,
  "g"
)
const CJK_HASH = new RegExp(`([${CJK}])(#([^ ]))`, "g")
const HASH_CJK = new RegExp(`(([^ ])#)([${CJK}])`, "g")
// the symbol part only includes + - * / = & | < >
const CJK_OPERATOR_ANS = new RegExp(
  `([${CJK}])([\\+\\-\\*\\/=&\\|<>])([A-Za-z0-9])`,
  "g"
)
const ANS_OPERATOR_CJK = new RegExp(
  `([A-Za-z0-9])([\\+\\-\\*\\/=&\\|<>])([${CJK}])`,
  "g"
)
const FIX_SLASH_AS = /([/]) ([a-z\-_\./]+)/g
const FIX_SLASH_AS_SLASH = /([/\.])([A-Za-z\-_\./]+) ([/])/g
// the bracket part only includes ( ) [ ] { } < > â€œ â€
const CJK_LEFT_BRACKET = new RegExp(`([${CJK}])([\\(\\[\\{<>\u201c])`, "g")
const RIGHT_BRACKET_CJK = new RegExp(`([\\)\\]\\}<>\u201d])([${CJK}])`, "g")
const FIX_LEFT_BRACKET_ANY_RIGHT_BRACKET =
  /([\(\[\{<\u201c]+)[ ]*(.+?)[ ]*([\)\]\}>\u201d]+)/
const ANS_CJK_LEFT_BRACKET_ANY_RIGHT_BRACKET = new RegExp(
  `([A-Za-z0-9${CJK}])[ ]*([\u201c])([A-Za-z0-9${CJK}\\-_ ]+)([\u201d])`,
  "g"
)
const LEFT_BRACKET_ANY_RIGHT_BRACKET_ANS_CJK = new RegExp(
  `([\u201c])([A-Za-z0-9${CJK}\\-_ ]+)([\u201d])[ ]*([A-Za-z0-9${CJK}])`,
  "g"
)
const AN_LEFT_BRACKET = /([A-Za-z0-9])([\(\[\{])/g
const RIGHT_BRACKET_AN = /([\)\]\}])([A-Za-z0-9])/g
const CJK_ANS = new RegExp(
  `([${CJK}])([A-Za-z\u0370-\u03ff0-9@\\$%\\^&\\*\\-\\+\\\\=\\|/\u00a1-\u00ff\u2150-\u218f\u2700â€”\u27bf])`,
  "g"
)
const ANS_CJK = new RegExp(
  `([A-Za-z\u0370-\u03ff0-9~\\$%\\^&\\*\\-\\+\\\\=\\|/!;:,\\.\\?\u00a1-\u00ff\u2150-\u218f\u2700â€”\u27bf])([${CJK}])`,
  "g"
)
const S_A = /(%)([A-Za-z])/g
const MIDDLE_DOT = /([ ]*)([\u00b7\u2022\u2027])([ ]*)/g
const BACKSAPCE_CJK = new RegExp(`([${CJK}]) ([${CJK}])`, "g")
const SUBSCRIPT_CJK = /([\u2080-\u2099])(?=[\u4e00-\u9fa5])/g
// ä¸Šæ ‡ https://rupertshepherd.info/resource_pages/superscript-letters-in-unicode
const SUPERSCRIPT_CJK = /([\u2070-\u209F\u1D56\u1D50\u207F\u1D4F\u1D57])(?=[\u4e00-\u9fa5])/g
// ç‰¹æ®Šå­—ç¬¦
// \u221E: âˆ
const SPECIAL = /([\u221E])(?!\s|[\(\[])/g  // (?!\s) æ˜¯ä¸ºäº†å½“åé¢æ²¡æœ‰ç©ºæ ¼æ‰åŠ ç©ºæ ¼ï¼Œé˜²æ­¢å‡ºç°å¤šä¸ªç©ºæ ¼
class Pangu {
  version
  static convertToFullwidth(symbols) {
    return symbols
      .replace(/~/g, "ï½")
      .replace(/!/g, "ï¼")
      .replace(/;/g, "ï¼›")
      .replace(/:/g, "ï¼š")
      .replace(/,/g, "ï¼Œ")
      .replace(/\./g, "ã€‚")
      .replace(/\?/g, "ï¼Ÿ")
  }
  static toFullwidth(text) {
    let newText = text
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const that = this
    newText = newText.replace(
      CONVERT_TO_FULLWIDTH_CJK_SYMBOLS_CJK,
      (match, leftCjk, symbols, rightCjk) => {
        const fullwidthSymbols = that.convertToFullwidth(symbols)
        return `${leftCjk}${fullwidthSymbols}${rightCjk}`
      }
    )
    newText = newText.replace(
      CONVERT_TO_FULLWIDTH_CJK_SYMBOLS,
      (match, cjk, symbols) => {
        const fullwidthSymbols = that.convertToFullwidth(symbols)
        return `${cjk}${fullwidthSymbols}`
      }
    )
    return newText
  }
  static spacing(text) {
    let newText = text
    // https://stackoverflow.com/questions/4285472/multiple-regex-replace
    newText = newText.replace(DOTS_CJK, "$1 $2")
    newText = newText.replace(FIX_CJK_COLON_ANS, "$1ï¼š$2")
    newText = newText.replace(CJK_QUOTE, "$1 $2")
    newText = newText.replace(QUOTE_CJK, "$1 $2")
    newText = newText.replace(FIX_QUOTE_ANY_QUOTE, "$1$2$3")
    newText = newText.replace(CJK_SINGLE_QUOTE_BUT_POSSESSIVE, "$1 $2")
    newText = newText.replace(SINGLE_QUOTE_CJK, "$1 $2")
    newText = newText.replace(FIX_POSSESSIVE_SINGLE_QUOTE, "$1's") // eslint-disable-line quotes
    newText = newText.replace(HASH_ANS_CJK_HASH, "$1 $2$3$4 $5")
    newText = newText.replace(CJK_HASH, "$1 $2")
    newText = newText.replace(HASH_CJK, "$1 $3")
    newText = newText.replace(CJK_OPERATOR_ANS, "$1 $2 $3")
    newText = newText.replace(ANS_OPERATOR_CJK, "$1 $2 $3")
    newText = newText.replace(FIX_SLASH_AS, "$1$2")
    newText = newText.replace(FIX_SLASH_AS_SLASH, "$1$2$3")
    newText = newText.replace(CJK_LEFT_BRACKET, "$1 $2")
    newText = newText.replace(RIGHT_BRACKET_CJK, "$1 $2")
    newText = newText.replace(FIX_LEFT_BRACKET_ANY_RIGHT_BRACKET, "$1$2$3")
    newText = newText.replace(
      ANS_CJK_LEFT_BRACKET_ANY_RIGHT_BRACKET,
      "$1 $2$3$4"
    )
    newText = newText.replace(
      LEFT_BRACKET_ANY_RIGHT_BRACKET_ANS_CJK,
      "$1$2$3 $4"
    )
    newText = newText.replace(AN_LEFT_BRACKET, "$1 $2")
    newText = newText.replace(RIGHT_BRACKET_AN, "$1 $2")
    newText = newText.replace(CJK_ANS, "$1 $2")
    newText = newText.replace(ANS_CJK, "$1 $2")
    newText = newText.replace(S_A, "$1 $2")
    // newText = newText.replace(MIDDLE_DOT, "ãƒ»")
    // å»ä¸­æ–‡é—´çš„ç©ºæ ¼
    newText = newText.replace(BACKSAPCE_CJK, "$1$2")
    // å»æ‰ä¸‹æ ‡å’Œä¸­æ–‡ä¹‹é—´çš„ç©ºæ ¼
    newText = newText.replace(SUBSCRIPT_CJK, "$1 ")
    newText = newText.replace(SUPERSCRIPT_CJK, "$1 ")
    /* ç‰¹æ®Šå¤„ç† */
    // ç‰¹æ®Šå­—ç¬¦
    newText = newText.replace(SPECIAL, "$1 ")
    // å¤„ç† C[a,b] è¿™ç§å•ç‹¬å­—æ¯ç´§è·Ÿæ‹¬å·çš„æƒ…å½¢ï¼Œä¸åŠ ç©ºæ ¼
    newText = newText.replace(/([A-Za-z])\s([\(\[\{])/g, "$1$2")
    newText = newText.replace(/([\)\]\}])\s([A-Za-z])/g, "$1$2")
    // â€åé¢ä¸åŠ ç©ºæ ¼
    newText = newText.replace(/â€\s/g, "â€")
    // Â· å·¦å³çš„ç©ºæ ¼å»æ‰
    newText = newText.replace(/\s*Â·\s*/g, "Â·")
    // - å·¦å³çš„ç©ºæ ¼å»æ‰
    newText = newText.replace(/\s*-\s*/g, "-")
    // âˆ åé¢çš„åªä¿ç•™ä¸€ä¸ªç©ºæ ¼ï¼Œè€Œä¸æ˜¯ç›´æ¥å»æ‰
    newText = newText.replace(/âˆ\s+/g, "âˆ ")
    newText = newText.replace(/âˆ\s*}/g, "âˆ}")
    newText = newText.replace(/âˆ\s*\)/g, "âˆ)")
    newText = newText.replace(/âˆ\s*\]/g, "âˆ]")
    newText = newText.replace(/âˆ\s*ã€‘/g, "âˆã€‘")
    newText = newText.replace(/âˆ\s*ï¼‰/g, "âˆï¼‰")
    newText = newText.replace(/âˆ\s*â€/g, "âˆâ€")
    newText = newText.replace(/âˆ\s*_/g, "âˆ_")
    // å¤§æ±‚å’Œç¬¦å·æ”¹æˆå°æ±‚å’Œç¬¦å·
    newText = newText.replace(/âˆ‘/g, "Î£")
    // å¤„ç†ä¸€ä¸‹ å¼±* w* è¿™ç§ç©ºæ ¼
    newText = newText.replace(/([å¼±A-Za-z])\s*\*/g, "$1*")
    newText = newText.replace(/\*\s*\*/g, "**")
    // æŠŠ ç­‰ä»·åˆ»ç”»/å……è¦æ¡ä»¶ ä¸­é—´çš„ / ä¸¤è¾¹çš„ç©ºæ ¼å»æ‰
    newText = newText.replace(/\s*\/\s*/g, '/')
    // å¤„ç†æ‹¬å·åé¢çš„ç©ºæ ¼
    newText = newText.replace(/\]\s*([A-Za-z])/g, "] $1")
    // å»æ‰ âˆˆ å‰é¢çš„ç©ºæ ¼
    newText = newText.replace(/\s*âˆˆ\s*/g, "âˆˆ")
    newText = newText.replace(/\|\|/g, "â€–")


    // å¤„ç†æ ‡ç‚¹ç¬¦å·
    newText = newText.replace(/\s*,\s*/g, ", ")
    newText = newText.replace(/\s*:\s*/g, ": ")
    newText = newText.replace(/:\s*\/\//g, "://")

    newText = newText.replace(/áµ©,\s*/g, "áµ©,")
    return newText
  }
}

class KnowledgeBaseClassUtils {
  static async makeNoteAfterProcessNewExcerpt (note, addToReview = false) {
    let type = KnowledgeBaseTemplate.getNoteTypeByColor(note.colorIndex)
    switch (type) {
      case "å½’ç±»":
        await this.createClassificationNoteAfterProcessNewExcerpt(note)
        break;
      default:
        let parentNote = note.parentNote
        let parentNoteType =  KnowledgeBaseTemplate.getNoteType(parentNote)
        let brotherIndex = note.indexInBrotherNotes
        if (
          parentNoteType &&
          parentNoteType == "å½’ç±»" &&
          KnowledgeBaseTemplate.parseNoteTitle(parentNote).type == type
        ) {
          let processedNote = KnowledgeBaseTemplate.toNoExcerptVersion(note)
          KnowledgeBaseTemplate.makeNote(processedNote, addToReview)
          //   KnowledgeBaseUtils.log("å®Œæ•´åˆ¶å¡", "onProcessNewExcerpt - å½’ç±»æ¨¡å¼", {
          //   brotherIndex: brotherIndex,
          //   "çˆ¶å¡ç‰‡": processedNote.parentNote.title,
          // })
          // parentNote.addChild(processedNote)
          processedNote.moveTo(brotherIndex)
          processedNote.focusInMindMap(0.5)
        } else {
          // KnowledgeBaseUtils.log("åªèƒ½è½¬ä¸ºéæ‘˜å½• ä¸åˆ¶å¡", "onProcessNewExcerpt - å½’ç±»æ¨¡å¼", {"1" : parentNoteType, "2 ": 
          // parentNoteType == "å½’ç±»", "3 ":
          // KnowledgeBaseTemplate.parseNoteTitle(parentNote).type, 4:type})
          let processedNote = KnowledgeBaseTemplate.toNoExcerptVersion(note)
          processedNote.focusInMindMap(0.3)
        }
        break;
    }
  }
  static async createClassificationNoteAfterProcessNewExcerpt (note) {
    let parentNote = note.parentNote
    if (!parentNote) { return }
    // KnowledgeBaseUtils.log("å¤„ç†å‰å¡ç‰‡çš„æ ‡é¢˜ä¸º" + note.title, "onProcessNewExcerpt - å½’ç±»æ¨¡å¼")
    if ( note.colorIndex !== KnowledgeBaseTemplate.types.å½’ç±».colorIndex ) { return }
    let finalParentNote
    if (KnowledgeBaseTemplate.getNoteType(parentNote)) {
      if (parentNote.childNotes.length > 1) {  // å› ä¸ºæ­¤æ—¶è‡ªå·±ä¹Ÿç®—å­å¡ç‰‡äº†ï¼Œæ‰€ä»¥ä» 1 å¼€å§‹ç®—
        finalParentNote = parentNote.childNotes[parentNote.childNotes.length - 2] // è·å–ä¸Šä¸€ä¸ªå…„å¼Ÿå¡ç‰‡
      } else {
        finalParentNote = parentNote
      }
      note.moveTo(finalParentNote)
      let convertedNote = await KnowledgeBaseTemplate.convertNoteToClassificationNote(note, true, true)
      MNUtil.undoGrouping(()=>{
        convertedNote.focusInMindMap(0.3)
      })
    } else {
      // æ­¤æ—¶è¡¨ç¤ºæ‘˜å½•ä¸ºç‹¬ç«‹å¡ç‰‡äº†
      let convertedNote = await KnowledgeBaseTemplate.convertNoteToClassificationNote(note, true, false)
      if (convertedNote) {
        MNUtil.undoGrouping(()=>{
          convertedNote.focusInMindMap(0.3)
        })
      }
    }
  }
  static async createClassificationNoteAfterTextEditingInMindMap (note) {
    let parentNote = note.parentNote
    let lastClassificationNote
    if (!parentNote || (
      !KnowledgeBaseTemplate.getNoteType(parentNote)
    )) {
      lastClassificationNote = await KnowledgeBaseTemplate.convertNoteToClassificationNote(note, true, false, false)
    } else {
      lastClassificationNote = await KnowledgeBaseTemplate.convertNoteToClassificationNote(note, true, true, false)
    }
    lastClassificationNote.focusInMindMap(0.2)
  }
}

// ============================================
// ğŸ“‹ ProofParser ç±»ï¼šæ•°å­¦è¯æ˜å°ç›®æ ‡æ‹†åˆ†
// ============================================
/**
 * ProofParser - ç”¨äºè§£ææ•°å­¦è¯æ˜çš„å±‚çº§ç»“æ„
 *
 * åŠŸèƒ½ï¼šå°†ç»“æ„åŒ–çš„ Markdown è¯æ˜æ–‡æœ¬è½¬æ¢ä¸ºè„‘å›¾å¡ç‰‡
 *
 * è¾“å…¥æ ¼å¼ï¼š
 * ```markdown
 * - **å°ç›®æ ‡ 1**
 *   > è¯¦ç»†å†…å®¹ 1
 *   - **å°ç›®æ ‡ 1.1**
 *     > è¯¦ç»†å†…å®¹ 1.1
 * ```
 *
 * è¾“å‡ºï¼šJSON æ ‘ç»“æ„ + MN å¡ç‰‡å±‚çº§
 *
 * ä½¿ç”¨ç¤ºä¾‹ï¼š
 * ```javascript
 * let markdown = "- **è¯æ˜**\n  > ç›®æ ‡æ˜¯...\n  - **æ­¥éª¤1**\n    > æ˜¾ç„¶...";
 * let tree = ProofParser.parseProofMarkdown(markdown);
 * ProofParser.createProofCards(tree, parentNote);
 * ```
 */
class ProofParser {
  /**
   * è§£ææ•°å­¦è¯æ˜ Markdown ä¸º JSON æ ‘
   * @param {string} markdown - Markdown æ–‡æœ¬
   * @returns {Object|Array} JSON æ ‘ç»“æ„
   *
   * è¿”å›æ ¼å¼ï¼š
   * {
   *   title: "å°ç›®æ ‡",
   *   content: "è¯¦ç»†å†…å®¹",
   *   children: [...]
   * }
   */
  /**
   * ä¿®å¤å¼•ç”¨å—å¤–çš„å­¤ç«‹å…¬å¼
   *
   * é—®é¢˜ï¼šå½“ blockquote ä»¥ > ç©ºè¡Œç»“å°¾åï¼Œç´§è·Ÿçš„ç‹¬ç«‹å…¬å¼å—ä¼šè¢« marked.js
   * è§£æä¸ºä¸‹ä¸€ä¸ªåˆ—è¡¨é¡¹çš„å†…å®¹ï¼Œå¯¼è‡´å…¬å¼ä¸¢å¤±
   *
   * è§£å†³ï¼šå°†è¿™ç§å­¤ç«‹çš„å…¬å¼å—ç§»å…¥å‰é¢çš„ blockquote ä¸­ï¼ˆæ·»åŠ  > å‰ç¼€ï¼‰
   *
   * @param {string} markdown - åŸå§‹ Markdown æ–‡æœ¬
   * @return {string} - ä¿®å¤åçš„ Markdown æ–‡æœ¬
   */
  static fixOrphanedFormulas(markdown) {
    // åŒ¹é…æ¨¡å¼ï¼š
    // 1. ä»¥ > å¼€å¤´çš„ä»»æ„è¡Œï¼ˆæ”¯æŒè¡Œé¦–ç¼©è¿›ï¼‰: (^\s*>.*\n)
    // 2. åé¢å¯èƒ½æœ‰å¤šä¸ªç©ºç™½è¡Œæˆ–ç©ºå¼•ç”¨è¡Œ: ((?:[\s>]*\n)*)
    // 3. åé¢æ˜¯ç‹¬ç«‹çš„è¡Œé—´å…¬å¼: $$...$$ (æ²¡æœ‰ > å‰ç¼€)
    // ä½¿ç”¨ negative lookahead (?!\s*>) ç¡®ä¿å…¬å¼è¡Œå‰é¢æ²¡æœ‰ >
    return markdown.replace(
      /(^\s*>.*\n)((?:[\s>]*\n)*)((?!\s*>)\$\$[\s\S]+?\$\$)/gm,
      (match, blockquoteLine, emptyLines, formula) => {
        // æå– blockquoteLine çš„ç¼©è¿›
        const indent = blockquoteLine.match(/^(\s*)/)[1];
        // è¿”å›ï¼šblockquoteLineï¼ˆå»é™¤å°¾éƒ¨ç©ºç™½ï¼‰+ æ¢è¡Œ + ç¼©è¿› + > + å…¬å¼
        // è¿™æ ·å¯ä»¥ç§»é™¤ä¸­é—´çš„ç©ºç™½è¡Œï¼ŒåŒæ—¶ä¿æŒæ­£ç¡®çš„ç¼©è¿›
        return blockquoteLine.trimEnd() + '\n' + indent + '> ' + formula;
      }
    );
  }

  /**
   * å…œåº•æ£€æµ‹ï¼šç¡®ä¿æ‰€æœ‰è¡Œé—´å…¬å¼éƒ½æœ‰æ­£ç¡®çš„ > å‰ç¼€
   *
   * ç­–ç•¥ï¼šé€è¡Œæ‰«æï¼Œæ£€æµ‹è¡Œé—´å…¬å¼ï¼Œå¦‚æœå‰é¢æœ‰ blockquote åˆ™ç¡®ä¿å…¬å¼ä¹Ÿæœ‰ > å‰ç¼€
   * æ™ºèƒ½å¤„ç†ç¼©è¿›ï¼šè‡ªåŠ¨åŒ¹é… blockquote çš„ç¼©è¿›çº§åˆ«
   *
   * @param {string} markdown - Markdown æ–‡æœ¬
   * @returns {string} - å¤„ç†åçš„ Markdown æ–‡æœ¬
   */
  static ensureAllFormulasInBlockquote(markdown) {
    const lines = markdown.split('\n');
    const result = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // æ£€æµ‹è¡Œé—´å…¬å¼å¼€å§‹ï¼ˆ$$å¼€å¤´ï¼Œä¸”å‰é¢æ²¡æœ‰>ï¼‰
      if (/^\s*\$\$/.test(line) && !/^\s*>/.test(line)) {
        // å‘ä¸ŠæŸ¥æ‰¾æœ€è¿‘çš„ blockquoteï¼ˆ10è¡Œå†…ï¼‰
        let blockquoteIndent = null;
        let hasBlockquoteAbove = false;

        for (let j = i - 1; j >= Math.max(0, i - 10); j--) {
          const prevLine = lines[j];

          // æ£€æµ‹åˆ° blockquote è¡Œ
          const blockquoteMatch = prevLine.match(/^(\s*)>/);
          if (blockquoteMatch) {
            hasBlockquoteAbove = true;
            blockquoteIndent = blockquoteMatch[1]; // æå–ç¼©è¿›
            break;
          }

          // é‡åˆ°éç©ºç™½ä¸”éblockquoteçš„å†…å®¹è¡Œï¼Œåœæ­¢æŸ¥æ‰¾
          // ä½†è¦æ’é™¤åˆ—è¡¨æ ‡è®°è¡Œï¼ˆå¦‚ "- " æˆ– "  - "ï¼‰
          if (!/^\s*$/.test(prevLine) &&
              !/^\s*>/.test(prevLine) &&
              !/^\s*[-*]\s/.test(prevLine)) {
            break;
          }
        }

        // å¦‚æœæ‰¾åˆ°äº† blockquoteï¼Œæ·»åŠ ç›¸åŒç¼©è¿›çš„ > å‰ç¼€
        if (hasBlockquoteAbove && blockquoteIndent !== null) {
          result.push(blockquoteIndent + '> ' + line.trim());
        } else {
          result.push(line);
        }
      } else {
        result.push(line);
      }
    }

    return result.join('\n');
  }

  static parseProofMarkdown(markdown) {
    try {
      // é¢„å¤„ç†1ï¼šä¿®å¤å¼•ç”¨å—å¤–çš„å­¤ç«‹å…¬å¼ï¼ˆæ­£åˆ™æ¨¡å¼ï¼‰
      let fixedMarkdown = this.fixOrphanedFormulas(markdown);

      // é¢„å¤„ç†2ï¼šå…œåº•æ£€æµ‹ï¼Œç¡®ä¿æ‰€æœ‰å…¬å¼éƒ½æœ‰ > å‰ç¼€ï¼ˆé€è¡Œæ‰«æï¼‰
      fixedMarkdown = this.ensureAllFormulasInBlockquote(fixedMarkdown);

      // ä½¿ç”¨ marked.lexer è¿›è¡Œè¯æ³•åˆ†æ
      const tokens = marked.lexer(fixedMarkdown);

      // æ„å»ºè¯æ˜æ ‘
      const tree = this.buildProofTree(tokens);

      return tree;
    } catch (error) {
      KnowledgeBaseUtils.addErrorLog(error, "ProofParser.parseProofMarkdown");
      MNUtil.showHUD("è§£æ Markdown å¤±è´¥: " + error.message);
      return null;
    }
  }

  /**
   * é€’å½’æå– token çš„æ–‡æœ¬å†…å®¹
   * @param {Object} token - token å¯¹è±¡
   * @returns {string} æå–çš„æ–‡æœ¬
   */
  static getUnformattedText(token) {
    if ("tokens" in token && token.tokens && token.tokens.length === 1) {
      return this.getUnformattedText(token.tokens[0]);
    } else if ("text" in token) {
      return token.text || "";
    } else {
      return "";
    }
  }

  /**
   * ä¿®å¤ AI é”™è¯¯è½¬ä¹‰çš„ LaTeX åæ–œæ 
   * å°† \\alpha ä¿®å¤ä¸º \alphaï¼Œä½†ä¿ç•™ \\ æ¢è¡Œç¬¦
   * @param {string} text - å¾…å¤„ç†çš„æ–‡æœ¬
   * @returns {string} ä¿®å¤åçš„æ–‡æœ¬
   */
  static cleanLatexBackslashes(text) {
    if (!text) return text;

    // ä¿®å¤ï¼š\\å‘½ä»¤ â†’ \å‘½ä»¤
    // åªåŒ¹é… \\ åç´§è·Ÿå­—æ¯çš„æƒ…å†µï¼ˆLaTeX å‘½ä»¤ï¼‰
    // ä¸å½±å“ \\ åæ˜¯ç©ºæ ¼æˆ– [ çš„æƒ…å†µï¼ˆLaTeX æ¢è¡Œç¬¦ï¼‰
    return text.replace(/\\\\([a-zA-Z])/g, '\\$1');
  }

  /**
   * ä»åˆ—è¡¨é¡¹ tokens ä¸­æå–å°ç›®æ ‡ä¿¡æ¯
   * @param {Array} tokens - åˆ—è¡¨é¡¹çš„ tokens
   * @returns {Object} {title: "æ ‡é¢˜", content: "å†…å®¹"}
   *
   * æå–è§„åˆ™ï¼š
   * - æ ‡é¢˜ï¼š**...** ä¸­çš„æ–‡æœ¬ï¼ˆstrong tokenï¼‰
   * - å†…å®¹ï¼š> å¼•ç”¨å—ä¸­çš„æ–‡æœ¬ï¼ˆblockquote tokenï¼‰
   */
  static extractGoalFromListItem(tokens) {
    let title = "";
    let content = "";
    let additionalContent = "";
    let blockquoteIndex = -1;

    if (!tokens || tokens.length === 0) {
      MNUtil.log("âš ï¸ extractGoalFromListItem - tokens ä¸ºç©ºæˆ–é•¿åº¦ä¸º 0", "ProofParser");
      return { title, content };
    }

    // æ—¥å¿—ï¼šè¾“å‡ºå®Œæ•´çš„ tokens ç»“æ„
    MNUtil.log(`ğŸ“Š extractGoalFromListItem - tokens æ•°é‡: ${tokens.length}`, "ProofParser");
    MNUtil.log(tokens, "ProofParser - å®Œæ•´ tokens");

    // éå†æ‰€æœ‰ tokens æå–æ ‡é¢˜å’Œå†…å®¹
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];

      // æ—¥å¿—ï¼šè¾“å‡ºå½“å‰ token
      MNUtil.log(`ğŸ” Token[${i}] ç±»å‹: ${token.type}`, "ProofParser");
      MNUtil.log(token, `ProofParser - Token[${i}]`);

      // å¤„ç†æ®µè½æˆ–æ–‡æœ¬ tokenï¼ˆå¯èƒ½åŒ…å« strong æˆ–çº¯æ–‡æœ¬ï¼‰
      if ((token.type === "text" || token.type === "paragraph") && token.tokens) {
        MNUtil.log(`ğŸ“ paragraph æœ‰ ${token.tokens.length} ä¸ª innerTokens`, "ProofParser");

        let foundStrong = false;
        for (let j = 0; j < token.tokens.length; j++) {
          const innerToken = token.tokens[j];
          MNUtil.log(`  ğŸ”¸ InnerToken[${j}] ç±»å‹: ${innerToken.type}`, "ProofParser");
          MNUtil.log(innerToken, `ProofParser - InnerToken[${j}]`);

          if (innerToken.type === "strong") {
            // ä½¿ç”¨é€’å½’æ–¹æ³•æå–æ ‡é¢˜ï¼ˆæœ‰åŠ ç²—ç¬¦å·ï¼‰
            title = this.getUnformattedText(innerToken);
            MNUtil.log(`âœ… æå–åˆ°åŠ ç²—æ ‡é¢˜: "${title}"`, "ProofParser");
            MNUtil.log(innerToken, "ProofParser - strong token");
            foundStrong = true;
            break;
          }
        }

        // å¦‚æœæ²¡æœ‰æ‰¾åˆ° strongï¼Œä½¿ç”¨æ•´ä¸ª token.text ä½œä¸ºæ ‡é¢˜ï¼ˆæ— åŠ ç²—ç¬¦å·ï¼‰
        if (!foundStrong && !title && token.text) {
          title = token.text.trim();
          MNUtil.log(`âœ… æå–åˆ°çº¯æ–‡æœ¬æ ‡é¢˜: "${title}"`, "ProofParser");
        }
      }

      // å¤„ç†å¼•ç”¨å— token
      if (token.type === "blockquote") {
        // ä½¿ç”¨ token.raw ä¿ç•™ > ç¬¦å·
        content = token.raw ? token.raw.trim() : "";
        blockquoteIndex = i;

        // â­ ä¼˜åŒ–ï¼šç²¾ç¡®æ£€æµ‹ç©º blockquoteï¼ˆåªæœ‰å•è¡Œä¸”ä¸ºç©ºæ‰åˆ¤å®šï¼‰
        // å¤šè¡Œ blockquote å³ä½¿æœ«å°¾æœ‰ç©ºè¡Œï¼Œä¹Ÿä¸åº”è¯¥è¢«åˆ¤å®šä¸º"ç©º"
        const lines = content.trim().split('\n');
        const isEmptyBlockquote = lines.length === 1 && /^\s*>\s*$/.test(lines[0]);

        if (isEmptyBlockquote) {
          MNUtil.log(`âš ï¸ è­¦å‘Šï¼šæ£€æµ‹åˆ°ç©º blockquoteï¼æ ‡é¢˜ä¸º: "${title}"`, "ProofParser");
          MNUtil.log(`  åŸå§‹å†…å®¹: ${JSON.stringify(content)}`, "ProofParser");
          // å°†ç©º blockquote æ›¿æ¢ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œè®©å…œåº•å¤„ç†å»æ•è·åç»­å†…å®¹
          content = "";
          blockquoteIndex = -1; // é‡ç½®ç´¢å¼•ï¼Œæ ‡è®°ä¸ºæ— æœ‰æ•ˆ blockquote
        } else {
          MNUtil.log(`âœ… æå–åˆ°å†…å®¹ (${lines.length} è¡Œ): "${content.substring(0, 30)}..."`, "ProofParser");
        }
      }

      // å¦‚æœå·²ç»æ‰¾åˆ°æ ‡é¢˜å’Œå†…å®¹ï¼Œä¸å†æå‰ç»“æŸï¼Œç»§ç»­æ”¶é›†åç»­ token
      if (title && content && blockquoteIndex === -1) {
        MNUtil.log(`ğŸ‰ æ ‡é¢˜å’Œå†…å®¹éƒ½æ‰¾åˆ°äº†ï¼`, "ProofParser");
        break;
      }
    }

    // å…œåº•å¤„ç†ï¼šæ”¶é›† blockquote åçš„ç‹¬ç«‹ tokenï¼ˆå¦‚è¡Œé—´å…¬å¼ï¼‰
    if (blockquoteIndex !== -1 && blockquoteIndex < tokens.length - 1) {
      MNUtil.log(`ğŸ” å¼€å§‹å…œåº•å¤„ç†ï¼ŒblockquoteIndex: ${blockquoteIndex}, å‰©ä½™ tokens: ${tokens.length - blockquoteIndex - 1}`, "ProofParser");

      for (let i = blockquoteIndex + 1; i < tokens.length; i++) {
        const token = tokens[i];
        MNUtil.log(`  ğŸ“Œ æ£€æŸ¥ token[${i}]: type=${token?.type}, raw="${token?.raw?.substring(0, 50)}..."`, "ProofParser");

        // è·³è¿‡ç©º token å’ŒåµŒå¥—åˆ—è¡¨ï¼ˆåµŒå¥—åˆ—è¡¨ç”± buildProofTree å¤„ç†ï¼‰
        if (!token || token.type === "list") {
          MNUtil.log(`  â­ï¸ è·³è¿‡ token[${i}]: ${!token ? "tokenä¸ºnull" : "æ˜¯listç±»å‹"}`, "ProofParser");
          continue;
        }

        // æå–æœ‰å†…å®¹çš„ tokenï¼ˆtext, paragraph, code, space, html ç­‰ï¼Œå¯èƒ½æ˜¯è¡Œé—´å…¬å¼ï¼‰
        // â­ ä¼˜åŒ–ï¼šä¼˜å…ˆä½¿ç”¨ rawï¼Œå…œåº•ä½¿ç”¨ text
        const tokenContent = (token.raw || token.text || "").trim();
        if (tokenContent) {
          additionalContent += (additionalContent ? "\n" : "") + tokenContent;
          MNUtil.log(`  âœ… å…œåº•æ•è· ${token.type} token: "${tokenContent.substring(0, 50)}..."`, "ProofParser");
        } else {
          MNUtil.log(`  âš ï¸ token[${i}] å†…å®¹ä¸ºç©ºï¼Œè·³è¿‡`, "ProofParser");
        }
      }

      // å°†å…œåº•å†…å®¹è¿½åŠ åˆ° content
      if (additionalContent) {
        // â­ ä¼˜å…ˆæ£€æµ‹ï¼šblockquote æœ«å°¾æ˜¯å¦æœ‰ç©ºå¼•ç”¨è¡Œï¼ˆ> ååªæœ‰ç©ºç™½å’Œæ¢è¡Œï¼‰
        const emptyQuoteLinePattern = />\s*\n$/;

        if (emptyQuoteLinePattern.test(content)) {
          // åœºæ™¯1ï¼šæœ‰ç©ºå¼•ç”¨è¡Œ â†’ æ›¿æ¢æœ«å°¾çš„ ">\n" ä¸º "> å…œåº•å†…å®¹\n"
          content = content.replace(/>\s*\n$/, `> ${additionalContent}\n`);
          MNUtil.log(`ğŸ”„ æ£€æµ‹åˆ°ç©ºå¼•ç”¨è¡Œï¼Œæ›¿æ¢ä¸ºå¼•ç”¨å†…å®¹: "${additionalContent.substring(0, 50)}..."`, "ProofParser");
        } else {
          // åœºæ™¯2ï¼šæ— ç©ºå¼•ç”¨è¡Œ â†’ æ£€æŸ¥æ˜¯å¦ä¸ºå®Œå…¨ç©ºçš„ blockquote
          const trimmedContent = content.replace(/^>\s*/, "").trim();
          if (trimmedContent === "") {
            // blockquote ä¸ºç©ºï¼šç›´æ¥ç”¨å…œåº•å†…å®¹æ›¿æ¢
            content = "> " + additionalContent;
            MNUtil.log(`ğŸ”„ blockquote ä¸ºç©ºï¼Œä½¿ç”¨å…œåº•å†…å®¹æ›¿æ¢ï¼Œæ–°å†…å®¹: "${content.substring(0, 100)}..."`, "ProofParser");
          } else {
            // blockquote æœ‰å†…å®¹ä½†æ— ç©ºå¼•ç”¨è¡Œï¼šè¿½åŠ ä¸ºæ–°çš„å¼•ç”¨è¡Œ
            content += "\n> " + additionalContent;  // â­ ä¿®æ”¹ï¼šæ·»åŠ  "> " å‰ç¼€
            MNUtil.log(`ğŸ”— blockquote æœ‰å†…å®¹ï¼Œè¿½åŠ å…œåº•å†…å®¹ä¸ºæ–°å¼•ç”¨è¡Œ`, "ProofParser");
          }
        }
        MNUtil.log(`âœ… å…œåº•å¤„ç†å®Œæˆï¼Œæœ€ç»ˆå†…å®¹é•¿åº¦: ${content.length}`, "ProofParser");
      } else {
        MNUtil.log(`âš ï¸ æ²¡æœ‰æ•è·åˆ°å…œåº•å†…å®¹`, "ProofParser");
      }
    } else {
      if (blockquoteIndex === -1) {
        MNUtil.log(`â„¹ï¸ æœªæ‰¾åˆ° blockquoteï¼Œè·³è¿‡å…œåº•å¤„ç†`, "ProofParser");
      } else {
        MNUtil.log(`â„¹ï¸ blockquote æ˜¯æœ€åä¸€ä¸ª tokenï¼Œæ— éœ€å…œåº•å¤„ç†`, "ProofParser");
      }
    }

    // â­ æ–°å¢ï¼šæœ€ç»ˆéªŒè¯ - å¦‚æœ content ä»ä¸ºç©ºæˆ–åªæœ‰ >ï¼Œä½¿ç”¨æ ‡é¢˜ä½œä¸ºå…œåº•
    const finalTrimmedContent = content.replace(/^>\s*/, "").trim();
    if (title && finalTrimmedContent === "") {
      content = `> ${title}`;
      MNUtil.log(`ğŸš¨ å…œåº•å¤„ç†ï¼šcontent ä¸ºç©ºï¼Œä½¿ç”¨æ ‡é¢˜ä½œä¸ºå†…å®¹`, "ProofParser");
    }

    // â­ æœ€ç»ˆæ¸…ç†ï¼šä¿®å¤ AI é”™è¯¯è½¬ä¹‰çš„åæ–œæ 
    title = this.cleanLatexBackslashes(title);
    content = this.cleanLatexBackslashes(content);

    // æœ€ç»ˆç»“æœæ—¥å¿—
    MNUtil.log(`ğŸ“‹ æœ€ç»ˆç»“æœ - æ ‡é¢˜: "${title}", å†…å®¹é•¿åº¦: ${content.length}`, "ProofParser");

    return { title, content };
  }

  /**
   * ä» tokens æ„å»ºè¯æ˜æ ‘
   * @param {Array} tokens - marked.lexer è¿”å›çš„ tokens
   * @param {number} depth - å½“å‰é€’å½’æ·±åº¦ï¼ˆç”¨äºè°ƒè¯•ï¼‰
   * @returns {Array} æ ‘èŠ‚ç‚¹æ•°ç»„
   *
   * å¤„ç†æµç¨‹ï¼š
   * 1. éå† tokensï¼Œè¯†åˆ« list ç±»å‹
   * 2. å¯¹æ¯ä¸ª list_itemï¼š
   *    - æå–æ ‡é¢˜å’Œå†…å®¹ï¼ˆextractGoalFromListItemï¼‰
   *    - é€’å½’å¤„ç†åµŒå¥—åˆ—è¡¨ï¼ˆbuildProofTreeï¼‰
   *    - æ„å»º {title, content, children} ç»“æ„
   */
  static buildProofTree(tokens, depth = 0) {
    const result = [];

    if (!tokens || tokens.length === 0) {
      return result;
    }

    for (const token of tokens) {
      // åªå¤„ç†åˆ—è¡¨ç±»å‹
      if (token.type === "list" && token.items) {
        for (const item of token.items) {
          // æå–å½“å‰åˆ—è¡¨é¡¹çš„æ ‡é¢˜å’Œå†…å®¹
          const { title, content } = this.extractGoalFromListItem(item.tokens);

          // åˆ›å»ºèŠ‚ç‚¹
          const node = {
            title: title,
            content: content,
            children: []
          };

          // é€’å½’å¤„ç†åµŒå¥—åˆ—è¡¨
          if (item.tokens) {
            const nestedLists = item.tokens.filter(t => t.type === "list");
            for (const nestedList of nestedLists) {
              const childrenNodes = this.buildProofTree([nestedList], depth + 1);
              node.children.push(...childrenNodes);
            }
          }

          result.push(node);
        }
      }
    }

    return result;
  }

  /**
   * ä» JSON æ ‘åˆ›å»º MN å¡ç‰‡
   * @param {Object|Array} tree - JSON æ ‘ï¼ˆå¯ä»¥æ˜¯å•ä¸ªå¯¹è±¡æˆ–æ•°ç»„ï¼‰
   * @param {MbBookNote} parentNote - çˆ¶å¡ç‰‡
   * @returns {Array} åˆ›å»ºçš„å¡ç‰‡æ•°ç»„
   *
   * åˆ›å»ºè§„åˆ™ï¼š
   * - æ ‡é¢˜ â†’ å¡ç‰‡æ ‡é¢˜
   * - å†…å®¹ â†’ å¡ç‰‡æ‘˜å½•ï¼ˆMarkdown æ ¼å¼ï¼‰
   * - children â†’ é€’å½’åˆ›å»ºå­å¡ç‰‡
   */
  static createProofCards(tree, parentNote) {
    const createdNotes = [];

    if (!tree || !parentNote) {
      MNUtil.showHUD("å‚æ•°é”™è¯¯ï¼šç¼ºå°‘æ ‘ç»“æ„æˆ–çˆ¶å¡ç‰‡");
      return createdNotes;
    }

    try {
      // ç¡®ä¿ tree æ˜¯æ•°ç»„
      const nodes = Array.isArray(tree) ? tree : [tree];
      let nodeContent

      MNUtil.undoGrouping(() => {
        for (const node of nodes) {
          // åˆ›å»ºå½“å‰èŠ‚ç‚¹çš„å¡ç‰‡

          // å¤„ç†ä¸€äº›å¯èƒ½çš„å†…å®¹é—®é¢˜
          // \\â†’\
          const childNote = parentNote.createChildNote({
            title: node.title || "æœªå‘½åç›®æ ‡",
            excerptText: node.content || "",
            excerptTextMarkdown: true  // ä½¿ç”¨ Markdown æ ¼å¼
          });

          createdNotes.push(childNote);

          // é€’å½’åˆ›å»ºå­å¡ç‰‡
          if (node.children && node.children.length > 0) {
            const subNotes = this.createProofCards(node.children, childNote);
            createdNotes.push(...subNotes);
          }
        }
      });

      MNUtil.showHUD(`âœ… å·²åˆ›å»º ${createdNotes.length} å¼ å¡ç‰‡`);
      return createdNotes;
    } catch (error) {
      KnowledgeBaseUtils.addErrorLog(error, "ProofParser.createProofCards");
      MNUtil.showHUD("åˆ›å»ºå¡ç‰‡å¤±è´¥: " + error.message);
      return createdNotes;
    }
  }

  /**
   * ä¾¿æ·æ–¹æ³•ï¼šç›´æ¥ä» Markdown åˆ›å»ºå¡ç‰‡
   * @param {string} markdown - Markdown æ–‡æœ¬
   * @param {MbBookNote} parentNote - çˆ¶å¡ç‰‡
   * @returns {Array} åˆ›å»ºçš„å¡ç‰‡æ•°ç»„
   */
  static createCardsFromMarkdown(markdown, parentNote) {
    const tree = this.parseProofMarkdown(markdown);
    if (!tree) {
      return [];
    }
    return this.createProofCards(tree, parentNote);
  }
}
