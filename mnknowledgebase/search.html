<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>MNKnowledgeBase - æœç´¢å¯è§†åŒ–æ¡†æ¶</title>
  <style>
    :root {
      --bg: #f7f8fb;
      --card-bg: #fff;
      --accent: #2b7cff;
      --muted: #666;
      --pill-bg: #eef5ff;
      --pill-active-bg: #cfe1ff;
      --negative-bg: #ffeef4;
      --negative-active-bg: #ffdfee;
      --type-pill-bg: #e7f4ee;
      --type-pill-active-bg: #c4e6d5;
      --type-pill-color: #1c8054;
      --toggle-bg: #f0f3f9;
      --toggle-border: #d2d9e5;
      --toggle-active-bg: #2b7cff;
      --toggle-active-color: #fff;
      --shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
      --topbar-height: 64px;
      --toolbar-gap: 78px;
      --preset-max-height: 220px;
      --negative-height: 78px;
      --spacing-buffer: 20px;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: var(--bg);
      color: #111;
      -webkit-font-smoothing: antialiased;
      touch-action: manipulation;
      overscroll-behavior: contain;
    }

    /* å›ºå®šé¡¶éƒ¨æœç´¢æ  */
    .topbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 90;
      backdrop-filter: blur(6px);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.98), rgba(250, 250, 250, 0.9));
      border-bottom: 1px solid #e6e9ef;
      padding: 14px 20px;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      min-height: var(--topbar-height);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }

    .topbar.hidden {
      transform: translateY(-100%);
      opacity: 0;
      pointer-events: none;
    }

    .search-input-wrap {
      display: flex;
      gap: 8px;
      align-items: center;
      flex: 1;
    }

    .search-input {
      flex: 1;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #d6dbe8;
      background: var(--card-bg);
      box-shadow: var(--shadow);
      font-size: 15px;
    }

    .search-count {
      color: var(--muted);
      font-size: 13px;
      white-space: nowrap;
    }

    .dataset-toggle {
      display: inline-flex;
      background: var(--toggle-bg);
      border: 1px solid var(--toggle-border);
      border-radius: 999px;
      padding: 4px;
      gap: 4px;
      align-items: center;
      margin-right: 12px;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .dataset-toggle button {
      appearance: none;
      border: none;
      background: transparent;
      color: #4d5e78;
      font-size: 13px;
      font-weight: 600;
      padding: 6px 14px;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    .dataset-toggle button.active {
      background: var(--toggle-active-bg);
      color: var(--toggle-active-color);
      box-shadow: 0 6px 14px rgba(43, 124, 255, 0.18);
    }

    .dataset-toggle button:focus-visible {
      outline: 2px solid rgba(43, 124, 255, 0.4);
      outline-offset: 2px;
    }

    /* å·¥å…·æ èƒ¶å›Š */
    .pill-section {
      position: fixed;
      left: 0;
      right: 0;
      z-index: 80;
      background: linear-gradient(180deg, rgba(247, 248, 251, 0.95), rgba(247, 248, 251, 0.78));
      padding: 10px 20px 14px;
      backdrop-filter: blur(4px);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }

    .pill-section.hidden {
      transform: translateY(-100%);
      opacity: 0;
      pointer-events: none;
    }

    .pill-section--type {
      top: var(--topbar-height);
    }

    .pill-section--classification {
      top: calc(var(--topbar-height) + var(--toolbar-gap));
    }

    .pill-section--negative {
      top: var(--negative-top, calc(var(--topbar-height) + var(--toolbar-gap) * 2));
    }

    .pill-section--preset {
      top: var(--preset-top, calc(var(--topbar-height) + var(--toolbar-gap) * 3));
      max-height: var(--preset-max-height);
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
    }

    .pill-section--preset::-webkit-scrollbar {
      width: 6px;
    }

    .pill-section--preset::-webkit-scrollbar-track {
      background: transparent;
    }

    .pill-section--preset::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }

    .pill-section--preset::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.3);
    }

    .pill-section__header {
      margin-bottom: 8px;
    }

    .pill-section__label-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .pill-section__label {
      font-size: 12px;
      font-weight: 600;
      color: #5b6a80;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .pill-section__label::before {
      content: '';
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
      opacity: 0.45;
    }

    .pill-section__clear-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      font-size: 12px;
      font-weight: 500;
      background: rgba(255, 59, 48, 0.08);
      border: 1px solid rgba(255, 59, 48, 0.25);
      border-radius: 12px;
      color: #ff3b30;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      min-height: 28px;
      min-width: 60px;
    }

    .pill-section__clear-btn .clear-icon {
      font-size: 14px;
      font-weight: 600;
    }

    .pill-section__clear-btn:hover:not(.disabled) {
      background: rgba(255, 59, 48, 0.15);
      border-color: rgba(255, 59, 48, 0.4);
      transform: translateY(-1px);
    }

    .pill-section__clear-btn:active:not(.disabled) {
      transform: translateY(0) scale(0.96);
    }

    .pill-section__clear-btn.disabled {
      opacity: 0.35;
      cursor: not-allowed;
      background: rgba(0, 0, 0, 0.04);
      border-color: rgba(0, 0, 0, 0.1);
      color: #999;
    }

    /* é¢„è®¾åˆ†ç»„æ ·å¼ */
    .preset-group {
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
    }

    .preset-group:last-child {
      border-bottom: none;
      margin-bottom: 6px;
      padding-bottom: 0;
    }

    .preset-group__label {
      font-size: 12px;
      font-weight: 600;
      color: #5b6a80;
      margin-bottom: 8px;
      padding-left: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* æœ€è¿‘ä½¿ç”¨åˆ†ç»„ç‰¹æ®Šæ ·å¼ */
    .preset-group--recent .preset-group__label {
      color: #2b7cff;
    }

    .pill-row {
      display: flex;
      gap: 10px;
      align-items: center;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
    }

    .pill-row::-webkit-scrollbar {
      display: none;
    }

    .pill {
      background: var(--pill-bg);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
      border: 1px solid transparent;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      user-select: none;
    }

    .pill:active {
      transform: scale(0.96);
    }

    .pill.active {
      background: var(--pill-active-bg);
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 2px 6px rgba(43, 124, 255, 0.12);
    }

    .type-bar .pill {
      background: var(--type-pill-bg);
      color: var(--type-pill-color);
    }

    .type-bar .pill.active {
      background: var(--type-pill-active-bg);
      border-color: rgba(21, 122, 82, 0.4);
      color: #0d5c39;
      box-shadow: 0 2px 6px rgba(21, 122, 82, 0.14);
    }

    .pill.negative {
      background: var(--negative-bg);
      color: #c23b6b;
    }

    .pill.negative.active {
      background: var(--negative-active-bg);
      border-color: #f0b6d0;
      box-shadow: 0 2px 6px rgba(194, 59, 107, 0.08);
    }

    /* ä¸»ä½“å¸ƒå±€ */
    .main-layout {
      display: flex;
      height: 100vh;
      padding-top: var(--main-padding-top, calc(var(--topbar-height) + var(--toolbar-gap) * 2 + var(--negative-height) + var(--preset-max-height) + var(--spacing-buffer)));
      overflow: hidden;
      transition: padding-top 0.3s ease;
    }

    body.toolbar-hidden .main-layout {
      padding-top: 0;
    }

    /* å·¦ä¾§æ“ä½œé¢æ¿ */
    .sidebar {
      width: 280px;
      flex-shrink: 0;
      background: var(--card-bg);
      border-right: 1px solid #e6e9ef;
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.04);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      position: sticky;
      top: 0;
      height: 100%;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid #e6e9ef;
      background: linear-gradient(180deg, #fafbfc, #fff);
    }

    .sidebar-title {
      font-size: 13px;
      font-weight: 600;
      color: #5b6a80;
      margin-bottom: 8px;
    }

    .selected-card-info {
      font-size: 14px;
      color: #2a3a52;
      line-height: 1.5;
      padding: 10px;
      background: #f7f9fc;
      border-radius: 8px;
      border-left: 3px solid var(--accent);
      max-height: 80px;
      overflow-y: auto;
    }

    .selected-card-info.empty {
      color: var(--muted);
      font-style: italic;
      border-left-color: #d6dbe8;
    }

    .sidebar-section {
      padding: 16px;
      border-bottom: 1px solid #f0f2f5;
    }

    .sidebar-section-title {
      font-size: 12px;
      font-weight: 600;
      color: #5b6a80;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sidebar-btn {
      width: 100%;
      padding: 10px 14px;
      margin-bottom: 8px;
      background: var(--card-bg);
      border: 1px solid #e3e6ee;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      text-align: left;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sidebar-btn:hover:not(:disabled) {
      background: #f7f9fc;
      border-color: var(--accent);
      transform: translateX(2px);
    }

    .sidebar-btn:active:not(:disabled) {
      transform: scale(0.98);
    }

    .sidebar-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .sidebar-btn.primary {
      background: var(--accent);
      color: #fff;
      border-color: transparent;
      box-shadow: 0 4px 12px rgba(43, 124, 255, 0.2);
    }

    .sidebar-btn.primary:hover:not(:disabled) {
      background: #1b6cef;
      transform: translateX(2px);
    }

    /* å³ä¾§å¡ç‰‡åŒºåŸŸ */
    .container {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    /* æ“ä½œå·¥å…·æ  */
    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .btn {
      background: var(--card-bg);
      border: 1px solid #e3e6ee;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .btn:active {
      transform: scale(0.97);
    }

    .btn.primary {
      background: var(--accent);
      color: #fff;
      border-color: transparent;
      box-shadow: 0 6px 16px rgba(43, 124, 255, 0.16);
    }

    .btn[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    /* ç»“æœåˆ—è¡¨ */
    .results {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 12px;
    }

    .card {
      background: var(--card-bg);
      padding: 12px;
      border-radius: 10px;
      box-shadow: var(--shadow);
      border-left: 6px solid transparent;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 6px;
      transition: transform 0.18s ease, box-shadow 0.18s ease;
      position: relative;
    }

    .card.selected {
      box-shadow: 0 12px 28px rgba(43, 124, 255, 0.18);
      transform: translateY(-4px);
      border-left-width: 10px;
    }

    .card-locate-icon {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      opacity: 1;
      transform: scale(1);
      transition: all 0.2s ease;
      z-index: 10;
    }

    .card-locate-icon:active {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 4px 12px rgba(43, 124, 255, 0.3);
      transform: scale(0.95);
    }

    .card-title {
      font-weight: 600;
      line-height: 1.4;
      word-break: break-word;
    }

    .card-snippet {
      font-size: 13px;
      color: #444;
      line-height: 1.4;
      word-break: break-word;
    }

    .match-count {
      font-size: 12px;
      color: var(--muted);
      margin-left: 8px;
    }

    mark.matched {
      background: rgba(255, 230, 120, 0.9);
      color: #111;
      padding: 0 2px;
      border-radius: 2px;
    }

    .card-meta {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .card-type {
      display: inline-flex;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: #fff;
      align-items: center;
      gap: 6px;
      letter-spacing: 0.3px;
      white-space: nowrap;
    }

    .classification-subtype {
      background: rgba(32, 52, 87, 0.08);
      color: #2f466b;
      padding: 3px 10px;
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: 0.2px;
    }

    .classification-bar .pill {
      background: #eef1ff;
      color: #2f4a8a;
    }

    .classification-bar .pill.active {
      background: #4d6cff;
      color: #fff;
      border-color: rgba(77, 108, 255, 0.6);
      box-shadow: 0 4px 12px rgba(77, 108, 255, 0.18);
    }

    .card-type-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .chip-score {
      background: rgba(43, 124, 255, 0.08);
      color: #2b7cff;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 6px;
    }

    .component-hidden {
      display: none !important;
    }

    .toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(33, 33, 33, 0.88);
      color: #fff;
      padding: 10px 18px;
      border-radius: 999px;
      font-size: 13px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 120;
    }

    .toast.show {
      opacity: 1;
    }

    /* è¿”å›é¡¶éƒ¨æŒ‰é’® */
    .scroll-to-top {
      position: fixed;
      right: 24px;
      bottom: 24px;
      width: 56px;
      height: 56px;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 50%;
      box-shadow: 0 8px 24px rgba(43, 124, 255, 0.35);
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 110;
      transition: opacity 0.3s ease, transform 0.3s ease;
      opacity: 0;
      pointer-events: none;
      transform: scale(0.8);
    }

    .scroll-to-top.show {
      opacity: 1;
      pointer-events: auto;
      transform: scale(1);
    }

    .scroll-to-top:hover {
      background: #1b6cef;
      transform: scale(1.1);
    }

    .scroll-to-top:active {
      transform: scale(0.95);
    }

    /* iPad ç«–å±å’Œå°å±å¹•è®¾å¤‡ */
    @media (max-width: 1024px) {
      .sidebar {
        position: fixed;
        left: 0;
        top: var(--topbar-height);
        height: calc(100vh - var(--topbar-height));
        z-index: 100;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }

      .sidebar.show {
        transform: translateX(0);
        box-shadow: 4px 0 16px rgba(0, 0, 0, 0.15);
      }

      .container {
        margin-left: 0;
      }

      /* Sidebar åˆ‡æ¢æŒ‰é’® */
      .sidebar-toggle {
        position: fixed;
        left: 16px;
        bottom: 24px;
        width: 56px;
        height: 56px;
        background: var(--accent);
        color: #fff;
        border: none;
        border-radius: 50%;
        box-shadow: 0 8px 24px rgba(43, 124, 255, 0.35);
        cursor: pointer;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 90;
        transition: transform 0.2s ease;
      }

      .sidebar-toggle:active {
        transform: scale(0.92);
      }

      .sidebar-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.3);
        z-index: 95;
        backdrop-filter: blur(2px);
      }

      .sidebar-overlay.show {
        display: block;
      }
    }

    @media (max-width: 640px) {
      :root {
        --topbar-height: 56px;
        --toolbar-gap: 40px;
      }

      .topbar {
        padding: 12px 14px;
      }

      .pill-row {
        padding: 8px 14px;
      }

      .container {
        padding: 0 12px 80px;
      }

      .results {
        grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      }

      .pill-section__clear-btn {
        min-height: 32px;
        padding: 6px 12px;
      }

      .pill-section__clear-btn .clear-text {
        display: none;
      }

      .pill-section__clear-btn .clear-icon {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="dataset-toggle" id="datasetToggle" role="group" aria-label="æ•°æ®æºåˆ‡æ¢">
      <button type="button" data-dataset="knowledge" class="active">çŸ¥è¯†åº“</button>
      <button type="button" data-dataset="intermediate">ä¸­é—´çŸ¥è¯†åº“</button>
    </div>
    <div class="search-input-wrap">
      <input id="searchInput" class="search-input" placeholder="æœç´¢çŸ¥è¯†åº“ï¼šè¾“å…¥å…³é”®å­—æˆ–é€‰æ‹©ä¸‹æ–¹é¢„è®¾" autocomplete="off" />
      <div id="searchCount" class="search-count">0 æ¡ç»“æœ</div>
    </div>
    <div>
      <button id="clearBtn" class="btn" type="button">æ¸…ç©º</button>
    </div>
  </div>

  <div class="pill-section pill-section--type" data-section="type">
    <div class="pill-section__label">ç±»å‹ç­›é€‰</div>
    <div class="pill-row type-bar" id="typeBar" aria-label="ç±»å‹ç­›é€‰">
      <!-- ç±»å‹ç­›é€‰ pill å°†åœ¨ JS ä¸­æ¸²æŸ“ -->
    </div>
  </div>
  <div class="pill-section pill-section--classification component-hidden" data-section="classification">
    <div class="pill-section__label">å½’ç±»å­ç±»å‹</div>
    <div class="pill-row classification-bar" id="classificationBar" aria-label="å½’ç±»äºŒçº§ç±»å‹">
      <!-- å½’ç±»äºŒçº§ç±»å‹ pill -->
    </div>
  </div>
  <div class="pill-section pill-section--preset" data-section="preset">
    <div class="pill-section__header">
      <div class="pill-section__label-group">
        <div class="pill-section__label">æœç´¢é¢„è®¾</div>
        <button class="pill-section__clear-btn" id="clearPresetsBtn" type="button">
          <span class="clear-icon">âœ•</span>
          <span class="clear-text">æ¸…é™¤</span>
        </button>
      </div>
    </div>
    <div id="presetBar" aria-label="æœç´¢é¢„è®¾">
      <!-- é¢„è®¾åˆ†ç»„å°†åœ¨ JS ä¸­æ¸²æŸ“ -->
    </div>
  </div>
  <div class="pill-section pill-section--negative" data-section="negative">
    <div class="pill-section__header">
      <div class="pill-section__label-group">
        <div class="pill-section__label">æ’é™¤å…³é”®è¯</div>
        <button class="pill-section__clear-btn" id="clearNegativesBtn" type="button">
          <span class="clear-icon">âœ•</span>
          <span class="clear-text">æ¸…é™¤</span>
        </button>
      </div>
    </div>
    <div class="pill-row negative-bar" id="negativeBar" aria-label="æ’é™¤è¯">
      <!-- è´Ÿå‘æ’é™¤è¯ï¼ˆç²‰è‰²ï¼‰å°†åœ¨ JS ä¸­æ¸²æŸ“ -->
    </div>
  </div>

  <!-- Sidebar é®ç½©å±‚ (ä»…ç§»åŠ¨ç«¯) -->
  <div class="sidebar-overlay" id="sidebarOverlay"></div>

  <!-- Sidebar åˆ‡æ¢æŒ‰é’® (ä»…ç§»åŠ¨ç«¯) -->
  <button class="sidebar-toggle" id="sidebarToggle" type="button" style="display: none;">
    âš™ï¸
  </button>

  <div class="main-layout">
    <!-- å·¦ä¾§æ“ä½œé¢æ¿ -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-title">å½“å‰é€‰ä¸­</div>
        <div class="selected-card-info empty" id="selectedCardInfo">æœªé€‰ä¸­å¡ç‰‡</div>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title">å¯¹é€‰ä¸­å¡ç‰‡çš„æ“ä½œ</div>
        <button class="sidebar-btn primary" id="locateInFloatBtn" type="button" disabled>
          <span>ğŸ“</span>
          <span>åœ¨æµ®çª—ä¸­å®šä½</span>
        </button>
        <button class="sidebar-btn" id="copyMarkdownBtn" type="button" disabled>
          <span>ğŸ“‹</span>
          <span>å¤åˆ¶ Markdown é“¾æ¥</span>
        </button>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title">ä¸ focusNote äº¤äº’</div>
        <button class="sidebar-btn" id="mergeToExcerptBtn" type="button" disabled>
          <span>ğŸ”—</span>
          <span>åˆå¹¶åˆ°ç›®æ ‡å¡ç‰‡çš„æ‘˜å½•åŒº</span>
        </button>
        <button class="sidebar-btn" id="clearAndMergeBtn" type="button" disabled>
          <span>ğŸ”—</span>
          <span>æ¸…ç©ºæ ‡é¢˜ & åˆå¹¶</span>
        </button>
        <button class="sidebar-btn" id="bidirectionalLinkBtn" type="button" disabled>
          <span>ğŸ”—</span>
          <span>åŒå‘é“¾æ¥</span>
        </button>
        <button class="sidebar-btn" id="moveAsChildBtn" type="button" disabled>
          <span>ğŸ—ºï¸</span>
          <span>ç§»åˆ°å­å¡ç‰‡</span>
        </button>
        <button class="sidebar-btn" id="moveAsChildAndLocateBtn" type="button" disabled>
          <span>ğŸ—ºï¸</span>
          <span>ç§»åˆ°å­å¡ç‰‡ & ä¸»è„‘å›¾å®šä½</span>
        </button>
        <button class="sidebar-btn" id="addTemplateAsChildBtn" type="button" disabled>
          <span>ğŸ—ºï¸</span>
          <span>å¢åŠ æ¨¡æ¿å¹¶æ·»åŠ ä¸ºå­å¡ç‰‡</span>
        </button>
        <button class="sidebar-btn" id="addTemplateAsChildAndLocateBtn" type="button" disabled>
          <span>ğŸ—ºï¸</span>
          <span>å¢åŠ æ¨¡æ¿å¹¶æ·»åŠ ä¸ºå­å¡ç‰‡ & å®šä½</span>
        </button>
      </div>
    </aside>

    <!-- å³ä¾§å¡ç‰‡åŒºåŸŸ -->
    <div class="container">
      <div class="results" id="results"></div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <!-- è¿”å›é¡¶éƒ¨æŒ‰é’® -->
  <button class="scroll-to-top" id="scrollToTopBtn" type="button" aria-label="è¿”å›é¡¶éƒ¨">
    â¬†ï¸
  </button>

  <script>
    (function () {
      'use strict';

      // é»˜è®¤é…ç½®ï¼ŒçœŸå®ç¯å¢ƒå¯ä»¥é€šè¿‡ window.MNKB API è¦†ç›–
      const DEFAULT_PRESET_GROUPS = [
        {
          name: 'æœºå™¨å­¦ä¹ ',
          icon: 'ğŸ¤–',
          presets: ['æœºå™¨å­¦ä¹ ', 'æ·±åº¦å­¦ä¹ ', 'æ”¯æŒå‘é‡æœº', 'å·ç§¯ ç¥ç» ç½‘ç»œ', 'è‡ªç„¶è¯­è¨€å¤„ç†', 'æ³¨æ„åŠ› æœºåˆ¶']
        },
        {
          name: 'ä¼˜åŒ–ä¸ç®—æ³•',
          icon: 'âš¡',
          presets: ['ä¼˜åŒ–', 'æ¢¯åº¦ ä¸‹é™', 'å­¦ä¹  æ›²çº¿']
        },
        {
          name: 'æ³›å‡½åˆ†æ',
          icon: 'ğŸ“',
          presets: ['æ³›å‡½ åˆ†æ', 'Hilbert ç©ºé—´', 'ç´§è‡´ æ€§è´¨']
        },
        {
          name: 'ä¿¡æ¯æ£€ç´¢',
          icon: 'ğŸ”',
          presets: ['æ£€ç´¢', 'ç»Ÿè®¡ æ¨æ–­']
        }
      ];

      const DEFAULT_NEGATIVE_PRESETS = ['å¤ Hilbert', 'å®éªŒ æ•°æ®', 'å™ªå£°', 'å¼‚å¸¸ å€¼', 'åä¾‹', 'ç¦»çº¿ æ¼”ç¤º'];

      // å¯¹é½ SearchConfig.typePresetsï¼Œä¾¿äºåç»­ä¸ utils.js ä¿æŒä¸€è‡´
      const RAW_TYPE_LABEL = 'æœªåˆ†ç±»';

      const DEFAULT_TYPE_FILTERS = [
        { key: 'all', label: 'å…¨éƒ¨ç±»å‹', types: null },
        { key: 'classifications', label: 'å½’ç±»', types: ['å½’ç±»'] },
        { key: 'definitions', label: 'å®šä¹‰', types: ['å®šä¹‰'] },
        { key: 'definitionsAndClassifications', label: 'å®šä¹‰ä¸å½’ç±»', types: ['å®šä¹‰', 'å½’ç±»'] },
        { key: 'knowledge', label: 'çŸ¥è¯†ç‚¹å¡ç‰‡', types: ['å®šä¹‰', 'å‘½é¢˜', 'ä¾‹å­', 'åä¾‹', 'æ€æƒ³æ–¹æ³•', 'çŸ¥è¯†'] },
        { key: 'propositions', label: 'å‘½é¢˜', types: ['å‘½é¢˜'] },
        { key: 'examples', label: 'ä¾‹å­', types: ['ä¾‹å­'] },
        { key: 'counterexamples', label: 'åä¾‹', types: ['åä¾‹'] },
        { key: 'methods', label: 'æ€æƒ³æ–¹æ³•', types: ['æ€æƒ³æ–¹æ³•'] },
        { key: 'problems', label: 'é—®é¢˜', types: ['é—®é¢˜'] },
        { key: 'ideas', label: 'æ€è·¯', types: ['æ€è·¯'] },
        { key: 'research', label: 'ç ”ç©¶è¿›å±•', types: ['ç ”ç©¶è¿›å±•'] },
        { key: 'papers', label: 'è®ºæ–‡', types: ['è®ºæ–‡'] },
        { key: 'untagged', label: RAW_TYPE_LABEL, types: [RAW_TYPE_LABEL] },
      ];

      // é¢œè‰²æ˜ å°„ï¼šä¼˜å…ˆç±»å‹ã€å…¶æ¬¡é¢œè‰²ç´¢å¼•ï¼Œæœ€åå›é€€è‰²
      const TYPE_COLOR_MAP = {
        å®šä¹‰: '#7bb8ff',
        å‘½é¢˜: '#5569ff',
        ä¾‹å­: '#8f7bff',
        åä¾‹: '#ff7b7b',
        å½’ç±»: '#ffd07b',
        æ€æƒ³æ–¹æ³•: '#5bd0a9',
        é—®é¢˜: '#ffa857',
        æ€è·¯: '#50c4a4',
        ç ”ç©¶è¿›å±•: '#5fa3ff',
        ç ”ç©¶: '#5fa3ff',
        è®ºæ–‡: '#a36bff',
        ä¹¦ä½œ: '#a36bff',
        ä½œè€…: '#7bb8ff',
        æ€»ç»“: '#7d8799',
        çŸ¥è¯†: '#7bb8ff',
        æœªåˆ†ç±»: '#b7c2d0',
      };

      const COLOR_INDEX_PALETTE = {
        0: '#ffd07b',
        1: '#ffb37b',
        2: '#7bb8ff',
        3: '#ff7b7b',
        4: '#ff9db5',
        5: '#5bd0a9',
        6: '#5fa3ff',
        7: '#aa7bff',
        8: '#ff9d4d',
        9: '#339972',
        10: '#5067ff',
        11: '#a36bff',
        12: '#ff914d',
        13: '#4d9dff',
        14: '#ffbf5f',
        15: '#b5bac7',
      };

      // å‡æ•°æ®ï¼šæœ¬åœ°é¢„è§ˆç”¨ï¼ŒçœŸå®ç¯å¢ƒé€šè¿‡åŸç”Ÿæ³¨å…¥
      const FAKE_CARDS = [
        { id: 'card-1001', title: 'æœºå™¨å­¦ä¹ æ¦‚è¿°', type: 'å®šä¹‰', color: '#7bb8ff', searchText: 'æœºå™¨å­¦ä¹  åŸºæœ¬æ¦‚å¿µ ç›‘ç£å­¦ä¹  æ— ç›‘ç£å­¦ä¹ ' },
        { id: 'card-1002', title: 'æ·±åº¦å­¦ä¹ ä¸ç¥ç»ç½‘ç»œ', type: 'å‘½é¢˜', color: '#5569ff', searchText: 'æ·±åº¦å­¦ä¹  ç¥ç»ç½‘ç»œ å·ç§¯ç¥ç»ç½‘ç»œ CNN RNN è¡¨å¾ å­¦ä¹ ' },
        { id: 'card-1003', title: 'æ”¯æŒå‘é‡æœºï¼ˆSVMï¼‰', type: 'å®šä¹‰', color: '#ff7b7b', searchText: 'æ”¯æŒå‘é‡æœº SVM åˆ†ç±» ç®—æ³•' },
        { id: 'card-1004', title: 'è‡ªç„¶è¯­è¨€å¤„ç†ç®€ä»‹', type: 'æ€æƒ³æ–¹æ³•', color: '#5bd0a9', searchText: 'è‡ªç„¶è¯­è¨€å¤„ç† NLP è¯å‘é‡ BERT' },
        { id: 'card-1005', title: 'å·ç§¯ ç¥ç» ç½‘ç»œ è¯¦è§£', type: 'å½’ç±»', classificationSubtype: 'å‘½é¢˜', color: '#ffd07b', searchText: 'å·ç§¯ ç¥ç» ç½‘ç»œ å·ç§¯ æ± åŒ–' },
        { id: 'card-1006', title: 'ä¼˜åŒ–ç®—æ³•å¯¹æ¯”', type: 'æ€æƒ³æ–¹æ³•', color: '#5bd0a9', searchText: 'æ¢¯åº¦ä¸‹é™ Adam RMSprop ä¼˜åŒ– å­¦ä¹ ç‡ è°ƒåº¦' },
        { id: 'card-1007', title: 'æ£€ç´¢ç³»ç»Ÿæ¦‚å¿µ', type: 'å®šä¹‰', color: '#7bb8ff', searchText: 'ä¿¡æ¯æ£€ç´¢ æœç´¢ æ’åº å€’æ’ç´¢å¼• æŸ¥è¯¢ æ‰©å±•' },
        { id: 'card-1008', title: 'æ³¨æ„åŠ›æœºåˆ¶ï¼ˆAttentionï¼‰', type: 'å‘½é¢˜', color: '#5569ff', searchText: 'æ³¨æ„åŠ› æœºåˆ¶ Transformer è‡ªæ³¨æ„åŠ›' },
        { id: 'card-1009', title: 'åŠç›‘ç£å­¦ä¹ å®ä¾‹', type: 'ä¾‹å­', color: '#8f7bff', searchText: 'åŠç›‘ç£ å­¦ä¹  å®ä¾‹ åº”ç”¨' },
        { id: 'card-1010', title: 'Evaluation Metrics', type: 'å®šä¹‰', color: '#7bb8ff', searchText: 'precision recall F1 score æ··æ·†çŸ©é˜µ' },
        { id: 'card-1011', title: 'Neural Network Architectures', type: 'å½’ç±»', classificationSubtype: 'ä¾‹å­', color: '#ffd07b', searchText: 'MLP CNN RNN Transformer architectures' },
        { id: 'card-1012', title: 'Embedding Techniques', type: 'ä¾‹å­', color: '#8f7bff', searchText: 'è¯å‘é‡ embedding word2vec GloVe BERT' },
        { id: 'card-2001', title: 'å¤ Hilbert ç©ºé—´ ä¸­çš„æ€§è´¨', type: 'å‘½é¢˜', color: '#5569ff', searchText: 'Hilbert ç©ºé—´ å¤ æ•° çº¿æ€§ ä»£æ•° å†…ç§¯ ç©ºé—´' },
        { id: 'card-2002', title: 'å® Hilbert ç©ºé—´ ç¤ºä¾‹', type: 'å‘½é¢˜', color: '#5569ff', searchText: 'Hilbert ç©ºé—´ å® æ•° ä¾‹å­ æ­£äº¤ åŸº' },
        { id: 'card-2003', title: 'å¤šé¡¹å¼ å›å½’ çš„é²æ£’æ€§', type: 'æ€æƒ³æ–¹æ³•', color: '#5bd0a9', searchText: 'å›å½’ å¤šé¡¹å¼ å›å½’ è¿‡æ‹Ÿåˆ æ­£åˆ™åŒ–' },
        { id: 'card-2004', title: 'å™ªå£° åˆ†æ æ–¹æ³•', type: 'æ€æƒ³æ–¹æ³•', color: '#5bd0a9', searchText: 'å™ªå£° ä¿¡å· è¿‡æ»¤ å»å™ª è°± åˆ†æ' },
        { id: 'card-2005', title: 'å¼‚å¸¸ å€¼ æ£€æµ‹ æŠ€æœ¯', type: 'æ€æƒ³æ–¹æ³•', color: '#5bd0a9', searchText: 'å¼‚å¸¸ å€¼ æ£€æµ‹ å¼‚å¸¸ æ•°æ® ç¦»ç¾¤ ç‚¹' },
        { id: 'card-2101', title: 'ç»Ÿè®¡å­¦ä¹ ç†è®ºæ ¸å¿ƒé—®é¢˜', type: 'é—®é¢˜', color: '#ffa857', searchText: 'ç»Ÿè®¡ å­¦ä¹  ç†è®º æ³›åŒ– èƒ½åŠ› VC ç»´ ç»éªŒ é£é™©' },
        { id: 'card-2102', title: 'æ¢¯åº¦æ¶ˆå¤±çš„æ’æŸ¥æ€è·¯', type: 'æ€è·¯', color: '#50c4a4', searchText: 'æ¢¯åº¦ æ¶ˆå¤± æ¿€æ´» å‡½æ•° æ‰¹é‡ å½’ä¸€åŒ– æ®‹å·® è¿æ¥ æ’æŸ¥ æµç¨‹' },
        { id: 'card-2103', title: 'Transformer ç ”ç©¶å‰æ²¿', type: 'ç ”ç©¶è¿›å±•', color: '#5fa3ff', searchText: 'Transformer ç ”ç©¶ å‰æ²¿ å¤šæ¨¡æ€ è§†è§‰ Transformers å‚æ•° é«˜æ•ˆ åŒ–' },
        { id: 'card-2104', title: 'æ³¨æ„åŠ›æœºåˆ¶ç»¼è¿°è®ºæ–‡', type: 'è®ºæ–‡', color: '#a36bff', searchText: 'æ³¨æ„åŠ› æœºåˆ¶ ç»¼è¿° è®ºæ–‡ å¼•ç”¨ ç»Ÿè®¡ Transformer åŸç†' },
        { id: 'card-2105', title: 'æ–‡çŒ®é˜…è¯»æçº²ï¼šæ·±åº¦æ¦‚ç‡æ¨¡å‹', type: 'å½’ç±»', classificationSubtype: 'å®šä¹‰', color: '#ffd07b', searchText: 'æ·±åº¦ æ¦‚ç‡ æ¨¡å‹ ç»“æ„ å­¦ä¹  å˜åˆ† æ¨æ–­ ç»¼è¿° æçº²' },
        { id: 'card-2106', title: 'å­¦ä¹ æ›²çº¿ä¸æ—©åœç­–ç•¥', type: 'æ€æƒ³æ–¹æ³•', color: '#5bd0a9', searchText: 'å­¦ä¹  æ›²çº¿ æ—©åœ éªŒè¯é›† è¿‡æ‹Ÿåˆ æ¨¡å‹ é€‰æ‹©' },
        { id: 'card-2107', title: 'å¼ é‡åˆ†è§£â€”â€”å®šä¹‰ä¸ä¾‹å­', type: 'å®šä¹‰', color: '#7bb8ff', searchText: 'å¼ é‡ åˆ†è§£ å®šä¹‰ Tucker CP åˆ†è§£ é«˜é˜¶ æ•°æ®' },
        { id: 'card-2108', title: 'å¼ é‡åˆ†è§£å¸¸è§åä¾‹', type: 'åä¾‹', color: '#ff7b7b', searchText: 'å¼ é‡ åˆ†è§£ åä¾‹ å”¯ä¸€æ€§ å¤±è´¥ æƒ…å†µ åä¾‹ æ„é€ ' },
        { id: 'card-2109', title: 'æ³›å‡½åˆ†æå…¥é—¨æçº²', type: 'å½’ç±»', classificationSubtype: 'å‘½é¢˜', color: '#ffd07b', searchText: 'æ³›å‡½ åˆ†æ å…¥é—¨ æçº² çº¿æ€§ ç©ºé—´ èµ‹èŒƒ ç©ºé—´ Banach' },
        { id: 'card-2110', title: 'Hilbert ç©ºé—´çš„å…¸å‹ä¾‹å­', type: 'ä¾‹å­', color: '#8f7bff', searchText: 'Hilbert ç©ºé—´ ä¾‹å­ L2 ç©ºé—´ Fourier åŸº æ­£äº¤ ç³»' },
        { id: 'card-2111', title: 'Hilbert ç©ºé—´çš„åä¾‹', type: 'åä¾‹', color: '#ff7b7b', searchText: 'Hilbert ç©ºé—´ åä¾‹ éå®Œå¤‡ å†…ç§¯ ç©ºé—´ counterexample' },
        { id: 'card-2112', title: 'ç»Ÿè®¡æ¨æ–­çš„å…³é”®å®šä¹‰', type: 'å®šä¹‰', color: '#7bb8ff', searchText: 'ç»Ÿè®¡ æ¨æ–­ å®šä¹‰ å‚æ•° ä¼°è®¡ å‡è®¾ æ£€éªŒ ç½®ä¿¡ åŒºé—´' },
        { id: 'card-2113', title: 'è´å¶æ–¯æ¨æ–­çš„æ€æƒ³æ–¹æ³•', type: 'æ€æƒ³æ–¹æ³•', color: '#5bd0a9', searchText: 'è´å¶æ–¯ æ¨æ–­ å…ˆéªŒ åéªŒ å…±è½­ åˆ†å¸ƒ ä¸ç¡®å®šæ€§' },
        { id: 'card-2114', title: 'æ¨¡å‹å‹ç¼©ç ”ç©¶è·¯çº¿', type: 'æ€è·¯', color: '#50c4a4', searchText: 'æ¨¡å‹ å‹ç¼© å‰ªæ é‡åŒ– çŸ¥è¯† è’¸é¦ ç ”ç©¶ è·¯çº¿' },
        { id: 'card-2115', title: 'å­¦ä¹ ç‡è°ƒåº¦å™¨å¯¹æ¯”', type: 'æ€æƒ³æ–¹æ³•', color: '#5bd0a9', searchText: 'å­¦ä¹ ç‡ è°ƒåº¦ ä½™å¼¦ é€€ç« çƒ­é‡å¯ å¾ªç¯ å­¦ä¹ ç‡ SEA' },
        { id: 'card-2116', title: 'ResNet è®¾è®¡æ¼”åŒ–å²', type: 'ç ”ç©¶è¿›å±•', color: '#5fa3ff', searchText: 'ResNet æ®‹å·® ç½‘ç»œ è®¾è®¡ æ¼”åŒ– å†å² å¤šåˆ†æ”¯ æ¶æ„' },
        { id: 'card-2117', title: 'æ·±åº¦å­¦ä¹ å¤±è´¥æ¡ˆä¾‹æ”¶é›†', type: 'åä¾‹', color: '#ff7b7b', searchText: 'æ·±åº¦ å­¦ä¹  å¤±è´¥ æ¡ˆä¾‹ æ¨¡å‹ å´©æºƒ å¯¹æŠ— æ ·æœ¬' },
      ];

      const FAKE_INTERMEDIATE = [
        { id: 'mid-3001', title: 'å¾…æ•´ç†ï¼šæµ‹åº¦è®ºé˜…è¯»æ€è·¯', type: 'æ€è·¯', color: '#50c4a4', searchText: 'æµ‹åº¦è®º é˜…è¯» æçº² ä»»åŠ¡ æ¸…å•', isTemplated: false },
        { id: 'mid-3002', title: 'å¾…æ€»ç»“ï¼šæ³›å‡½åˆ†ææœ¯è¯­', type: 'é—®é¢˜', color: '#ffa857', searchText: 'æ³›å‡½ åˆ†æ æœ¯è¯­ å¾…æ•´ç† åˆ—è¡¨', isTemplated: false },
        { id: 'mid-3003', title: 'è‰ç¨¿ï¼šHilbert ç©ºé—´è¯¾å ‚ç¬”è®°', searchText: 'Hilbert ç©ºé—´ è¯¾å ‚ ç¬”è®° è‰ç¨¿ éœ€è¦è¡¥å……', isTemplated: false },
        { id: 'mid-3004', title: 'å¾…ç¡®è®¤ï¼šæ³¨æ„åŠ›æœºåˆ¶èµ„æ–™æ”¶é›†', type: 'çŸ¥è¯†', color: '#5569ff', searchText: 'æ³¨æ„åŠ› æœºåˆ¶ èµ„æ–™ æ”¶é›† å‚è€ƒ é“¾æ¥ å¾…ç¡®è®¤', isTemplated: false },
        { id: 'mid-3005', title: 'ä¸´æ—¶ï¼šæ¢¯åº¦æ¶ˆå¤±å®éªŒè®°å½•', searchText: 'æ¢¯åº¦ æ¶ˆå¤± å®éªŒ è®°å½• å¾…æ€»ç»“ ç»“æœ', isTemplated: false },
        { id: 'mid-3006', title: 'å°šæœªåˆ†ç±»ï¼šéšæœºæƒ³æ³•å¤‡å¿˜', searchText: 'éšæœº æƒ³æ³• å¤‡å¿˜ ä¸´æ—¶ æ¡ç›® éœ€è¦ åˆ†ç±»', isTemplated: false },
      ];

      const state = {
        config: {
          presetGroups: JSON.parse(JSON.stringify(DEFAULT_PRESET_GROUPS)),
          negativePresets: DEFAULT_NEGATIVE_PRESETS.slice(),
          typeFilters: DEFAULT_TYPE_FILTERS.slice(),
          typeColors: { ...TYPE_COLOR_MAP },
          colorIndexPalette: { ...COLOR_INDEX_PALETTE },
        },
        recentPresets: [],
        datasets: {
          knowledge: {
            label: 'çŸ¥è¯†åº“',
            cards: FAKE_CARDS.slice(),
            count: FAKE_CARDS.length,
          },
          intermediate: {
            label: 'ä¸­é—´çŸ¥è¯†åº“',
            cards: FAKE_INTERMEDIATE.slice(),
            count: FAKE_INTERMEDIATE.length,
          },
        },
        currentDatasetKey: 'knowledge',
        cards: FAKE_CARDS.slice(),
        filteredCards: [],
        activePresets: new Set(),
        activeNegativePresets: new Set(),
        selectedCardId: null,
        userInput: '',
        currentTypeKey: 'all',
        classificationOptions: [],
        currentClassificationSubtype: 'all',
        lastQueryPayload: null,
      };

      const dom = {
        typeSection: document.querySelector('[data-section="type"]'),
        presetSection: document.querySelector('[data-section="preset"]'),
        negativeSection: document.querySelector('[data-section="negative"]'),
        classificationSection: document.querySelector('[data-section="classification"]'),
        datasetToggle: document.getElementById('datasetToggle'),
        presetBar: document.getElementById('presetBar'),
        typeBar: document.getElementById('typeBar'),
        classificationBar: document.getElementById('classificationBar'),
        negativeBar: document.getElementById('negativeBar'),
        results: document.getElementById('results'),
        searchInput: document.getElementById('searchInput'),
        searchCount: document.getElementById('searchCount'),
        selectedCardInfo: document.getElementById('selectedCardInfo'),
        clearBtn: document.getElementById('clearBtn'),
        clearPresetsBtn: document.getElementById('clearPresetsBtn'),
        clearNegativesBtn: document.getElementById('clearNegativesBtn'),
        toast: document.getElementById('toast'),
        sidebar: document.getElementById('sidebar'),
        sidebarToggle: document.getElementById('sidebarToggle'),
        sidebarOverlay: document.getElementById('sidebarOverlay'),
        // Sidebar æŒ‰é’®
        locateInFloatBtn: document.getElementById('locateInFloatBtn'),
        copyMarkdownBtn: document.getElementById('copyMarkdownBtn'),
        mergeToExcerptBtn: document.getElementById('mergeToExcerptBtn'),
        clearAndMergeBtn: document.getElementById('clearAndMergeBtn'),
        bidirectionalLinkBtn: document.getElementById('bidirectionalLinkBtn'),
        moveAsChildBtn: document.getElementById('moveAsChildBtn'),
        moveAsChildAndLocateBtn: document.getElementById('moveAsChildAndLocateBtn'),
        addTemplateAsChildBtn: document.getElementById('addTemplateAsChildBtn'),
        addTemplateAsChildAndLocateBtn: document.getElementById('addTemplateAsChildAndLocateBtn'),
        scrollToTopBtn: document.getElementById('scrollToTopBtn'),
        topbar: document.querySelector('.topbar'),
        container: document.querySelector('.container'),
      };

      let toastTimer = null;
      let lastScrollY = 0;
      let isToolbarHidden = false;
      const debouncedInputHandler = debounce(handleSearchInputChange, 180);

      // ========== è¾…åŠ©å‡½æ•° ==========

      // æ ¼å¼å…¼å®¹ï¼šæ”¯æŒæ—§çš„æ•°ç»„æ ¼å¼å’Œæ–°çš„åˆ†ç»„æ ¼å¼
      function normalizePresetConfig(config) {
        if (!config) return [];
        if (Array.isArray(config)) {
          // æ—§æ ¼å¼ï¼š["è¯1", "è¯2"]
          if (config.length > 0 && typeof config[0] === 'string') {
            return [{ name: 'å¸¸ç”¨', presets: config }];
          }
          // æ–°æ ¼å¼ï¼š[{ name, presets }]
          return config;
        }
        return [];
      }

      // è·å–åŒ…å«"æœ€è¿‘ä½¿ç”¨"çš„åˆ†ç»„åˆ—è¡¨
      function getPresetGroupsWithRecent() {
        const groups = state.config.presetGroups ? [...state.config.presetGroups] : [];
        if (state.recentPresets && state.recentPresets.length > 0) {
          groups.unshift({
            name: 'æœ€è¿‘ä½¿ç”¨',
            icon: 'â±ï¸',
            presets: [...state.recentPresets],
            isRecent: true
          });
        }
        return groups;
      }

      // æ›´æ–°æœ€è¿‘ä½¿ç”¨åˆ—è¡¨
      function updateRecentPresets(preset) {
        if (!preset) return;
        // ç§»é™¤æ—§è®°å½•
        state.recentPresets = state.recentPresets.filter(p => p !== preset);
        // æ·»åŠ åˆ°æœ€å‰é¢
        state.recentPresets.unshift(preset);
        // é™åˆ¶é•¿åº¦ä¸º 8
        if (state.recentPresets.length > 8) {
          state.recentPresets = state.recentPresets.slice(0, 8);
        }
        // ä¿å­˜åˆ° localStorage
        saveRecentPresets();
      }

      // ä¿å­˜æœ€è¿‘ä½¿ç”¨åˆ° localStorage
      function saveRecentPresets() {
        try {
          localStorage.setItem('mnkb_recent_presets', JSON.stringify(state.recentPresets));
        } catch (error) {
          console.warn('ä¿å­˜æœ€è¿‘ä½¿ç”¨å¤±è´¥', error);
        }
      }

      // ä» localStorage åŠ è½½æœ€è¿‘ä½¿ç”¨
      function loadRecentPresets() {
        try {
          const saved = localStorage.getItem('mnkb_recent_presets');
          if (saved) {
            state.recentPresets = JSON.parse(saved);
          }
        } catch (error) {
          console.warn('åŠ è½½æœ€è¿‘ä½¿ç”¨å¤±è´¥', error);
          state.recentPresets = [];
        }
      }

      // ========== åˆå§‹åŒ– ==========

      loadRecentPresets();
      init();

      function init() {
        renderDatasetToggle();
        refreshClassificationOptions();
        renderPresetBar();
        renderTypeBar();
        renderNegativeBar();
        attachEventListeners();
        registerBridge();
        applyFilters(buildQueryPayload());
        setupResponsive();
        setupScrollBehavior();
      }

      function setupResponsive() {
        // æ£€æµ‹æ˜¯å¦æ˜¯ç§»åŠ¨ç«¯æˆ– iPad ç«–å±
        const checkMobile = () => window.innerWidth <= 1024;

        // åˆå§‹åŒ–æ˜¾ç¤ºçŠ¶æ€
        if (dom.sidebarToggle) {
          dom.sidebarToggle.style.display = checkMobile() ? 'flex' : 'none';
        }

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => {
          if (dom.sidebarToggle) {
            dom.sidebarToggle.style.display = checkMobile() ? 'flex' : 'none';
          }
          if (!checkMobile()) {
            closeSidebar();
          }
        });
      }

      function setupScrollBehavior() {
        if (!dom.container) return;

        // èŠ‚æµå‡½æ•°ï¼šé™åˆ¶æ»šåŠ¨äº‹ä»¶å¤„ç†é¢‘ç‡
        let scrollTimeout = null;
        const handleScroll = () => {
          if (scrollTimeout) return;

          scrollTimeout = setTimeout(() => {
            scrollTimeout = null;

            const currentScrollY = dom.container.scrollTop;
            const scrollThreshold = 100; // æ»šåŠ¨è¶…è¿‡ 100px æ—¶è§¦å‘éšè—

            // å‘ä¸‹æ»šåŠ¨ä¸”è¶…è¿‡é˜ˆå€¼ï¼šéšè—å·¥å…·æ 
            if (currentScrollY > scrollThreshold && currentScrollY > lastScrollY && !isToolbarHidden) {
              hideToolbars();
            }
            // å‘ä¸Šæ»šåŠ¨æˆ–å›åˆ°é¡¶éƒ¨ï¼šæ˜¾ç¤ºå·¥å…·æ 
            else if ((currentScrollY < lastScrollY || currentScrollY <= scrollThreshold) && isToolbarHidden) {
              showToolbars();
            }

            // æ›´æ–°æ»šåŠ¨åˆ°é¡¶éƒ¨æŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
            if (currentScrollY > 200) {
              dom.scrollToTopBtn?.classList.add('show');
            } else {
              dom.scrollToTopBtn?.classList.remove('show');
            }

            lastScrollY = currentScrollY;
          }, 100); // 100ms èŠ‚æµ
        };

        // ç›‘å¬å®¹å™¨æ»šåŠ¨äº‹ä»¶
        dom.container.addEventListener('scroll', handleScroll, { passive: true });

        // è¿”å›é¡¶éƒ¨æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        dom.scrollToTopBtn?.addEventListener('click', scrollToTop);
      }

      function hideToolbars() {
        isToolbarHidden = true;

        // æ·»åŠ å…¨å±€éšè—çŠ¶æ€,è§¦å‘ padding-top çš„è¿‡æ¸¡
        document.body.classList.add('toolbar-hidden');

        // éšè—é¡¶éƒ¨æœç´¢æ 
        dom.topbar?.classList.add('hidden');

        // éšè—æ‰€æœ‰å·¥å…·æ 
        const toolbars = [
          dom.typeSection,
          dom.classificationSection,
          dom.presetSection,
          dom.negativeSection
        ];

        toolbars.forEach(toolbar => {
          if (toolbar && !toolbar.classList.contains('component-hidden')) {
            toolbar.classList.add('hidden');
          }
        });
      }

      function showToolbars() {
        isToolbarHidden = false;

        // ç§»é™¤å…¨å±€éšè—çŠ¶æ€,æ¢å¤ padding-top
        document.body.classList.remove('toolbar-hidden');

        // æ˜¾ç¤ºé¡¶éƒ¨æœç´¢æ 
        dom.topbar?.classList.remove('hidden');

        // æ˜¾ç¤ºæ‰€æœ‰å·¥å…·æ 
        const toolbars = [
          dom.typeSection,
          dom.classificationSection,
          dom.presetSection,
          dom.negativeSection
        ];

        toolbars.forEach(toolbar => {
          if (toolbar) {
            toolbar.classList.remove('hidden');
          }
        });
      }

      function scrollToTop() {
        if (!dom.container) return;

        // å¹³æ»‘æ»šåŠ¨åˆ°é¡¶éƒ¨
        dom.container.scrollTo({
          top: 0,
          behavior: 'smooth'
        });
      }

      function toggleSidebar() {
        if (!dom.sidebar) return;

        const isShow = dom.sidebar.classList.contains('show');
        if (isShow) {
          closeSidebar();
        } else {
          openSidebar();
        }
      }

      function openSidebar() {
        dom.sidebar?.classList.add('show');
        dom.sidebarOverlay?.classList.add('show');
      }

      function closeSidebar() {
        dom.sidebar?.classList.remove('show');
        dom.sidebarOverlay?.classList.remove('show');
      }

      function attachEventListeners() {
        dom.searchInput.addEventListener('input', debouncedInputHandler, { passive: true });
        dom.clearBtn.addEventListener('click', handleClearFilters);
        dom.clearPresetsBtn?.addEventListener('click', handleClearPresets);
        dom.clearNegativesBtn?.addEventListener('click', handleClearNegatives);

        // Sidebar æŒ‰é’®äº‹ä»¶
        dom.locateInFloatBtn?.addEventListener('click', () => handleSidebarAction('locateInFloat'));
        dom.copyMarkdownBtn?.addEventListener('click', () => handleSidebarAction('copyMarkdown'));
        dom.mergeToExcerptBtn?.addEventListener('click', () => handleSidebarAction('mergeToExcerpt'));
        dom.clearAndMergeBtn?.addEventListener('click', () => handleSidebarAction('clearAndMerge'));
        dom.bidirectionalLinkBtn?.addEventListener('click', () => handleSidebarAction('bidirectionalLink'));
        dom.moveAsChildBtn?.addEventListener('click', () => handleSidebarAction('moveAsChild'));
        dom.moveAsChildAndLocateBtn?.addEventListener('click', () => handleSidebarAction('moveAsChildAndLocate'));
        dom.addTemplateAsChildBtn?.addEventListener('click', () => handleSidebarAction('addTemplateAsChild'));
        dom.addTemplateAsChildAndLocateBtn?.addEventListener('click', () => handleSidebarAction('addTemplateAsChildAndLocate'));

        dom.datasetToggle?.querySelectorAll('button').forEach((btn) => {
          btn.addEventListener('click', () => setActiveDataset(btn.dataset.dataset, { requestIfEmpty: true }));
        });

        // Sidebar åˆ‡æ¢
        dom.sidebarToggle?.addEventListener('click', toggleSidebar);
        dom.sidebarOverlay?.addEventListener('click', closeSidebar);
      }

      function handleSearchInputChange() {
        state.userInput = dom.searchInput.value.trim();
        scheduleSearch();
      }

      function handleClearFilters() {
        dom.searchInput.value = '';
        state.userInput = '';
        state.activePresets.clear();
        state.activeNegativePresets.clear();
        state.currentTypeKey = state.config.typeFilters[0]?.key || 'all';
        state.currentClassificationSubtype = 'all';
        refreshClassificationOptions();
        renderPresetBar();
        renderTypeBar();
        renderClassificationBar();
        renderNegativeBar();
        clearSelection();
        scheduleSearch();
      }

      function handleClearPresets() {
        if (state.activePresets.size === 0) return;

        state.activePresets.clear();
        renderPresetBar();
        scheduleSearch();
        showToast('å·²æ¸…é™¤æ‰€æœ‰é¢„è®¾');
      }

      function handleClearNegatives() {
        if (state.activeNegativePresets.size === 0) return;

        state.activeNegativePresets.clear();
        renderNegativeBar();
        scheduleSearch();
        showToast('å·²æ¸…é™¤æ‰€æœ‰æ’é™¤è¯');
      }

      function updateClearPresetsButton() {
        if (!dom.clearPresetsBtn) return;

        if (state.activePresets.size === 0) {
          dom.clearPresetsBtn.classList.add('disabled');
        } else {
          dom.clearPresetsBtn.classList.remove('disabled');
        }
      }

      function updateClearNegativesButton() {
        if (!dom.clearNegativesBtn) return;

        if (state.activeNegativePresets.size === 0) {
          dom.clearNegativesBtn.classList.add('disabled');
        } else {
          dom.clearNegativesBtn.classList.remove('disabled');
        }
      }

      function renderDatasetToggle() {
        if (!dom.datasetToggle) return;
        dom.datasetToggle.querySelectorAll('button').forEach((btn) => {
          const key = btn.dataset.dataset;
          if (!key) return;
          const dataset = state.datasets[key];
          btn.classList.toggle('active', key === state.currentDatasetKey);
          if (dataset && dataset.label) {
            const count = dataset.count ?? dataset.cards?.length ?? 0;
            btn.textContent = count ? `${dataset.label} (${count})` : dataset.label;
          }
        });
      }

      function setActiveDataset(datasetKey, options = {}) {
        if (!datasetKey || datasetKey === state.currentDatasetKey) return;
        const dataset = state.datasets[datasetKey];
        if (!dataset) {
          showToast('æ•°æ®æºæœªå‡†å¤‡å¥½');
          return;
        }
        const requestIfEmpty = options.requestIfEmpty !== false;
        state.currentDatasetKey = datasetKey;
        state.cards = (dataset.cards || []).slice();
        state.currentClassificationSubtype = 'all';
        clearSelection();
        renderDatasetToggle();
        if (!state.cards.length && requestIfEmpty) {
          postBridge('requestDataset', { datasetKey });
        }
        refreshClassificationOptions();
        scheduleSearch({ triggerNative: false });
      }

      function updateDatasetCards(datasetKey, cards, { replace = true } = {}) {
        if (!datasetKey) datasetKey = state.currentDatasetKey;
        const current = state.datasets[datasetKey] || { label: datasetKey, cards: [] };
        const sanitized = Array.isArray(cards) ? cards.filter(Boolean) : [];
        if (replace) {
          current.cards = sanitized.slice();
        } else {
          const existing = new Map((current.cards || []).map((item) => [item.id, item]));
          sanitized.forEach((item) => {
            if (!item || !item.id || existing.has(item.id)) return;
            existing.set(item.id, item);
          });
          current.cards = Array.from(existing.values());
        }
        current.count = current.cards.length;
        if (!current.label) current.label = datasetKey;
        state.datasets[datasetKey] = current;

        if (datasetKey === state.currentDatasetKey) {
          state.cards = current.cards.slice();
          clearSelection();
          refreshClassificationOptions();
          scheduleSearch({ triggerNative: false });
        }

        renderDatasetToggle();
      }

      function renderPresetBar() {
        const groups = getPresetGroupsWithRecent();
        dom.presetBar.innerHTML = '';

        if (!groups.length) {
          dom.presetSection?.classList.add('component-hidden');
          return;
        }
        dom.presetSection?.classList.remove('component-hidden');

        groups.forEach((group) => {
          if (!group || !group.presets || !group.presets.length) return;

          // åˆ›å»ºåˆ†ç»„å®¹å™¨
          const groupDiv = document.createElement('div');
          groupDiv.className = 'preset-group';
          if (group.isRecent) {
            groupDiv.classList.add('preset-group--recent');
          }

          // åˆ›å»ºåˆ†ç»„æ ‡ç­¾
          const label = document.createElement('div');
          label.className = 'preset-group__label';
          const labelText = (group.icon ? group.icon + ' ' : '') + group.name;
          label.textContent = labelText;
          groupDiv.appendChild(label);

          // åˆ›å»ºé¢„è®¾è¯è¡Œ
          const pillRow = document.createElement('div');
          pillRow.className = 'pill-row';

          group.presets.forEach((preset) => {
            const pill = document.createElement('div');
            pill.className = 'pill';
            if (state.activePresets.has(preset)) pill.classList.add('active');
            pill.textContent = preset;
            pill.tabIndex = 0;

            const toggle = () => {
              if (state.activePresets.has(preset)) {
                state.activePresets.delete(preset);
              } else {
                state.activePresets.add(preset);
                // æ›´æ–°æœ€è¿‘ä½¿ç”¨
                updateRecentPresets(preset);
              }
              renderPresetBar();
              scheduleSearch();
            };

            pill.addEventListener('click', toggle);
            pill.addEventListener('keydown', (event) => {
              if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                toggle();
              }
            });
            pillRow.appendChild(pill);
          });

          groupDiv.appendChild(pillRow);
          dom.presetBar.appendChild(groupDiv);
        });

        updateClearPresetsButton();
      }

      function renderNegativeBar() {
        const presets = state.config.negativePresets || [];
        dom.negativeBar.innerHTML = '';
        if (!presets.length) {
          dom.negativeSection?.classList.add('component-hidden');
          return;
        }
        dom.negativeSection?.classList.remove('component-hidden');

        presets.forEach((preset) => {
          const pill = document.createElement('div');
          pill.className = 'pill negative';
          if (state.activeNegativePresets.has(preset)) pill.classList.add('active');
          pill.textContent = preset;
          pill.tabIndex = 0;
          const toggle = () => {
            if (state.activeNegativePresets.has(preset)) {
              state.activeNegativePresets.delete(preset);
            } else {
              state.activeNegativePresets.add(preset);
            }
            renderNegativeBar();
            scheduleSearch();
          };
          pill.addEventListener('click', toggle);
          pill.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              toggle();
            }
          });
          dom.negativeBar.appendChild(pill);
        });

        updateClearNegativesButton();
      }

      function renderTypeBar() {
        const filters = state.config.typeFilters || [];
        dom.typeBar.innerHTML = '';
        if (!filters.length) {
          dom.typeSection?.classList.add('component-hidden');
          return;
        }
        dom.typeSection?.classList.remove('component-hidden');

        filters.forEach((filter) => {
          const pill = document.createElement('div');
          pill.className = 'pill';
          if (filter.key === state.currentTypeKey) pill.classList.add('active');
          pill.textContent = filter.label || filter.key;
          pill.dataset.key = filter.key;
          pill.tabIndex = 0;
          const select = () => {
            state.currentTypeKey = filter.key;
            renderTypeBar();
            renderClassificationBar();
            scheduleSearch();
          };
          pill.addEventListener('click', select);
          pill.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              select();
            }
          });
          dom.typeBar.appendChild(pill);
        });

        renderClassificationBar();
      }

      function refreshClassificationOptions() {
        const options = new Set();
        (state.cards || []).forEach((card) => {
          if (!card) return;
          if (card.type === 'å½’ç±»' && card.classificationSubtype) {
            options.add(card.classificationSubtype);
          }
        });
        state.classificationOptions = Array.from(options).sort();
        if (
          state.currentClassificationSubtype !== 'all' &&
          !state.classificationOptions.includes(state.currentClassificationSubtype)
        ) {
          state.currentClassificationSubtype = 'all';
        }
        renderClassificationBar();
      }

      function shouldShowClassificationFilter() {
        if (!dom.classificationSection || !state.classificationOptions.length) return false;
        const preset = getCurrentTypePreset();
        const types = preset.types;
        return Array.isArray(types) && types.includes('å½’ç±»');
      }

      function renderClassificationBar() {
        if (!dom.classificationBar || !dom.classificationSection) return;
        if (!shouldShowClassificationFilter()) {
          dom.classificationSection.classList.add('component-hidden');
          dom.classificationBar.innerHTML = '';
          state.currentClassificationSubtype = 'all';

          // å½’ç±»åŒºåŸŸéšè—æ—¶ï¼Œè°ƒæ•´æ’é™¤å’Œé¢„è®¾åŒºåŸŸçš„ä½ç½®
          document.documentElement.style.setProperty('--negative-top', 'calc(var(--topbar-height) + var(--toolbar-gap))');
          document.documentElement.style.setProperty('--preset-top', 'calc(var(--topbar-height) + var(--toolbar-gap) * 2)');
          document.documentElement.style.setProperty('--main-padding-top', 'calc(var(--topbar-height) + var(--toolbar-gap) + var(--negative-height) + var(--preset-max-height) + var(--spacing-buffer))');
          return;
        }

        dom.classificationSection.classList.remove('component-hidden');
        dom.classificationBar.innerHTML = '';

        // å½’ç±»åŒºåŸŸæ˜¾ç¤ºæ—¶ï¼Œæ¢å¤æ’é™¤å’Œé¢„è®¾åŒºåŸŸçš„é»˜è®¤ä½ç½®
        document.documentElement.style.setProperty('--negative-top', 'calc(var(--topbar-height) + var(--toolbar-gap) * 2)');
        document.documentElement.style.setProperty('--preset-top', 'calc(var(--topbar-height) + var(--toolbar-gap) * 3)');
        document.documentElement.style.setProperty('--main-padding-top', 'calc(var(--topbar-height) + var(--toolbar-gap) * 2 + var(--negative-height) + var(--preset-max-height) + var(--spacing-buffer))');

        const options = ['all', ...state.classificationOptions];
        options.forEach((option) => {
          const pill = document.createElement('div');
          pill.className = 'pill';
          const isAll = option === 'all';
          const value = isAll ? 'all' : option;
          if (state.currentClassificationSubtype === value) pill.classList.add('active');
          pill.textContent = isAll ? 'å…¨éƒ¨å­ç±»å‹' : option;
          pill.dataset.subtype = value;
          pill.tabIndex = 0;
          const select = () => {
            state.currentClassificationSubtype = value;
            renderClassificationBar();
            scheduleSearch({ triggerNative: false });
          };
          pill.addEventListener('click', select);
          pill.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              select();
            }
          });
          dom.classificationBar.appendChild(pill);
        });
      }

      function scheduleSearch(options = {}) {
        const payload = buildQueryPayload();
        state.lastQueryPayload = payload;

        const shouldNotifyNative = options.triggerNative !== false;
        if (shouldNotifyNative && window.MNKBBridge && typeof window.MNKBBridge.performSearch === 'function') {
          try {
            window.MNKBBridge.performSearch(payload);
          } catch (error) {
            console.warn('performSearch è°ƒç”¨å¤±è´¥', error);
          }
        }

        applyFilters(payload);
      }

      function buildQueryPayload() {
        const currentType = getCurrentTypePreset();
        const includePresets = Array.from(state.activePresets);
        const excludePresets = Array.from(state.activeNegativePresets);
        const highlightTokens = deriveTokens(state.userInput, includePresets);

        return {
          rawInput: state.userInput,
          includePresets,
          excludePresets,
          typeKey: currentType.key,
          typeList: currentType.types ? currentType.types.slice() : null,
          classificationSubtype: state.currentClassificationSubtype,
          highlightTokens,
          tokensLower: highlightTokens.map((token) => token.toLowerCase()),
          timestamp: Date.now(),
        };
      }

      function deriveTokens(rawInput, includePresets) {
        const tokens = [];

        // æ™ºèƒ½ç©ºæ ¼åˆ†éš”ï¼šæ£€æµ‹æ˜¯å¦æœ‰åŒç©ºæ ¼
        if (rawInput) {
          let parts;
          if (/\s{2,}/.test(rawInput)) {
            // æœ‰åŒç©ºæ ¼ï¼šæŒ‰åŒç©ºæ ¼åˆ†å‰²ï¼Œä¿ç•™å•ç©ºæ ¼ä½œä¸ºçŸ­è¯­çš„ä¸€éƒ¨åˆ†
            parts = rawInput.split(/\s{2,}/);
          } else {
            // æ— åŒç©ºæ ¼ï¼šæŒ‰å•ç©ºæ ¼åˆ†å‰²
            parts = rawInput.split(/\s+/);
          }

          parts.forEach((part) => {
            const value = part.trim();
            if (value && !tokens.includes(value)) tokens.push(value);
          });
        }

        // é¢„è®¾è¯å§‹ç»ˆä½œä¸ºç‹¬ç«‹ token
        (includePresets || []).forEach((part) => {
          const value = part.trim();
          if (value && !tokens.includes(value)) tokens.push(value);
        });

        return tokens;
      }

      function getCurrentTypePreset() {
        const filters = state.config.typeFilters || [];
        const fallback = filters[0] || { key: 'all', label: 'å…¨éƒ¨ç±»å‹', types: null };
        return filters.find((filter) => filter.key === state.currentTypeKey) || fallback;
      }

      function applyFilters(payload) {
        const query = payload || state.lastQueryPayload || buildQueryPayload();
        const allowedTypes = query.typeList ? new Set(query.typeList) : null;
        const negatives = query.excludePresets.map((word) => word.toLowerCase());
        const tokensLower = query.tokensLower;
        const highlightTokens = query.highlightTokens;

        const results = [];
        const availableIds = new Set();
        const subtypeFilter = query.classificationSubtype;
        const enforceSubtype = subtypeFilter && subtypeFilter !== 'all';

        (state.cards || []).forEach((card) => {
          if (!card || !card.id) return;

          const normalizedType = card.type && String(card.type).trim() ? card.type : RAW_TYPE_LABEL;
          availableIds.add(card.id);

          if (allowedTypes && allowedTypes.size > 0 && !allowedTypes.has(normalizedType)) {
            return;
          }

          if (enforceSubtype && normalizedType === 'å½’ç±»') {
            if (!card.classificationSubtype || card.classificationSubtype !== subtypeFilter) {
              return;
            }
          }

          if (!passesNegativeFilter(card, negatives)) return;

          const evaluation = evaluateCard({ ...card, type: normalizedType }, tokensLower);
          // AND é€»è¾‘ï¼šæ‰€æœ‰å…³é”®è¯å¿…é¡»åŒ¹é…
          if (tokensLower.length > 0 && evaluation.matchCount < tokensLower.length) return;

          const prepared = { ...card, type: normalizedType };
          prepared.matchCount = evaluation.matchCount;
          prepared.score = typeof card.score === 'number' ? card.score : evaluation.score;
          if (!card.type) prepared.isRaw = true;

          if (!prepared.titleHtml) {
            prepared.titleHtml = highlightTextWithTokens(prepared.title || '', highlightTokens);
          }

          if (!prepared.snippetHtml) {
            const sourceText = prepared.snippet || prepared.searchText || prepared.title || '';
            const snippet = extractSnippet(sourceText, tokensLower);
            prepared.snippetHtml = highlightTextWithTokens(snippet, highlightTokens);
          }

          results.push(prepared);
        });

        pruneSelections(availableIds);

        results.sort((a, b) => {
          const scoreDiff = (b.score || 0) - (a.score || 0);
          if (scoreDiff !== 0) return scoreDiff;
          return (a.title || '').localeCompare(b.title || '');
        });

        state.filteredCards = results;
        renderResults(results);
      }

      function passesNegativeFilter(card, negativeTokens) {
        if (!negativeTokens || negativeTokens.length === 0) return true;

        if (card.excludedGroups && Array.isArray(card.excludedGroups) && card.excludedGroups.length > 0) {
          const hit = card.excludedGroups.some((group) => {
            if (!group) return false;
            const pool = [
              group.groupName || '',
              ...(group.excludeWords || []),
              ...(group.affectedTriggers || []),
            ]
              .join(' ')
              .toLowerCase();
            return negativeTokens.some((token) => pool.includes(token));
          });
          if (hit) return false;
        }

        const text = [
          card.title || '',
          card.searchText || '',
          card.snippet || '',
          card.content || '',
        ]
          .join(' ')
          .toLowerCase();

        return !negativeTokens.some((token) => token && text.includes(token));
      }

      function evaluateCard(card, tokensLower) {
        if (!tokensLower || tokensLower.length === 0) {
          return { score: card.score || 0, matchCount: 0, matchedTokens: new Set() };
        }

        const baseScore = typeof card.score === 'number' ? card.score : 0;
        let score = baseScore;
        const matchedTokens = new Set();

        const title = (card.title || '').toLowerCase();
        const type = (card.type || '').toLowerCase();
        const subtype = (card.classificationSubtype || '').toLowerCase();
        const searchText = (card.searchText || '').toLowerCase();
        const keywords = (card.keywords || '').toLowerCase();
        const prefix = (card.prefix || '').toLowerCase();
        const snippet = (card.snippet || '').toLowerCase();

        tokensLower.forEach((token) => {
          if (!token) return;
          let hit = false;

          if (title.includes(token)) {
            score += 60;
            hit = true;
          }
          if (searchText.includes(token)) {
            score += 25;
            hit = true;
          }
          if (keywords.includes(token)) {
            score += 20;
            hit = true;
          }
          if (prefix.includes(token)) {
            score += 18;
            hit = true;
          }
          if (type.includes(token)) {
            score += 12;
            hit = true;
          }
          if (subtype && subtype.includes(token)) {
            score += 14;
            hit = true;
          }
          if (snippet.includes(token)) {
            score += 8;
            hit = true;
          }

          if (hit) matchedTokens.add(token);
        });

        return { score, matchCount: matchedTokens.size, matchedTokens };
      }

      function extractSnippet(text, tokensLower) {
        if (!text) return '';
        if (!tokensLower || tokensLower.length === 0) {
          return text.length > 120 ? `${text.slice(0, 120)}â€¦` : text;
        }

        const lower = text.toLowerCase();
        let firstIndex = -1;
        tokensLower.forEach((token) => {
          const idx = lower.indexOf(token);
          if (idx !== -1 && (firstIndex === -1 || idx < firstIndex)) {
            firstIndex = idx;
          }
        });

        if (firstIndex === -1) {
          return text.length > 120 ? `${text.slice(0, 120)}â€¦` : text;
        }

        const start = Math.max(0, firstIndex - 30);
        const end = Math.min(text.length, firstIndex + 80);
        const prefix = start > 0 ? 'â€¦' : '';
        const suffix = end < text.length ? 'â€¦' : '';
        return `${prefix}${text.slice(start, end)}${suffix}`;
      }

      function renderResults(items) {
        dom.results.innerHTML = '';
        const fragment = document.createDocumentFragment();

        items.forEach((card) => {
          const element = document.createElement('div');
          element.className = 'card';
          element.dataset.id = card.id;

          if (state.selectedCardId === card.id) {
            element.classList.add('selected');
          }

          const color = resolveTypeColor(card);
          element.style.borderLeftColor = color;

          // æ·»åŠ å®šä½å›¾æ ‡
          const locateIcon = document.createElement('div');
          locateIcon.className = 'card-locate-icon';
          locateIcon.textContent = 'ğŸ“';
          locateIcon.title = 'åœ¨ä¸»è„‘å›¾å®šä½';
          locateIcon.addEventListener('click', (e) => {
            e.stopPropagation(); // é˜»æ­¢å†’æ³¡åˆ°å¡ç‰‡ç‚¹å‡»äº‹ä»¶
            handleCardLocate(card.id);
          });

          const title = document.createElement('div');
          title.className = 'card-title';
          title.innerHTML = card.titleHtml || escapeHtml(card.title || '');

          const meta = document.createElement('div');
          meta.className = 'card-meta';

          const typeBadge = document.createElement('span');
          typeBadge.className = 'card-type';
          typeBadge.style.background = color;
          typeBadge.textContent = card.type || 'æœªçŸ¥ç±»å‹';
          meta.appendChild(typeBadge);

          if (card.type === 'å½’ç±»' && card.classificationSubtype) {
            const subBadge = document.createElement('span');
            subBadge.className = 'classification-subtype';
            subBadge.textContent = card.classificationSubtype;
            meta.appendChild(subBadge);
          }

          if (typeof card.matchCount === 'number' && card.matchCount > 0) {
            const mc = document.createElement('span');
            mc.className = 'match-count';
            mc.textContent = `åŒ¹é… ${card.matchCount}`;
            meta.appendChild(mc);
          }

          if (typeof card.score === 'number') {
            const scoreChip = document.createElement('span');
            scoreChip.className = 'chip-score';
            scoreChip.textContent = `score ${Math.round(card.score)}`;
            meta.appendChild(scoreChip);
          }

          element.appendChild(locateIcon);
          element.appendChild(title);
          element.appendChild(meta);

          if (card.snippetHtml) {
            const snippet = document.createElement('div');
            snippet.className = 'card-snippet';
            snippet.innerHTML = card.snippetHtml;
            element.appendChild(snippet);
          }

          element.addEventListener('click', () => toggleSelection(card.id, element));
          fragment.appendChild(element);
        });

        dom.results.appendChild(fragment);
        updateSearchCount(items.length);
        updateSelectionInfo();
        updateActionButtonsState();
      }

      function resolveTypeColor(card) {
        if (card.color && /^#/.test(card.color)) return card.color;
        if (typeof card.colorIndex === 'number' && state.config.colorIndexPalette[card.colorIndex]) {
          return state.config.colorIndexPalette[card.colorIndex];
        }
        if (card.type && state.config.typeColors[card.type]) {
          return state.config.typeColors[card.type];
        }
        return '#d4d9e6';
      }

      function toggleSelection(cardId, element) {
        if (!cardId) return;
        if (state.selectedCardId === cardId) {
          state.selectedCardId = null;
          if (element) element.classList.remove('selected');
        } else {
          state.selectedCardId = cardId;
          dom.results.querySelectorAll('.card.selected').forEach((node) => node.classList.remove('selected'));
          if (element) element.classList.add('selected');
        }
        updateSelectionInfo();
        updateActionButtonsState();
      }

      function pruneSelections(availableIds) {
        if (state.selectedCardId && !availableIds.has(state.selectedCardId)) {
          state.selectedCardId = null;
          updateSelectionInfo();
          updateActionButtonsState();
        }
      }

      function clearSelection() {
        if (!state.selectedCardId) return;
        state.selectedCardId = null;
        dom.results.querySelectorAll('.card.selected').forEach((node) => node.classList.remove('selected'));
        updateSelectionInfo();
        updateActionButtonsState();
      }

      function updateSearchCount(count) {
        dom.searchCount.textContent = `${count} æ¡ç»“æœ`;
      }

      function updateSelectionInfo() {
        if (!state.selectedCardId) {
          dom.selectedCardInfo.textContent = 'æœªé€‰ä¸­å¡ç‰‡';
          dom.selectedCardInfo.classList.add('empty');
          return;
        }

        const selected = state.cards.find((item) => item.id === state.selectedCardId) ||
                        state.filteredCards.find((item) => item.id === state.selectedCardId);

        if (selected) {
          const title = selected.title || '(æ— æ ‡é¢˜)';
          const type = selected.type || 'æœªåˆ†ç±»';

          // æ„å»ºç±»å‹æ˜¾ç¤ºæ–‡æœ¬
          let typeDisplay = type;
          if (type === 'å½’ç±»' && selected.classificationSubtype) {
            typeDisplay = `${type} - ${selected.classificationSubtype}`;
          }

          dom.selectedCardInfo.innerHTML = `<strong>${title}</strong><br><small>${typeDisplay}</small>`;
          dom.selectedCardInfo.classList.remove('empty');
        } else {
          dom.selectedCardInfo.textContent = 'å·²é€‰ 1 é¡¹';
          dom.selectedCardInfo.classList.remove('empty');
        }
      }

      function updateActionButtonsState() {
        const disabled = !state.selectedCardId;

        // æ›´æ–°æ‰€æœ‰ Sidebar æŒ‰é’®çŠ¶æ€
        const sidebarButtons = [
          dom.locateInFloatBtn,
          dom.copyMarkdownBtn,
          dom.mergeToExcerptBtn,
          dom.clearAndMergeBtn,
          dom.bidirectionalLinkBtn,
          dom.moveAsChildBtn,
          dom.moveAsChildAndLocateBtn,
          dom.addTemplateAsChildBtn,
          dom.addTemplateAsChildAndLocateBtn,
        ];

        sidebarButtons.forEach((btn) => {
          if (btn) btn.disabled = disabled;
        });
      }

      function handleCardLocate(cardId) {
        if (!cardId) return;

        if (!postBridge('locateInMindMap', { id: cardId })) {
          showToast('åŠŸèƒ½å¼€å‘ä¸­ï¼šåœ¨ä¸»è„‘å›¾å®šä½');
        }
      }

      function handleSidebarAction(action) {
        if (!state.selectedCardId) {
          showToast('è¯·å…ˆé€‰æ‹©å¡ç‰‡');
          return;
        }

        const id = state.selectedCardId;
        const card = state.cards.find((item) => item.id === id) ||
                     state.filteredCards.find((item) => item.id === id) ||
                     { title: id };

        switch (action) {
          case 'locateInFloat':
            if (!postBridge('locateInFloat', { id })) {
              showToast('åŠŸèƒ½å¼€å‘ä¸­ï¼šåœ¨æµ®çª—ä¸­å®šä½');
            }
            break;

          case 'copyMarkdown': {
            const title = card.title || id;
            const markdown = `[${title}](marginnote4app://note/${id})`;
            copyToClipboard(markdown, 'å·²å¤åˆ¶ Markdown é“¾æ¥');
            break;
          }

          case 'mergeToExcerpt':
            showToast('åŠŸèƒ½å¼€å‘ä¸­ï¼šåˆå¹¶åˆ°ç›®æ ‡å¡ç‰‡');
            break;

          case 'clearAndMerge':
            showToast('åŠŸèƒ½å¼€å‘ä¸­ï¼šæ¸…ç©ºæ ‡é¢˜å¹¶åˆå¹¶');
            break;

          case 'bidirectionalLink':
            showToast('åŠŸèƒ½å¼€å‘ä¸­ï¼šåŒå‘é“¾æ¥');
            break;

          case 'moveAsChild':
            showToast('åŠŸèƒ½å¼€å‘ä¸­ï¼šç§»åˆ°å­å¡ç‰‡');
            break;

          case 'moveAsChildAndLocate':
            showToast('åŠŸèƒ½å¼€å‘ä¸­ï¼šç§»åˆ°å­å¡ç‰‡å¹¶å®šä½');
            break;

          case 'addTemplateAsChild':
            showToast('åŠŸèƒ½å¼€å‘ä¸­ï¼šå¢åŠ æ¨¡æ¿å¹¶æ·»åŠ ä¸ºå­å¡ç‰‡');
            break;

          case 'addTemplateAsChildAndLocate':
            showToast('åŠŸèƒ½å¼€å‘ä¸­ï¼šå¢åŠ æ¨¡æ¿å¹¶æ·»åŠ ä¸ºå­å¡ç‰‡å¹¶å®šä½');
            break;

          default:
            showToast('æœªçŸ¥æ“ä½œ');
            break;
        }
      }

      function copyToClipboard(text, successMessage = 'å·²å¤åˆ¶') {
        if (!text) {
          showToast('æ— å¯å¤åˆ¶çš„å†…å®¹');
          return;
        }

        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
          navigator.clipboard
            .writeText(text)
            .then(() => showToast(successMessage))
            .catch(() => fallbackCopy(text, successMessage));
        } else {
          fallbackCopy(text, successMessage);
        }
      }

      function fallbackCopy(text, successMessage) {
        try {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          try {
            textarea.focus({ preventScroll: true });
          } catch (focusError) {
            textarea.focus();
          }
          textarea.select();
          const ok = document.execCommand('copy');
          document.body.removeChild(textarea);
          if (ok) {
            showToast(successMessage);
          } else {
            showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·åœ¨åŸç”Ÿç«¯ä½¿ç”¨');
          }
        } catch (error) {
          console.warn('fallback copy failed', error);
          showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·åœ¨åŸç”Ÿç«¯ä½¿ç”¨');
        }
      }

      function registerBridge() {
        const api = {
          setSearchResults(results, options = {}) {
            const datasetKey = options.datasetKey || state.currentDatasetKey;
            setCardsForDataset(datasetKey, results, options);
          },
          appendSearchResults(results, options = {}) {
            const datasetKey = options.datasetKey || state.currentDatasetKey;
            setCardsForDataset(datasetKey, results, { replace: false });
          },
          setPresets(presets) {
            if (!presets) return;
            // æ”¯æŒæ–°æ—§ä¸¤ç§æ ¼å¼
            state.config.presetGroups = normalizePresetConfig(presets);
            state.activePresets.clear();
            renderPresetBar();
            scheduleSearch({ triggerNative: false });
          },
          setNegativePresets(presets) {
            if (!Array.isArray(presets)) return;
            state.config.negativePresets = Array.from(new Set(presets.filter(Boolean)));
            state.activeNegativePresets.clear();
            renderNegativeBar();
            scheduleSearch({ triggerNative: false });
          },
          setTypeFilters(filters) {
            if (!Array.isArray(filters) || !filters.length) return;
            state.config.typeFilters = filters
              .map((filter, index) => ({
                key: filter.key || filter.value || `preset-${index}`,
                label: filter.label || filter.name || filter.key || `ç±»å‹ ${index + 1}`,
                types: Array.isArray(filter.types) ? filter.types.slice() : null,
              }))
              .filter(Boolean);

            state.currentTypeKey = state.config.typeFilters[0]?.key || 'all';
            renderTypeBar();
            scheduleSearch({ triggerNative: false });
          },
          updateConfig(config) {
            if (!config || typeof config !== 'object') return;
            if (config.typeColors) {
              state.config.typeColors = { ...state.config.typeColors, ...config.typeColors };
            }
            if (config.colorIndexPalette) {
              state.config.colorIndexPalette = { ...state.config.colorIndexPalette, ...config.colorIndexPalette };
            }
            scheduleSearch({ triggerNative: false });
          },
          resetSelection() {
            clearSelection();
          },
          switchDataset(datasetKey) {
            setActiveDataset(datasetKey, { requestIfEmpty: true });
          },
          showToast,
          postMessage: postBridge,
        };

        window.MNKB = Object.assign({}, window.MNKB || {}, api);

        if (!window.MNKBBridge) {
          window.MNKBBridge = {};
        }
        if (typeof window.MNKBBridge.performSearch !== 'function') {
          window.MNKBBridge.performSearch = function () {
            return false;
          };
        }
        if (typeof window.MNKBBridge.postMessage !== 'function') {
          window.MNKBBridge.postMessage = function (action, params) {
            postToAddon(action, params);
          };
        }
      }

      function setCardsForDataset(datasetKey, results, options = {}) {
        updateDatasetCards(datasetKey, results, { replace: options.replace !== false });
      }

      function postBridge(action, params = {}) {
        try {
          if (window.MNKBBridge && typeof window.MNKBBridge.postMessage === 'function') {
            window.MNKBBridge.postMessage(action, params);
            return true;
          }
        } catch (error) {
          console.warn('postMessage è°ƒç”¨å¤±è´¥', error);
        }

        try {
          postToAddon(action, params);
          return true;
        } catch (error) {
          console.warn('postToAddon è°ƒç”¨å¤±è´¥', error);
        }

        return false;
      }

      function postToAddon(action, params = {}) {
        const scheme = 'mnaddon';
        const payload = { action, ...params };
        const url = generateUrlScheme(scheme, '', payload);
        window.location.href = url;
      }

      function generateUrlScheme(scheme, path, params) {
        let url = `${scheme}://${path || ''}`;
        const keys = Object.keys(params || {});
        if (keys.length > 0) {
          const query = keys
            .map((key) => {
              const value = params[key];
              const serialised = typeof value === 'object' ? JSON.stringify(value) : value;
              return `${encodeURIComponent(key)}=${encodeURIComponent(serialised)}`;
            })
            .join('&');
          url += query ? `?${query}` : '';
        }
        return url;
      }

      function showToast(message, duration = 1600) {
        if (!dom.toast) return;
        dom.toast.textContent = message;
        dom.toast.classList.add('show');
        clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
          dom.toast.classList.remove('show');
        }, duration);
      }

      function escapeHtml(text) {
        if (!text) return '';
        return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }

      function highlightTextWithTokens(text, tokens) {
        if (!text) return '';
        if (!tokens || tokens.length === 0) {
          if (/<[^>]+>/.test(text)) return text;
          return escapeHtml(text);
        }

        if (/<[^>]+>/.test(text)) {
          // å·²ç»æ˜¯é«˜äº®/å¯Œæ–‡æœ¬ï¼Œç›´æ¥è¿”å›
          return text;
        }

        let safe = escapeHtml(text);
        const placeholders = [];
        const sorted = tokens.slice().sort((a, b) => b.length - a.length);

        sorted.forEach((token, index) => {
          if (!token) return;
          const regexp = new RegExp(escapeRegExp(token), 'ig');
          safe = safe.replace(regexp, (match) => {
            const key = `__HL_${index}_${placeholders.length}__`;
            placeholders.push({ key, text: match });
            return key;
          });
        });

        placeholders.forEach((placeholder) => {
          safe = safe.split(placeholder.key).join(`<mark class="matched">${placeholder.text}</mark>`);
        });

        return safe;
      }

      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\$&');
      }

      function debounce(fn, wait) {
        let timer = null;
        return function (...args) {
          clearTimeout(timer);
          timer = setTimeout(() => fn.apply(this, args), wait);
        };
      }
    })();
  </script>
</body>
</html>
