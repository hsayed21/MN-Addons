<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MNKnowledgeBase - 搜索可视化框架</title>
  <style>
  :root{
      --bg:#f7f8fb;
      --card-bg:#fff;
      --accent:#2b7cff;
      --muted:#666;
      --pill-bg:#eef5ff;
      --pill-active-bg:#cfe1ff;
      --shadow: 0 1px 3px rgba(0,0,0,0.08);
    }
    html,body{height:100%;margin:0;font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#111}

    /* 固定顶部搜索栏 */
    .topbar{
      position:sticky; top:0; z-index:80; backdrop-filter: blur(6px);
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(250,250,250,0.9));
      border-bottom: 1px solid #e6e9ef;
      padding:14px 20px; display:flex; gap:12px; align-items:center;
    }
    .search-input-wrap{display:flex; gap:8px; align-items:center; flex:1}
    .search-input{flex:1; padding:10px 14px; border-radius:10px; border:1px solid #d6dbe8; background:var(--card-bg); box-shadow:var(--shadow); font-size:15px}
    .search-count{color:var(--muted); font-size:13px}

    /* 预设词区域，固定在搜索框下方（粘附在页面顶部） */
    .preset-bar{position:sticky; top:64px; z-index:70; background:transparent; padding:10px 20px; display:flex; gap:10px; align-items:center; overflow:auto}
    .preset-pill{background:var(--pill-bg); border-radius:999px; padding:8px 12px; font-size:13px; cursor:pointer; white-space:nowrap; border:1px solid transparent}
    .preset-pill.active{background:var(--pill-active-bg); border-color:var(--accent); color:var(--accent); box-shadow:0 2px 6px rgba(43,124,255,0.12)}

    /* 主体 */
    .container{max-width:1000px; margin:20px auto; padding:0 16px}

    /* 操作工具栏 */
    .toolbar{display:flex; gap:8px; align-items:center; margin-bottom:12px}
    .btn{background:var(--card-bg); border:1px solid #e3e6ee; padding:8px 10px; border-radius:8px; cursor:pointer; font-size:13px}
    .btn.primary{background:var(--accent); color:#fff; border-color:transparent}

    /* 结果列表 */
  .results{display:grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap:12px}
    .card{background:var(--card-bg); padding:12px; border-radius:10px; box-shadow:var(--shadow); border-left:6px solid transparent; cursor:pointer; display:flex; flex-direction:column; gap:6px}
  .card.selected{box-shadow:0 14px 36px rgba(43,124,255,0.18); transform: translateY(-6px); border-left-width:10px}
  .card-title{font-weight:600}
  .card-snippet{font-size:13px;color:#444;line-height:1.4}
  .match-count{font-size:12px;color:var(--muted);margin-left:8px}
  mark.matched{background:rgba(255,230,120,0.9); color:#111; padding:0 2px; border-radius:2px}
  .card-meta{font-size:13px; color:var(--muted)}
  .card-type{display:inline-block; padding:4px 8px; border-radius:999px; font-size:12px; color:#fff}
  /* 负向排除词 pill（粉色） */
  .negative-pill{background:#ffeef4; border-radius:999px; padding:8px 12px; font-size:13px; cursor:pointer; white-space:nowrap; border:1px solid transparent; color:#c23b6b}
  .negative-pill.active{background:#ffdfee; box-shadow:0 2px 6px rgba(194,59,107,0.08); border-color:#f0b6d0}
  .negative-bar{position:sticky; top:104px; z-index:69}

    /* 选中高亮 */
    .card.highlighted{box-shadow:0 6px 20px rgba(43,124,255,0.12); transform: translateY(-2px)}

    /* 页脚占位，留出空间 */
    .spacer{height:120px}

    /* 响应 */
    @media (max-width:640px){
      .container{padding:0 10px}
      .topbar{padding:10px}
      .preset-bar{top:56px}
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="search-input-wrap">
      <input id="searchInput" class="search-input" placeholder="搜索知识库：输入关键字或选择下方预设" />
      <div id="searchCount" class="search-count">0 条结果</div>
    </div>
    <div>
      <button id="clearBtn" class="btn">清空</button>
    </div>
  </div>

  <div class="preset-bar" id="presetBar">
    <!-- 预设词标签将在 JS 中渲染 -->
    </div>
    <div class="preset-bar" id="typeBar" style="margin-top:4px">
      <!-- 类型筛选 pill 将在 JS 中渲染 -->
    </div>
    <div class="preset-bar" id="negativeBar" style="margin-top:4px">
      <!-- 负向排除词（粉色）将在 JS 中渲染 -->
    </div>

  <div class="container">
    <div class="toolbar" id="toolbar">
      <button class="btn" id="locateBtn">定位</button>
      <button class="btn" id="copyUrlBtn">复制 URL</button>
      <button class="btn" id="copyMdBtn">复制 Markdown 链接</button>
      <button class="btn primary" id="multiActionBtn">对所选执行操作</button>
      <div style="flex:1"></div>
      <div class="search-count" id="selectionInfo">未选中</div>
    </div>

    <div class="results" id="results"></div>

    <div class="spacer"></div>
  </div>

  <script>
    // 假数据：更具代表性的卡片列表，包含多词短语以演示精确短语匹配
    const fakeCards = [
      {id: 'card-1001', title: '机器学习概述', type: '定义', color:'#7bb8ff', searchText: '机器学习 基本概念 监督学习 无监督学习'},
      {id: 'card-1002', title: '深度学习与神经网络', type: '知识', color:'#ffd07b', searchText: '深度学习 神经网络 卷积神经网络 CNN RNN'},
      {id: 'card-1003', title: '支持向量机（SVM）', type: '定义', color:'#ff7b7b', searchText: '支持向量机 SVM 分类 算法'},
      {id: 'card-1004', title: '自然语言处理简介', type: '知识', color:'#7bd389', searchText: '自然语言处理 NLP 词向量 BERT'},
      {id: 'card-1005', title: '卷积 神经 网络 详解', type: '归类', color:'#7bb8ff', searchText: '卷积 神经 网络 卷积 池化'},
      {id: 'card-1006', title: '优化算法对比', type: '知识', color:'#ffd07b', searchText: '梯度下降 Adam RMSprop 优化'},
      {id: 'card-1007', title: '检索系统概念', type: '定义', color:'#ff7b7b', searchText: '信息检索 搜索 排序 倒排索引'},
      {id: 'card-1008', title: '注意力机制（Attention）', type: '知识', color:'#7bd389', searchText: '注意力 机制 Transformer 自注意力'},
  {id: 'card-1009', title: '半监督学习实例', type: '知识', color:'#7bb8ff', searchText: '半监督 学习 实例 应用'},
  {id: 'card-1010', title: 'Evaluation Metrics', type: '定义', color:'#ffd07b', searchText: 'precision recall F1 score 混淆矩阵'},
  {id: 'card-1011', title: 'Neural Network Architectures', type: '归类', color:'#ff7b7b', searchText: 'MLP CNN RNN Transformer architectures'},
  {id: 'card-1012', title: 'Embedding Techniques', type: '知识', color:'#7bd389', searchText: '词向量 embedding word2vec GloVe BERT'},
  // 以下是为测试负向排除词准备的示例卡片
  {id: 'card-2001', title: '复 Hilbert 空间 中的性质', type: '定义', color:'#ffb6c1', searchText: 'Hilbert 空间 复 数 线性 代数'},
  {id: 'card-2002', title: '实 Hilbert 空间 示例', type: '定义', color:'#ffb6c1', searchText: 'Hilbert 空间 实 数 例子'},
  {id: 'card-2003', title: '多项式 回归 的鲁棒性', type: '知识', color:'#ffc0cb', searchText: '回归 多项式 回归 过拟合'},
  {id: 'card-2004', title: '噪声 分析 方法', type: '知识', color:'#ffccd9', searchText: '噪声 信号 过滤 去噪'},
  {id: 'card-2005', title: '异常 值 检测 技术', type: '知识', color:'#ffd6e8', searchText: '异常 值 检测 异常 数据'},
    ]

  // 预设词（可包含空格作为精确短语）
  const presets = ['机器学习','深度学习','支持向量机','卷积 神经 网络','自然语言处理','优化','检索']
  // 负向排除词（粉色），选中后将从结果中排除标题包含该词的卡片
  const negativePresets = ['复','多项式 回归','噪声','异常 值']

  // 状态
  let activePresets = new Set()
  let activeNegativePresets = new Set()
  // 支持多选（Set）
  let selectedCardIds = new Set()
  // 类型筛选
  const typesList = ['所有类型','归类','所有知识点','定义','命题','例子','反例','思想方法']
  let currentTypeFilter = '所有类型'
  // 保存用户实际输入的文本（不包含由预设自动追加的词）
  let userTyped = ''

    // 元素
    const presetBar = document.getElementById('presetBar')
    const resultsEl = document.getElementById('results')
    const searchInput = document.getElementById('searchInput')
    const searchCount = document.getElementById('searchCount')
    const selectionInfo = document.getElementById('selectionInfo')

    // 初始化预设词
    function renderPresets(){
      presetBar.innerHTML = ''
      presets.forEach(p =>{
        const el = document.createElement('div')
        el.className = 'preset-pill'
        el.textContent = p
        el.dataset.preset = p
        el.addEventListener('click', () => {
          if (activePresets.has(p)) {
            activePresets.delete(p)
            el.classList.remove('active')
          } else {
            activePresets.add(p)
            el.classList.add('active')
          }
          syncInputWithPresets()
          doSearch()
        })
        presetBar.appendChild(el)
      })
    }

      // 渲染负向排除词
      function renderNegativePresets(){
        const negBar = document.getElementById('negativeBar')
        negBar.innerHTML = ''
        negativePresets.forEach(p =>{
          const el = document.createElement('div')
          el.className = 'negative-pill'
          el.textContent = p
          el.dataset.preset = p
          el.addEventListener('click', () => {
            if (activeNegativePresets.has(p)) {
              activeNegativePresets.delete(p)
              el.classList.remove('active')
            } else {
              activeNegativePresets.add(p)
              el.classList.add('active')
            }
            // 负向词不同步到输入框，直接重新搜索排除匹配标题的项
            doSearch()
          })
          negBar.appendChild(el)
        })
      }

      // 渲染类型筛选 pill
      function renderTypeBar(){
        const typeBar = document.getElementById('typeBar')
        typeBar.innerHTML = ''
        typesList.forEach(t=>{
          const el = document.createElement('div')
          el.className = 'preset-pill'
          if (t === currentTypeFilter) el.classList.add('active')
          el.textContent = t
          el.dataset.type = t
          el.addEventListener('click', ()=>{
            currentTypeFilter = t
            // 更新样式
            typeBar.querySelectorAll('.preset-pill').forEach(x=>x.classList.remove('active'))
            el.classList.add('active')
            doSearch()
          })
          typeBar.appendChild(el)
        })
      }

    // 将选中的预设同步到输入框里（作为输入的一部分）
    // 语义：预设与用户输入之间用双空格分隔，这样包含单空格的短语可以作为精确短语保留
    function syncInputWithPresets(){
      const arr = Array.from(activePresets)
      if (arr.length === 0) {
        searchInput.value = userTyped
      } else {
        if (userTyped && userTyped.length) {
          searchInput.value = userTyped + '  ' + arr.join('  ')
        } else {
          searchInput.value = arr.join('  ')
        }
      }
    }

    // 在用户输入时，提取 userTyped：如果存在双空格，则取第一个双空格前的部分作为 userTyped
    function updateUserTypedFromInput(text){
      if (text.includes('  ')) {
        userTyped = text.split(/\s{2,}/)[0].trim()
      } else {
        // 没有双空格时，整个文本视作 userTyped（按单空格拆分用于搜索）
        userTyped = text.trim()
      }
    }

    // 渲染结果
    function renderResults(items){
      resultsEl.innerHTML = ''
      items.forEach(card =>{
        const el = document.createElement('div')
        el.className = 'card'
        el.dataset.id = card.id
        el.style.borderLeftColor = card.color

        const title = document.createElement('div')
        title.className = 'card-title'
        if (card.titleHtml) title.innerHTML = card.titleHtml
        else title.textContent = card.title

        const meta = document.createElement('div')
        meta.className = 'card-meta'
        const typeEl = document.createElement('span')
        typeEl.className = 'card-type'
        typeEl.textContent = card.type
        typeEl.style.background = card.color
        meta.appendChild(typeEl)
        meta.appendChild(document.createTextNode('  •  ' + card.id))
        if (card.matchCount) {
          const mc = document.createElement('span')
          mc.className = 'match-count'
          mc.textContent = `匹配 ${card.matchCount}`
          meta.appendChild(mc)
        }

        el.appendChild(title)
        el.appendChild(meta)
        if (card.snippetHtml) {
          const sn = document.createElement('div')
          sn.className = 'card-snippet'
          sn.innerHTML = card.snippetHtml
          el.appendChild(sn)
        }

        // 点击选中
        // 点击切换选中状态（支持多选）
        el.addEventListener('click', (e)=>{
          if (selectedCardIds.has(card.id)) {
            selectedCardIds.delete(card.id)
            el.classList.remove('selected')
          } else {
            selectedCardIds.add(card.id)
            el.classList.add('selected')
          }
          if (selectedCardIds.size === 0) selectionInfo.textContent = '未选中'
          else selectionInfo.textContent = `已选 ${selectedCardIds.size} 项`
        })
        resultsEl.appendChild(el)
      })
      searchCount.textContent = `${items.length} 条结果`
    }

    // 解析搜索 tokens：若包含双空格则以双空格为分隔（双空格分隔后保留单空格短语作为精确短语），否则按单空格分割
    // 返回 { tokens: [...], isDoubleSep: boolean }
    function parseSearchTokens(text){
      if (!text || !text.trim()) return {tokens: [], isDoubleSep:false}
      if (text.includes('  ')) {
        return { tokens: text.split(/\s{2,}/).map(t=>t.trim()).filter(Boolean), isDoubleSep: true }
      } else {
        return { tokens: text.split(/\s+/).map(t=>t.trim()).filter(Boolean), isDoubleSep: false }
      }
    }

    // 工具：转义正则特殊字符
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // 高亮文本（优先长词匹配），返回 HTML 字符串
    function highlightTextWithTokens(text, tokens){
      if (!tokens || tokens.length === 0) return text
      const placeholders = []
      let tmp = text
      const sorted = tokens.slice().sort((a,b)=>b.length - a.length)
      let idx = 0
      for (const tok of sorted) {
        if (!tok) continue
        const re = new RegExp(escapeRegExp(tok), 'ig')
        tmp = tmp.replace(re, match => {
          const key = `__HL_${idx}__`
          placeholders.push({key, text: match})
          idx++
          return key
        })
      }
      for (const ph of placeholders) {
        tmp = tmp.replace(ph.key, `<mark class="matched">${ph.text}</mark>`)
      }
      return tmp
    }

    // 防抖辅助
    function debounce(fn, wait){
      let t = null
      return function(...args){
        clearTimeout(t)
        t = setTimeout(()=>fn.apply(this, args), wait)
      }
    }

    // 搜索：评分、过滤、排序并准备高亮片段
    function doSearch(){
      const raw = searchInput.value || ''
      const parsed = parseSearchTokens(raw)
      const tokens = parsed.tokens.map(t=>t.toLowerCase())
      const useAnd = parsed.isDoubleSep
      if (!tokens.length) {
        renderResults(fakeCards)
        return
      }

      const scored = fakeCards.map(card => {
        const txt = (card.searchText + ' ' + card.title + ' ' + card.type).toLowerCase()
        let score = 0
        let matchCount = 0
        const matched = []
        for (const tok of tokens) {
          if (!tok) continue
          const inTitle = card.title.toLowerCase().includes(tok)
          const inType = (card.type || '').toLowerCase().includes(tok)
          const inText = (card.searchText || '').toLowerCase().includes(tok)
          if (inTitle) { score += 50; matchCount++; matched.push(tok); }
          if (inType) { score += 30; matchCount++; matched.push(tok); }
          if (inText) { score += 10; matchCount++; matched.push(tok); }
        }
        return Object.assign({}, card, {score, matchCount, matched})
      })

      const filtered = scored.filter(card => {
        if (!useAnd) return card.matchCount > 0
        const txt = (card.searchText + ' ' + card.title + ' ' + card.type).toLowerCase()
        return tokens.every(tok => txt.includes(tok))
      })

      filtered.sort((a,b)=> (b.score - a.score) || a.title.localeCompare(b.title))

      const tokensForHighlight = parsed.tokens
      const prepared = filtered.map(card => {
        const titleHtml = highlightTextWithTokens(card.title, tokensForHighlight)
        let snippet = card.searchText
        const lower = card.searchText.toLowerCase()
        let firstIdx = -1
        for (const tok of tokens) {
          const i = lower.indexOf(tok)
          if (i >= 0 && (firstIdx === -1 || i < firstIdx)) firstIdx = i
        }
        if (firstIdx >= 0) {
          const start = Math.max(0, firstIdx - 20)
          snippet = (start > 0 ? '...':'') + card.searchText.substring(start, Math.min(card.searchText.length, firstIdx + 60)) + (firstIdx + 60 < card.searchText.length ? '...':'')
        } else if (snippet.length > 100) {
          snippet = snippet.substring(0, 100) + '...'
        }
        const snippetHtml = highlightTextWithTokens(snippet, tokensForHighlight)
        return Object.assign({}, card, {titleHtml, snippetHtml})
      })

      // 负向排除：如果 activeNegativePresets 中包含某项且标题包含该项，则排除
      let final = prepared
      if (activeNegativePresets && activeNegativePresets.size > 0) {
        const negs = Array.from(activeNegativePresets).map(s=>s.toLowerCase())
        final = prepared.filter(card => {
          const t = (card.title || '').toLowerCase()
          for (const neg of negs) {
            if (!neg) continue
            if (t.includes(neg)) return false
          }
          return true
        })
      }

      // 类型过滤：根据 currentTypeFilter 进一步筛选 final（'所有类型'不过滤）
      if (currentTypeFilter && currentTypeFilter !== '所有类型') {
        const cf = currentTypeFilter
        if (cf === '归类') {
          final = final.filter(c => (c.type || '').toLowerCase() === '归类')
        } else if (cf === '所有知识点') {
          // 包含常见知识类类型
          const know = ['知识','定义','归类','命题','例子','反例','思想方法']
          final = final.filter(c => know.includes((c.type || '')))
        } else {
          // 具体知识点，匹配类型相等或包含
          final = final.filter(c => (c.type || '').toLowerCase() === cf.toLowerCase() || (c.type || '').indexOf(cf) >= 0)
        }
      }

      // 清理已选的 ID，如果某些已选项不在当前 final 列表中，则取消选中
      const visibleIds = new Set(final.map(c=>c.id))
      for (const id of Array.from(selectedCardIds)) {
        if (!visibleIds.has(id)) selectedCardIds.delete(id)
      }
      selectionInfo.textContent = selectedCardIds.size ? `已选 ${selectedCardIds.size} 项` : '未选中'

      renderResults(final)
    }

    // 工具栏操作
    document.getElementById('locateBtn').addEventListener('click', ()=>{
      if (selectedCardIds.size === 0) return alert('请先选择一张卡片')
      alert('定位卡片: ' + Array.from(selectedCardIds).join(', '))
    })
    document.getElementById('copyUrlBtn').addEventListener('click', ()=>{
      if (selectedCardIds.size === 0) return alert('请先选择一张卡片')
      const urls = Array.from(selectedCardIds).map(id=>`marginnote4app://note/${id}`).join('\n')
      navigator.clipboard?.writeText(urls).then(()=>alert('已复制 URL 列表'), ()=>alert('复制失败'))
    })
    document.getElementById('copyMdBtn').addEventListener('click', ()=>{
      if (selectedCardIds.size === 0) return alert('请先选择一张卡片')
      const mds = Array.from(selectedCardIds).map(id=>{
        const card = fakeCards.find(c=>c.id===id) || {title:id}
        return `[${card.title}](marginnote4app://note/${id})`
      }).join('\n')
      navigator.clipboard?.writeText(mds).then(()=>alert('已复制 Markdown 列表'), ()=>alert('复制失败'))
    })
    document.getElementById('multiActionBtn').addEventListener('click', ()=>{
      if (selectedCardIds.size === 0) return alert('请先选择一张卡片')
      alert('对卡片执行操作: ' + Array.from(selectedCardIds).join(', '))
    })

    // 清空
    document.getElementById('clearBtn').addEventListener('click', ()=>{
      searchInput.value = ''
      userTyped = ''
      activePresets.clear()
      activeNegativePresets.clear()
      currentTypeFilter = '所有类型'
      document.querySelectorAll('.preset-pill.active').forEach(el=>el.classList.remove('active'))
      document.querySelectorAll('.negative-pill.active').forEach(el=>el.classList.remove('active'))
      doSearch()
    })

    // 输入监听：使用防抖以减少频繁计算
    const debouncedSearch = debounce(()=>{
      updateUserTypedFromInput(searchInput.value)
      doSearch()
    }, 180)
    searchInput.addEventListener('input', debouncedSearch)

    // 初始化
    renderPresets()
    renderTypeBar()
    renderNegativePresets()
    renderResults(fakeCards)
  </script>
</body>
</html>